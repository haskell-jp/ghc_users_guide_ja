
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.3. Optimisation (code improvement) &mdash; Glasgow Haskell Compiler 8.2.2 User&#39;s Guide</title>
    
    <link rel="stylesheet" href="_static/ghc-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Search within Glasgow Haskell Compiler 8.2.2 User&#39;s Guide"
          href="_static/opensearch.xml"/>
    <link rel="top" title="Glasgow Haskell Compiler 8.2.2 User&#39;s Guide" href="index.html" />
    <link rel="up" title="7. Using GHC" href="usage.html" />
    <link rel="next" title="7.4. Using Concurrent Haskell" href="using-concurrent.html" />
    <link rel="prev" title="7.2. Warnings and sanity-checking" href="using-warnings.html" /> 
  </head>
  <body>
<div class="logo">
    <h1><a href="index.html">Glasgow Haskell Compiler User's Guide</a></h1>
</div>

    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="using-concurrent.html" title="7.4. Using Concurrent Haskell"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="using-warnings.html" title="7.2. Warnings and sanity-checking"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">GHC 8.2.2 User&#39;s Guide</a> &raquo;</li>
          <li><a href="usage.html" accesskey="U">7. Using GHC</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="using-optimisation.html#">7.3. Optimisation (code improvement)</a><ul>
<li><a class="reference internal" href="using-optimisation.html#o-convenient-packages-of-optimisation-flags">7.3.1. <tt class="docutils literal"><span class="pre">-O*</span></tt>: convenient “packages” of optimisation flags.</a></li>
<li><a class="reference internal" href="using-optimisation.html#f-platform-independent-flags">7.3.2. <tt class="docutils literal"><span class="pre">-f*</span></tt>: platform-independent flags</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="using-warnings.html"
                        title="previous chapter">7.2. Warnings and sanity-checking</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="using-concurrent.html"
                        title="next chapter">7.4. Using Concurrent Haskell</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/using-optimisation.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="optimisation-code-improvement">
<span id="options-optimise"></span><h1>7.3. Optimisation (code improvement)<a class="headerlink" href="using-optimisation.html#optimisation-code-improvement" title="Permalink to this headline">¶</a></h1>
<p id="index-0">The <tt class="docutils literal"><span class="pre">-O*</span></tt> options specify convenient &#8220;packages&#8221; of optimisation flags;
the <tt class="docutils literal"><span class="pre">-f*</span></tt> options described later on specify <em>individual</em>
optimisations to be turned on/off; the <tt class="docutils literal"><span class="pre">-m*</span></tt> options specify
<em>machine-specific</em> optimisations to be turned on/off.</p>
<p>Most of these options are boolean and have options to turn them both &#8220;on&#8221; and
&#8220;off&#8221; (beginning with the prefix <tt class="docutils literal"><span class="pre">no-</span></tt>). For instance, while <tt class="docutils literal"><span class="pre">-fspecialise</span></tt>
enables specialisation, <tt class="docutils literal"><span class="pre">-fno-specialise</span></tt> disables it. When multiple flags for
the same option appear in the command-line they are evaluated from left to
right. For instance, <tt class="docutils literal"><span class="pre">-fno-specialise</span> <span class="pre">-fspecialise</span></tt> will enable
specialisation.</p>
<p>It is important to note that the <tt class="docutils literal"><span class="pre">-O*</span></tt> flags are roughly equivalent to
combinations of <tt class="docutils literal"><span class="pre">-f*</span></tt> flags. For this reason, the effect of the
<tt class="docutils literal"><span class="pre">-O*</span></tt> and <tt class="docutils literal"><span class="pre">-f*</span></tt> flags is dependent upon the order in which they
occur on the command line.</p>
<p>For instance, take the example of <tt class="docutils literal"><span class="pre">-fno-specialise</span> <span class="pre">-O1</span></tt>. Despite the
<tt class="docutils literal"><span class="pre">-fno-specialise</span></tt> appearing in the command line, specialisation will
still be enabled. This is the case as <tt class="docutils literal"><span class="pre">-O1</span></tt> implies <tt class="docutils literal"><span class="pre">-fspecialise</span></tt>,
overriding the previous flag. By contrast, <tt class="docutils literal"><span class="pre">-O1</span> <span class="pre">-fno-specialise</span></tt> will
compile without specialisation, as one would expect.</p>
<div class="section" id="o-convenient-packages-of-optimisation-flags">
<span id="optimise-pkgs"></span><h2>7.3.1. <tt class="docutils literal"><span class="pre">-O*</span></tt>: convenient “packages” of optimisation flags.<a class="headerlink" href="using-optimisation.html#o-convenient-packages-of-optimisation-flags" title="Permalink to this headline">¶</a></h2>
<p>There are <em>many</em> options that affect the quality of code produced by
GHC. Most people only have a general goal, something like &#8220;Compile
quickly&#8221; or &#8220;Make my program run like greased lightning.&#8221; The following
&#8220;packages&#8221; of optimisations (or lack thereof) should suffice.</p>
<p>Note that higher optimisation levels cause more cross-module
optimisation to be performed, which can have an impact on how much of
your program needs to be recompiled when you change something. This is
one reason to stick to no-optimisation when developing code.</p>
<p><strong>No ``-O*``-type option specified:</strong> This is taken to mean “Please
compile quickly; I&#8217;m not over-bothered about compiled-code quality.”
So, for example, <tt class="docutils literal"><span class="pre">ghc</span> <span class="pre">-c</span> <span class="pre">Foo.hs</span></tt></p>
<dl class="ghc-flag">
<dt id="ghc-flag--O0">
<tt class="descname">-O0</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--O0" title="Permalink to this definition">¶</a></dt>
<dd><p>Means &#8220;turn off all optimisation&#8221;, reverting to the same settings as
if no <tt class="docutils literal"><span class="pre">-O</span></tt> options had been specified. Saying <tt class="docutils literal"><span class="pre">-O0</span></tt> can be
useful if e.g. <tt class="docutils literal"><span class="pre">make</span></tt> has inserted a <tt class="docutils literal"><span class="pre">-O</span></tt> on the command line
already.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--O">
<tt class="descname">-O</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--O" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--O1">
<tt class="descname">-O1</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--O1" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-1">Means: &#8220;Generate good-quality code without taking too long about
it.&#8221; Thus, for example: <tt class="docutils literal"><span class="pre">ghc</span> <span class="pre">-c</span> <span class="pre">-O</span> <span class="pre">Main.lhs</span></tt></p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--O2">
<tt class="descname">-O2</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--O2" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-2">Means: &#8220;Apply every non-dangerous optimisation, even if it means
significantly longer compile times.&#8221;</p>
<p>The avoided &#8220;dangerous&#8221; optimisations are those that can make
runtime or space <em>worse</em> if you&#8217;re unlucky. They are normally turned
on or off individually.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--Odph">
<tt class="descname">-Odph</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--Odph" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-3">Enables all <tt class="docutils literal"><span class="pre">-O2</span></tt> optimisation, sets
<tt class="docutils literal"><span class="pre">-fmax-simplifier-iterations=20</span></tt> and <tt class="docutils literal"><span class="pre">-fsimplifier-phases=3</span></tt>.
Designed for use with <a class="reference internal" href="parallel.html#dph"><em>Data Parallel Haskell (DPH)</em></a>.</p>
</dd></dl>

<p>We don&#8217;t use a <tt class="docutils literal"><span class="pre">-O*</span></tt> flag for day-to-day work. We use <tt class="docutils literal"><span class="pre">-O</span></tt> to get
respectable speed; e.g., when we want to measure something. When we want
to go for broke, we tend to use <tt class="docutils literal"><span class="pre">-O2</span></tt> (and we go for lots of coffee
breaks).</p>
<p>The easiest way to see what <tt class="docutils literal"><span class="pre">-O</span></tt> (etc.) “really mean” is to run with
<a class="reference internal" href="using.html#ghc-flag--v"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-v</span></tt></a>, then stand back in amazement.</p>
</div>
<div class="section" id="f-platform-independent-flags">
<span id="options-f"></span><h2>7.3.2. <tt class="docutils literal"><span class="pre">-f*</span></tt>: platform-independent flags<a class="headerlink" href="using-optimisation.html#f-platform-independent-flags" title="Permalink to this headline">¶</a></h2>
<p id="index-4">These flags turn on and off individual optimisations. Flags marked as
on by default are enabled by <tt class="docutils literal"><span class="pre">-O</span></tt>, and as such you shouldn&#8217;t
need to set any of them explicitly. A flag <tt class="docutils literal"><span class="pre">-fwombat</span></tt> can be negated
by saying <tt class="docutils literal"><span class="pre">-fno-wombat</span></tt>.</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fcase-merge">
<tt class="descname">-fcase-merge</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fcase-merge" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Merge immediately-nested case expressions that scrutinise the same variable.
For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Red</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
            <span class="kt">Blue</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
            <span class="kt">Green</span> <span class="ow">-&gt;</span> <span class="n">e3</span>
</pre></div>
</div>
<p>Is transformed to,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Red</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="kt">Blue</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
   <span class="kt">Green</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
</pre></div>
</div>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcase-folding">
<tt class="descname">-fcase-folding</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fcase-folding" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Allow constant folding in case expressions that scrutinise some primops:
For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="p">`</span><span class="n">minusWord</span><span class="o">#</span><span class="p">`</span> <span class="mi">10</span><span class="o">##</span> <span class="kr">of</span>
   <span class="mi">10</span><span class="o">##</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="mi">20</span><span class="o">##</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
   <span class="n">v</span>    <span class="ow">-&gt;</span> <span class="n">e3</span>
</pre></div>
</div>
<p>Is transformed to,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="mi">20</span><span class="o">##</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="mi">30</span><span class="o">##</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
   <span class="kr">_</span>    <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">minusWord</span><span class="o">#</span><span class="p">`</span> <span class="mi">10</span><span class="o">##</span> <span class="kr">in</span> <span class="n">e3</span>
</pre></div>
</div>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcall-arity">
<tt class="descname">-fcall-arity</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fcall-arity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Enable call-arity analysis.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcmm-elim-common-blocks">
<tt class="descname">-fcmm-elim-common-blocks</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fcmm-elim-common-blocks" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Enables the common block elimination optimisation
in the code generator. This optimisation attempts to find identical
Cmm blocks and eliminate the duplicates.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcmm-sink">
<tt class="descname">-fcmm-sink</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fcmm-sink" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Enables the sinking pass in the code generator.
This optimisation attempts to find identical Cmm blocks and
eliminate the duplicates attempts to move variable bindings closer
to their usage sites. It also inlines simple expressions like
literals or registers.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcpr-off">
<tt class="descname">-fcpr-off</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fcpr-off" title="Permalink to this definition">¶</a></dt>
<dd><p>Switch off CPR analysis in the demand analyser.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcse">
<tt class="descname">-fcse</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fcse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Enables the common-sub-expression elimination
optimisation. Switching this off can be useful if you have some
<tt class="docutils literal"><span class="pre">unsafePerformIO</span></tt> expressions that you don&#8217;t want commoned-up.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstg-cse">
<tt class="descname">-fstg-cse</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fstg-cse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Enables the common-sub-expression elimination optimisation on the STG
intermediate language, where it is able to common up some subexpressions
that differ in their types, but not their represetation.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdicts-cheap">
<tt class="descname">-fdicts-cheap</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fdicts-cheap" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>A very experimental flag that makes dictionary-valued expressions
seem cheap to the optimiser.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdicts-strict">
<tt class="descname">-fdicts-strict</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fdicts-strict" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Make dictionaries strict.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdmd-tx-dict-sel">
<tt class="descname">-fdmd-tx-dict-sel</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fdmd-tx-dict-sel" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Use a special demand transformer for dictionary selectors.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdo-eta-reduction">
<tt class="descname">-fdo-eta-reduction</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fdo-eta-reduction" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Eta-reduce lambda expressions, if doing so gets rid of a whole group of
lambdas.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdo-lambda-eta-expansion">
<tt class="descname">-fdo-lambda-eta-expansion</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fdo-lambda-eta-expansion" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Eta-expand let-bindings to increase their arity.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--feager-blackholing">
<tt class="descname">-feager-blackholing</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--feager-blackholing" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Usually GHC black-holes a thunk only when it switches threads. This
flag makes it do so as soon as the thunk is entered. See <a class="reference external" href="http://community.haskell.org/~simonmar/papers/multiproc.pdf">Haskell on
a shared-memory
multiprocessor</a>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fexcess-precision">
<tt class="descname">-fexcess-precision</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fexcess-precision" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>When this option is given, intermediate floating point values can
have a <em>greater</em> precision/range than the final type. Generally this
is a good thing, but some programs may rely on the exact
precision/range of <tt class="docutils literal"><span class="pre">Float</span></tt>/<tt class="docutils literal"><span class="pre">Double</span></tt> values and should not use
this option for their compilation.</p>
<p>Note that the 32-bit x86 native code generator only supports
excess-precision mode, so neither <tt class="docutils literal"><span class="pre">-fexcess-precision</span></tt> nor
<tt class="docutils literal"><span class="pre">-fno-excess-precision</span></tt> has any effect. This is a known bug, see
<a class="reference internal" href="bugs.html#bugs-ghc"><em>Bugs in GHC</em></a>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fexpose-all-unfoldings">
<tt class="descname">-fexpose-all-unfoldings</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fexpose-all-unfoldings" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>An experimental flag to expose all unfoldings, even for very large
or recursive functions. This allows for all functions to be inlined
while usually GHC would avoid inlining larger functions.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ffloat-in">
<tt class="descname">-ffloat-in</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--ffloat-in" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Float let-bindings inwards, nearer their binding
site. See <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs
(ICFP&#8216;96)</a>.</p>
<p>This optimisation moves let bindings closer to their use site. The
benefit here is that this may avoid unnecessary allocation if the
branch the let is now on is never executed. It also enables other
optimisation passes to work more effectively as they have more
information locally.</p>
<p>This optimisation isn&#8217;t always beneficial though (so GHC applies
some heuristics to decide when to apply it). The details get
complicated but a simple example is that it is often beneficial to
move let bindings outwards so that multiple let bindings can be
grouped into a larger single let binding, effectively batching their
allocation and helping the garbage collector and allocator.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ffull-laziness">
<tt class="descname">-ffull-laziness</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--ffull-laziness" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Run the full laziness optimisation (also known as
let-floating), which floats let-bindings outside enclosing lambdas,
in the hope they will be thereby be computed less often. See
<a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs
(ICFP&#8216;96)</a>.
Full laziness increases sharing, which can lead to increased memory
residency.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">GHC doesn&#8217;t implement complete full-laziness. When
optimisation in on, and <tt class="docutils literal"><span class="pre">-fno-full-laziness</span></tt> is not given, some
transformations that increase sharing are performed, such as
extracting repeated computations from a loop. These are the same
transformations that a fully lazy implementation would do, the
difference is that GHC doesn&#8217;t consistently apply full-laziness, so
don&#8217;t rely on it.</p>
</div>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ffun-to-thunk">
<tt class="descname">-ffun-to-thunk</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--ffun-to-thunk" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Worker-wrapper removes unused arguments, but usually we do not
remove them all, lest it turn a function closure into a thunk,
thereby perhaps creating a space leak and/or disrupting inlining.
This flag allows worker/wrapper to remove <em>all</em> value lambdas.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fignore-asserts">
<tt class="descname">-fignore-asserts</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fignore-asserts" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Causes GHC to ignore uses of the function <tt class="docutils literal"><span class="pre">Exception.assert</span></tt> in source
code (in other words, rewriting <tt class="docutils literal"><span class="pre">Exception.assert</span> <span class="pre">p</span> <span class="pre">e</span></tt> to <tt class="docutils literal"><span class="pre">e</span></tt> (see
<a class="reference internal" href="glasgow_exts.html#assertions"><em>Assertions</em></a>).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fignore-interface-pragmas">
<tt class="descname">-fignore-interface-pragmas</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fignore-interface-pragmas" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Tells GHC to ignore all inessential information when reading
interface files. That is, even if <tt class="file docutils literal"><span class="pre">M.hi</span></tt> contains unfolding or
strictness information for a function, GHC will ignore that
information.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--flate-dmd-anal">
<tt class="descname">-flate-dmd-anal</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--flate-dmd-anal" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Run demand analysis again, at the end of the simplification
pipeline. We found some opportunities for discovering strictness
that were not visible earlier; and optimisations like
<a class="reference internal" href="using-optimisation.html#ghc-flag--fspec-constr"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-fspec-constr</span></tt></a> can create functions with unused arguments which
are eliminated by late demand analysis. Improvements are modest, but
so is the cost. See notes on the <a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/LateDmd">Trac wiki page</a>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fliberate-case">
<tt class="descname">-fliberate-case</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fliberate-case" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off but enabled with <a class="reference internal" href="using-optimisation.html#ghc-flag--O2"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-O2</span></tt></a>.</td>
</tr>
</tbody>
</table>
<p>Turn on the liberate-case transformation. This unrolls recursive function
once in its own RHS, to avoid repeated case analysis of free variables. It&#8217;s
a bit like the call-pattern specialiser (<a class="reference internal" href="using-optimisation.html#ghc-flag--fspec-constr"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-fspec-constr</span></tt></a>) but for
free variables rather than arguments.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fliberate-case-threshold=⟨n⟩">
<tt class="descname">-fliberate-case-threshold</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fliberate-case-threshold=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">2000</td>
</tr>
</tbody>
</table>
<p>Set the size threshold for the liberate-case transformation.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--floopification">
<tt class="descname">-floopification</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--floopification" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>When this optimisation is enabled the code generator will turn all
self-recursive saturated tail calls into local jumps rather than
function calls.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-inline-alloc-size=⟨n⟩">
<tt class="descname">-fmax-inline-alloc-size</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fmax-inline-alloc-size=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">128</td>
</tr>
</tbody>
</table>
<p>Set the maximum size of inline array allocations to n bytes.
GHC will allocate non-pinned arrays of statically known size in the current
nursery block if they&#8217;re no bigger than n bytes, ignoring GC overheap. This
value should be quite a bit smaller than the block size (typically: 4096).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-inline-memcpy-insns=⟨n⟩">
<tt class="descname">-fmax-inline-memcpy-insns</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fmax-inline-memcpy-insns=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">32</td>
</tr>
</tbody>
</table>
<p>Inline <tt class="docutils literal"><span class="pre">memcpy</span></tt> calls if they would generate no more than ⟨n⟩ pseudo-instructions.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-inline-memset-insns=⟨n⟩">
<tt class="descname">-fmax-inline-memset-insns</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fmax-inline-memset-insns=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">32</td>
</tr>
</tbody>
</table>
<p>Inline <tt class="docutils literal"><span class="pre">memset</span></tt> calls if they would generate no more than n pseudo
instructions.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-relevant-binds=⟨n⟩">
<tt class="descname">-fmax-relevant-binds</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fmax-relevant-binds=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--fno-max-relevant-bindings">
<tt class="descname">-fno-max-relevant-bindings</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fno-max-relevant-bindings" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">6</td>
</tr>
</tbody>
</table>
<p>The type checker sometimes displays a fragment of the type
environment in error messages, but only up to some maximum number,
set by this flag. Turning it off with
<tt class="docutils literal"><span class="pre">-fno-max-relevant-bindings</span></tt> gives an unlimited number.
Syntactically top-level bindings are also usually excluded (since
they may be numerous), but <tt class="docutils literal"><span class="pre">-fno-max-relevant-bindings</span></tt> includes
them too.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-uncovered-patterns=⟨n⟩">
<tt class="descname">-fmax-uncovered-patterns</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fmax-uncovered-patterns=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">4</td>
</tr>
</tbody>
</table>
<p>Maximum number of unmatched patterns to be shown in warnings generated by
<a class="reference internal" href="using-warnings.html#ghc-flag--Wincomplete-patterns"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-Wincomplete-patterns</span></tt></a> and <a class="reference internal" href="using-warnings.html#ghc-flag--Wincomplete-uni-patterns"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-Wincomplete-uni-patterns</span></tt></a>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-simplifier-iterations=⟨n⟩">
<tt class="descname">-fmax-simplifier-iterations</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fmax-simplifier-iterations=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">4</td>
</tr>
</tbody>
</table>
<p>Sets the maximal number of iterations for the simplifier.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-worker-args=⟨n⟩">
<tt class="descname">-fmax-worker-args</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fmax-worker-args=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">10</td>
</tr>
</tbody>
</table>
<p>If a worker has that many arguments, none will be unpacked anymore.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fno-opt-coercion">
<tt class="descname">-fno-opt-coercion</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fno-opt-coercion" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Turn off the coercion optimiser.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fno-pre-inlining">
<tt class="descname">-fno-pre-inlining</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fno-pre-inlining" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Turn off pre-inlining.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fno-state-hack">
<tt class="descname">-fno-state-hack</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fno-state-hack" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Turn off the &#8220;state hack&#8221; whereby any lambda with a <tt class="docutils literal"><span class="pre">State#</span></tt> token
as argument is considered to be single-entry, hence it is considered
okay to inline things inside it. This can improve performance of IO
and ST monad code, but it runs the risk of reducing sharing.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fomit-interface-pragmas">
<tt class="descname">-fomit-interface-pragmas</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fomit-interface-pragmas" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Tells GHC to omit all inessential information from the interface
file generated for the module being compiled (say M). This means
that a module importing M will see only the <em>types</em> of the functions
that M exports, but not their unfoldings, strictness info, etc.
Hence, for example, no function exported by M will be inlined into
an importing module. The benefit is that modules that import M will
need to be recompiled less often (only when M&#8217;s exports change their
type, not when they change their implementation).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fomit-yields">
<tt class="descname">-fomit-yields</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fomit-yields" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Tells GHC to omit heap checks when no allocation is
being performed. While this improves binary sizes by about 5%, it
also means that threads run in tight non-allocating loops will not
get preempted in a timely fashion. If it is important to always be
able to interrupt such threads, you should turn this optimization
off. Consider also recompiling all libraries with this optimization
turned off, if you need to guarantee interruptibility.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fpedantic-bottoms">
<tt class="descname">-fpedantic-bottoms</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fpedantic-bottoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Make GHC be more precise about its treatment of bottom (but see also
<a class="reference internal" href="using-optimisation.html#ghc-flag--fno-state-hack"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-fno-state-hack</span></tt></a>). In particular, stop GHC eta-expanding through
a case expression, which is good for performance, but bad if you are
using <tt class="docutils literal"><span class="pre">seq</span></tt> on partial applications.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fregs-graph">
<tt class="descname">-fregs-graph</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fregs-graph" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off due to a performance regression bug (<a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/7679">Trac #7679</a>)</td>
</tr>
</tbody>
</table>
<p><em>Only applies in combination with the native code generator.</em> Use the graph
colouring register allocator for register allocation in the native code
generator. By default, GHC uses a simpler, faster linear register allocator.
The downside being that the linear register allocator usually generates
worse code.</p>
<p>Note that the graph colouring allocator is a bit experimental and may fail
when faced with code with high register pressure <a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/8657">Trac #8657</a>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fregs-iterative">
<tt class="descname">-fregs-iterative</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fregs-iterative" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p><em>Only applies in combination with the native code generator.</em> Use the
iterative coalescing graph colouring register allocator for register
allocation in the native code generator. This is the same register allocator
as the <a class="reference internal" href="using-optimisation.html#ghc-flag--fregs-graph"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-fregs-graph</span></tt></a> one but also enables iterative coalescing
during register allocation.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fsimplifier-phases=⟨n⟩">
<tt class="descname">-fsimplifier-phases</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fsimplifier-phases=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">2</td>
</tr>
</tbody>
</table>
<p>Set the number of phases for the simplifier. Ignored with <tt class="docutils literal"><span class="pre">-O0</span></tt>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fsimpl-tick-factor=⟨n⟩">
<tt class="descname">-fsimpl-tick-factor</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fsimpl-tick-factor=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">100</td>
</tr>
</tbody>
</table>
<p>GHC&#8217;s optimiser can diverge if you write rewrite rules
(<a class="reference internal" href="glasgow_exts.html#rewrite-rules"><em>Rewrite rules</em></a>) that don&#8217;t terminate, or (less satisfactorily)
if you code up recursion through data types (<a class="reference internal" href="bugs.html#bugs-ghc"><em>Bugs in GHC</em></a>). To
avoid making the compiler fall into an infinite loop, the optimiser
carries a &#8220;tick count&#8221; and stops inlining and applying rewrite rules
when this count is exceeded. The limit is set as a multiple of the
program size, so bigger programs get more ticks. The
<tt class="docutils literal"><span class="pre">-fsimpl-tick-factor</span></tt> flag lets you change the multiplier. The
default is 100; numbers larger than 100 give more ticks, and numbers
smaller than 100 give fewer.</p>
<p>If the tick-count expires, GHC summarises what simplifier steps it
has done; you can use <tt class="docutils literal"><span class="pre">-fddump-simpl-stats</span></tt> to generate a much
more detailed list. Usually that identifies the loop quite
accurately, because some numbers are very large.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr">
<tt class="descname">-fspec-constr</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fspec-constr" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off but enabled by <a class="reference internal" href="using-optimisation.html#ghc-flag--O2"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-O2</span></tt></a>.</td>
</tr>
</tbody>
</table>
<p>Turn on call-pattern specialisation; see <a class="reference external" href="https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/">Call-pattern specialisation for
Haskell programs</a>.</p>
<p>This optimisation specializes recursive functions according to their
argument &#8220;shapes&#8221;. This is best explained by example so consider:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">last</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">last</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;last&quot;</span>
<span class="nf">last</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">last</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last</span> <span class="n">xs</span>
</pre></div>
</div>
<p>In this code, once we pass the initial check for an empty list we
know that in the recursive case this pattern match is redundant. As
such <tt class="docutils literal"><span class="pre">-fspec-constr</span></tt> will transform the above code to:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">last</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">last</span> <span class="kt">[]</span>       <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;last&quot;</span>
<span class="nf">last</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last&#39;</span> <span class="n">x</span> <span class="n">xs</span>
    <span class="kr">where</span>
      <span class="n">last&#39;</span> <span class="n">x</span> <span class="kt">[]</span>       <span class="ow">=</span> <span class="n">x</span>
      <span class="n">last&#39;</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last&#39;</span> <span class="n">y</span> <span class="n">ys</span>
</pre></div>
</div>
<p>As well avoid unnecessary pattern matching it also helps avoid
unnecessary allocation. This applies when a argument is strict in
the recursive call to itself but not on the initial entry. As strict
recursive branch of the function is created similar to the above
example.</p>
<p>It is also possible for library writers to instruct GHC to perform
call-pattern specialisation extremely aggressively. This is
necessary for some highly optimized libraries, where we may want to
specialize regardless of the number of specialisations, or the size
of the code. As an example, consider a simplified use-case from the
<tt class="docutils literal"><span class="pre">vector</span></tt> library:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">GHC.Types</span> <span class="p">(</span><span class="kt">SPEC</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>

<span class="nf">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="cm">{-# INLINE foldl #-}</span>
<span class="nf">foldl</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">step</span> <span class="n">s</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldl_loop</span> <span class="kt">SPEC</span> <span class="n">z</span> <span class="n">s</span>
  <span class="kr">where</span>
    <span class="n">foldl_loop</span> <span class="o">!</span><span class="n">sPEC</span> <span class="n">z</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">step</span> <span class="n">s</span> <span class="kr">of</span>
                            <span class="kt">Yield</span> <span class="n">x</span> <span class="n">s&#39;</span> <span class="ow">-&gt;</span> <span class="n">foldl_loop</span> <span class="n">sPEC</span> <span class="p">(</span><span class="n">f</span> <span class="n">z</span> <span class="n">x</span><span class="p">)</span> <span class="n">s&#39;</span>
                            <span class="kt">Skip</span>       <span class="ow">-&gt;</span> <span class="n">foldl_loop</span> <span class="n">sPEC</span> <span class="n">z</span> <span class="n">s&#39;</span>
                            <span class="kt">Done</span>       <span class="ow">-&gt;</span> <span class="n">z</span>
</pre></div>
</div>
<p>Here, after GHC inlines the body of <tt class="docutils literal"><span class="pre">foldl</span></tt> to a call site, it
will perform call-pattern specialisation very aggressively on
<tt class="docutils literal"><span class="pre">foldl_loop</span></tt> due to the use of <tt class="docutils literal"><span class="pre">SPEC</span></tt> in the argument of the
loop body. <tt class="docutils literal"><span class="pre">SPEC</span></tt> from <tt class="docutils literal"><span class="pre">GHC.Types</span></tt> is specifically recognised by
the compiler.</p>
<p>(NB: it is extremely important you use <tt class="docutils literal"><span class="pre">seq</span></tt> or a bang pattern on
the <tt class="docutils literal"><span class="pre">SPEC</span></tt> argument!)</p>
<p>In particular, after inlining this will expose <tt class="docutils literal"><span class="pre">f</span></tt> to the loop
body directly, allowing heavy specialisation over the recursive
cases.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr-keen">
<tt class="descname">-fspec-constr-keen</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fspec-constr-keen" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>If this flag is on, call-pattern specialisation will specialise a call
<tt class="docutils literal"><span class="pre">(f</span> <span class="pre">(Just</span> <span class="pre">x))</span></tt> with an explicit constructor argument, even if the argument
is not scrutinised in the body of the function. This is sometimes
beneficial; e.g. the argument might be given to some other function
that can itself be specialised.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr-count=⟨n⟩">
<tt class="descname">-fspec-constr-count</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fspec-constr-count=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">3</td>
</tr>
</tbody>
</table>
<p>Set the maximum number of specialisations that will be created for
any one function by the SpecConstr transformation.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr-threshold=⟨n⟩">
<tt class="descname">-fspec-constr-threshold</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fspec-constr-threshold=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">2000</td>
</tr>
</tbody>
</table>
<p>Set the size threshold for the SpecConstr transformation.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspecialise">
<tt class="descname">-fspecialise</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fspecialise" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Specialise each type-class-overloaded function
defined in this module for the types at which it is called in this
module. If <a class="reference internal" href="using-optimisation.html#ghc-flag--fcross-module-specialise"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-fcross-module-specialise</span></tt></a> is set imported functions
that have an INLINABLE pragma (<a class="reference internal" href="glasgow_exts.html#inlinable-pragma"><em>INLINABLE pragma</em></a>) will be
specialised as well.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspecialise-aggressively">
<tt class="descname">-fspecialise-aggressively</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fspecialise-aggressively" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>By default only type class methods and methods marked <tt class="docutils literal"><span class="pre">INLINABLE</span></tt> or
<tt class="docutils literal"><span class="pre">INLINE</span></tt> are specialised. This flag will specialise any overloaded function
regardless of size if its unfolding is available. This flag is not
included in any optimisation level as it can massively increase code
size. It can be used in conjunction with <a class="reference internal" href="using-optimisation.html#ghc-flag--fexpose-all-unfoldings"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-fexpose-all-unfoldings</span></tt></a>
if you want to ensure all calls are specialised.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcross-module-specialise">
<tt class="descname">-fcross-module-specialise</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fcross-module-specialise" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Specialise <tt class="docutils literal"><span class="pre">INLINABLE</span></tt> (<a class="reference internal" href="glasgow_exts.html#inlinable-pragma"><em>INLINABLE pragma</em></a>)
type-class-overloaded functions imported from other modules for the types at
which they are called in this module. Note that specialisation must be
enabled (by <tt class="docutils literal"><span class="pre">-fspecialise</span></tt>) for this to have any effect.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fsolve-constant-dicts">
<tt class="descname">-fsolve-constant-dicts</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fsolve-constant-dicts" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>When solving constraints, try to eagerly solve
super classes using available dictionaries.</p>
<p>For example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">class</span> <span class="kt">M</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span> <span class="n">m</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="kr">type</span> <span class="kt">C</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">M</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>

<span class="nf">f</span> <span class="ow">::</span> <span class="kt">C</span> <span class="kt">Int</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">f</span> <span class="kr">_</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>The body of <cite>f</cite> requires a <cite>Num Int</cite> instance. We could solve this
constraint from the context  because we have <cite>C Int b</cite> and that provides us
a
solution for <cite>Num Int</cite>. However, we can often produce much better code
by directly solving for an available <cite>Num Int</cite> dictionary we might have at
hand. This removes potentially many layers of indirection and crucially
allows other optimisations to fire as the dictionary will be statically
known and selector functions can be inlined.</p>
<p>The optimisation also works for GADTs which bind dictionaries. If we
statically know which class dictionary we need then we will solve it
directly rather than indirectly using the one passed in at run time.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstatic-argument-transformation">
<tt class="descname">-fstatic-argument-transformation</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fstatic-argument-transformation" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Turn on the static argument transformation, which turns a recursive
function into a non-recursive one with a local recursive loop. See
Chapter 7 of <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/santos-thesis.ps.gz">Andre Santos&#8217;s PhD
thesis</a></p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstrictness">
<tt class="descname">-fstrictness</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fstrictness" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Switch on the strictness analyser. There is a very
old paper about GHC&#8217;s strictness analyser, <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/simple-strictnes-analyser.ps.gz">Measuring the
effectiveness of a simple strictness
analyser</a>,
but the current one is quite a bit different.</p>
<p>The strictness analyser figures out when arguments and variables in
a function can be treated &#8216;strictly&#8217; (that is they are always
evaluated in the function at some point). This allow GHC to apply
certain optimisations such as unboxing that otherwise don&#8217;t apply as
they change the semantics of the program when applied to lazy
arguments.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstrictness-before=⟨n⟩">
<tt class="descname">-fstrictness-before</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fstrictness-before=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><p>Run an additional strictness analysis before simplifier phase ⟨n⟩.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funbox-small-strict-fields">
<tt class="descname">-funbox-small-strict-fields</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--funbox-small-strict-fields" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p id="index-5">This option causes all constructor fields which
are marked strict (i.e. “!”) and which representation is smaller or
equal to the size of a pointer to be unpacked, if possible. It is
equivalent to adding an <tt class="docutils literal"><span class="pre">UNPACK</span></tt> pragma (see <a class="reference internal" href="glasgow_exts.html#unpack-pragma"><em>UNPACK pragma</em></a>)
to every strict constructor field that fulfils the size restriction.</p>
<p>For example, the constructor fields in the following data types</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">A</span> <span class="ow">=</span> <span class="kt">A</span> <span class="o">!</span><span class="kt">Int</span>
<span class="kr">data</span> <span class="kt">B</span> <span class="ow">=</span> <span class="kt">B</span> <span class="o">!</span><span class="kt">A</span>
<span class="kr">newtype</span> <span class="kt">C</span> <span class="ow">=</span> <span class="kt">C</span> <span class="kt">B</span>
<span class="kr">data</span> <span class="kt">D</span> <span class="ow">=</span> <span class="kt">D</span> <span class="o">!</span><span class="kt">C</span>
</pre></div>
</div>
<p>would all be represented by a single <tt class="docutils literal"><span class="pre">Int#</span></tt> (see
<a class="reference internal" href="glasgow_exts.html#primitives"><em>Unboxed types and primitive operations</em></a>) value with <tt class="docutils literal"><span class="pre">-funbox-small-strict-fields</span></tt>
enabled.</p>
<p>This option is less of a sledgehammer than
<tt class="docutils literal"><span class="pre">-funbox-strict-fields</span></tt>: it should rarely make things worse. If
you use <tt class="docutils literal"><span class="pre">-funbox-small-strict-fields</span></tt> to turn on unboxing by
default you can disable it for certain constructor fields using the
<tt class="docutils literal"><span class="pre">NOUNPACK</span></tt> pragma (see <a class="reference internal" href="glasgow_exts.html#nounpack-pragma"><em>NOUNPACK pragma</em></a>).</p>
<p>Note that for consistency <tt class="docutils literal"><span class="pre">Double</span></tt>, <tt class="docutils literal"><span class="pre">Word64</span></tt>, and <tt class="docutils literal"><span class="pre">Int64</span></tt>
constructor fields are unpacked on 32-bit platforms, even though
they are technically larger than a pointer on those platforms.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funbox-strict-fields">
<tt class="descname">-funbox-strict-fields</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--funbox-strict-fields" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p id="index-6">This option causes all constructor fields which are marked strict
(i.e. <tt class="docutils literal"><span class="pre">!</span></tt>) to be unpacked if possible. It is equivalent to adding an
<tt class="docutils literal"><span class="pre">UNPACK</span></tt> pragma to every strict constructor field (see
<a class="reference internal" href="glasgow_exts.html#unpack-pragma"><em>UNPACK pragma</em></a>).</p>
<p>This option is a bit of a sledgehammer: it might sometimes make
things worse. Selectively unboxing fields by using <tt class="docutils literal"><span class="pre">UNPACK</span></tt>
pragmas might be better. An alternative is to use
<tt class="docutils literal"><span class="pre">-funbox-strict-fields</span></tt> to turn on unboxing by default but disable
it for certain constructor fields using the <tt class="docutils literal"><span class="pre">NOUNPACK</span></tt> pragma (see
<a class="reference internal" href="glasgow_exts.html#nounpack-pragma"><em>NOUNPACK pragma</em></a>).</p>
<p>Alternatively you can use <a class="reference internal" href="using-optimisation.html#ghc-flag--funbox-small-strict-fields"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-funbox-small-strict-fields</span></tt></a> to only
unbox strict fields which are &#8220;small&#8221;.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-creation-threshold=⟨n⟩">
<tt class="descname">-funfolding-creation-threshold</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--funfolding-creation-threshold=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">750</td>
</tr>
</tbody>
</table>
<p id="index-7">Governs the maximum size that GHC will allow a
function unfolding to be. (An unfolding has a “size” that reflects
the cost in terms of “code bloat” of expanding (aka inlining) that
unfolding at a call site. A bigger function would be assigned a
bigger cost.)</p>
<p>Consequences:</p>
<ol class="loweralpha simple">
<li>nothing larger than this will be inlined (unless it has an <tt class="docutils literal"><span class="pre">INLINE</span></tt> pragma)</li>
<li>nothing larger than this will be spewed into an interface file.</li>
</ol>
<p>Increasing this figure is more likely to result in longer compile times
than faster code. The <a class="reference internal" href="using-optimisation.html#ghc-flag--funfolding-use-threshold=⟨n⟩"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-funfolding-use-threshold=⟨n⟩</span></tt></a> is more
useful.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-dict-discount=⟨n⟩">
<tt class="descname">-funfolding-dict-discount</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--funfolding-dict-discount=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">30</td>
</tr>
</tbody>
</table>
<p id="index-8">How eager should the compiler be to inline dictionaries?</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-fun-discount=⟨n⟩">
<tt class="descname">-funfolding-fun-discount</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--funfolding-fun-discount=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">60</td>
</tr>
</tbody>
</table>
<p id="index-9">How eager should the compiler be to inline functions?</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-keeness-factor=⟨n⟩">
<tt class="descname">-funfolding-keeness-factor</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--funfolding-keeness-factor=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">1.5</td>
</tr>
</tbody>
</table>
<p id="index-10">How eager should the compiler be to inline functions?</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-use-threshold=⟨n⟩">
<tt class="descname">-funfolding-use-threshold</tt><tt class="descclassname">=⟨n⟩</tt><a class="headerlink" href="using-optimisation.html#ghc-flag--funfolding-use-threshold=⟨n⟩" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">60</td>
</tr>
</tbody>
</table>
<p id="index-11">This is the magic cut-off figure for unfolding (aka
inlining): below this size, a function definition will be unfolded
at the call-site, any bigger and it won&#8217;t. The size computed for a
function depends on two things: the actual size of the expression
minus any discounts that apply depending on the context into which
the expression is to be inlined.</p>
<p>The difference between this and
<a class="reference internal" href="using-optimisation.html#ghc-flag--funfolding-creation-threshold=⟨n⟩"><tt class="xref std std-ghc-flag docutils literal"><span class="pre">-funfolding-creation-threshold=⟨n⟩</span></tt></a> is that this one determines
if a function definition will be inlined <em>at a call site</em>. The other option
determines if a function definition will be kept around at all for
potential inlining.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fvectorisation-avoidance">
<tt class="descname">-fvectorisation-avoidance</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fvectorisation-avoidance" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p id="index-12">Part of <a class="reference internal" href="parallel.html#dph"><em>Data Parallel Haskell (DPH)</em></a>.</p>
<p>Enable the <em>vectorisation</em> avoidance optimisation.
This optimisation only works when used in combination with the
<tt class="docutils literal"><span class="pre">-fvectorise</span></tt> transformation.</p>
<p>While vectorisation of code using DPH is often a big win, it can
also produce worse results for some kinds of code. This optimisation
modifies the vectorisation transformation to try to determine if a
function would be better of unvectorised and if so, do just that.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fvectorise">
<tt class="descname">-fvectorise</tt><tt class="descclassname"></tt><a class="headerlink" href="using-optimisation.html#ghc-flag--fvectorise" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Part of <a class="reference internal" href="parallel.html#dph"><em>Data Parallel Haskell (DPH)</em></a>.</p>
<p>Enable the <em>vectorisation</em> optimisation
transformation. This optimisation transforms the nested data
parallelism code of programs using DPH into flat data parallelism.
Flat data parallel programs should have better load balancing,
enable SIMD parallelism and friendlier cache behaviour.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="using-concurrent.html" title="7.4. Using Concurrent Haskell"
             >next</a> |</li>
        <li class="right" >
          <a href="using-warnings.html" title="7.2. Warnings and sanity-checking"
             >previous</a> |</li>
        <li><a href="index.html">GHC 8.2.2 User&#39;s Guide</a> &raquo;</li>
          <li><a href="usage.html" >7. Using GHC</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2015, GHC Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>