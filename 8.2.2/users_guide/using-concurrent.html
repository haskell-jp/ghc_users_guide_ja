
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.4. Concurrent Haskell を使う &#8212; Glasgow Haskell Compiler 8.2.2 User&#39;s Guide</title>
    
    <link rel="stylesheet" href="_static/ghc-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Glasgow Haskell Compiler 8.2.2 User&#39;s Guide 内を検索"
          href="_static/opensearch.xml"/>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="7.6. Flag reference" href="flags.html" />
    <link rel="prev" title="7.3. 最適化 (コードの改善)" href="using-optimisation.html" /> 
  </head>
  <body role="document">
<div class="logo">
    <h1><a href="index.html">Glasgow Haskell Compiler User's Guide</a></h1>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="flags.html" title="7.6. Flag reference"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="using-optimisation.html" title="7.3. 最適化 (コードの改善)"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.2.2 User&#39;s Guide</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="usage.html" accesskey="U">7. GHCを使う</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.4. Concurrent Haskell を使う</a></li>
<li><a class="reference internal" href="#smp">7.5. SMP 並列を使う</a><ul>
<li><a class="reference internal" href="#parallel-compile-options">7.5.1. SMP 並列のためのコンパイルオプション</a></li>
<li><a class="reference internal" href="#smp-rts">7.5.2. SMP 並列のための RTS オプション</a></li>
<li><a class="reference internal" href="#id3">7.5.3. SMP 並列を使うためのヒント</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="using-optimisation.html"
                        title="前の章へ">7.3. 最適化 (コードの改善)</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="flags.html"
                        title="次の章へ">7.6. Flag reference</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/using-concurrent.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="concurrent-haskell">
<span id="using-concurrent"></span><h1>7.4. Concurrent Haskell を使う<a class="headerlink" href="#concurrent-haskell" title="このヘッドラインへのパーマリンク">¶</a></h1>
<span class="target" id="index-0"></span><p>GHC は特別なオプションや専用にコンパイルしたライブラリなしのデフォルトで Concurrent Haskell をサポートしています．
Concurrent Haskellのサポートライブラリにアクセスするには単に
<a class="reference external" href="../libraries/base-4.10.1.0/Control-Concurrent.html">Control.Concurrent</a>
をインポートすればよいだけです．
Concurrent Haskell に関する情報については，このモジュールの文書が提供しています．</p>
<p>任意選択で，プログラムを <a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a> オプション(<a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a> 参照)でリンクできます．
これには2つの利点があります．</p>
<ul class="simple">
<li><a class="reference internal" href="#rts-flag--N ⟨x⟩"><code class="xref std std-rts-flag docutils literal"><span class="pre">-N</span> <span class="pre">⟨x⟩</span></code></a> を使って，スレッドをマルチプロセッサあるいマルチコアの計算機で動かせます．
<a class="reference internal" href="#using-smp"><span class="std std-ref">SMP 並列を使う</span></a> を参照してください．</li>
<li>あるスレッドが外部呼び出しを行うと(その呼び出しに <code class="docutils literal"><span class="pre">unsafe</span></code> が付いていなければ)，
その外部呼び出し中にプログラム中の他のHaskellスレッドが走り続けます．
さらに <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code> された Haskell の関数が複数のOSスレッドから同時に呼ばれてもよい．
<a class="reference internal" href="ffi-chap.html#ffi-threads"><span class="std std-ref">Multi-threading and the FFI</span></a> を参照</li>
</ul>
<p>以下の RTS オプションが Concurrent Haskell プログラムの振舞いに影響します．</p>
<span class="target" id="index-1"></span><dl class="rts-flag">
<dt id="rts-flag--C ⟨s⟩">
<code class="descname">-C</code><code class="descclassname"> ⟨s⟩</code><a class="headerlink" href="#rts-flag--C ⟨s⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">20 ミリ秒</td>
</tr>
</tbody>
</table>
<p>コンテキストスイッチの間隔を ⟨s⟩ 秒に設定する．
コンテキストスイッチは，時間切れの後の最初のヒープブロック確保の際に発生します．
(ヒープブロックの確保は確保4k毎に発生します．)
<code class="docutils literal"><span class="pre">-C0</span></code> または <code class="docutils literal"><span class="pre">-C</span></code> を使うと，コンテキストスイッチは可能なかぎり頻繁に起こります
(ヒープブロック確保毎になります)．</p>
</dd></dl>

</div>
<div class="section" id="smp">
<span id="using-smp"></span><h1>7.5. SMP 並列を使う<a class="headerlink" href="#smp" title="このヘッドラインへのパーマリンク">¶</a></h1>
<span class="target" id="index-2"></span><p>GHC はSMP(対称マルチプロセッサ)上でHaskellプログラムが並列に走るのをサポートしています．</p>
<p><em>並行性</em> と <em>並列性</em> の間には細かい違いがあります．
並列性とは，複数のプロセッサーを同時に使用することで，プログラムの実行速度を向上させることです．
一方，並行処理は抽象化の手段であり，複数の非同期イベントに応答する必要があるプログラムを構造化する便利な方法です．</p>
<p>しかし，この2つの用語は確かに関連しています．
複数のCPUを使用することにより，並行スレッドを並列で実行することが可能になります．
これは，まさにGHCのSMP並列処理のサポートと同じです．
しかし，並行性を使用しないプログラムでは，並列性を使用してパフォーマンスを向上させることも可能です．
このセクションでは，GHCを使用して並列プログラムをコンパイルおよび実行する方法について説明します．
<a class="reference internal" href="parallel.html#lang-parallel"><span class="std std-ref">Concurrent and Parallel Haskell</span></a> では並列性に影響を与える言語機能について説明します．</p>
<div class="section" id="parallel-compile-options">
<span id="id1"></span><h2>7.5.1. SMP 並列のためのコンパイルオプション<a class="headerlink" href="#parallel-compile-options" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>複数のCPUを使うためには，プログラムは <a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a> オプション(<a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a> 参照)で
リンクしなければなりません．
さらに，次のコンパイルオプションが並列性に影響します．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--feager-blackholing">
<code class="descname">-feager-blackholing</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--feager-blackholing" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>ブラックホール化は，評価中のサンク（遅延計算）をマークする行為です．
第1にある種の無限ループ(<code class="docutils literal"><span class="pre">NonTermination</span></code> 例外)を検出させ，
第2にある種の空間リークを回避し，
第3に並列プログラムで計算の反復を避けられます．
計算が進行中であるタイミングを教えられるからです．</p>
<p><a class="reference internal" href="#ghc-flag--feager-blackholing"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-feager-blackholing</span></code></a> オプションは，評価が始まるとすぐに，各サンクをブラックホール化します．
デフォルトでは，「遅延ブラックホール化」で，スレッドが何らかの理由で一時停止している場合に，
評価中のサンクであることを示すマークだけを付けます．
遅延ブラックホール化は通常より効率的(およぼ1-2%程度)です．
ほとんどのサンクはブラックホール化の必要がないからです．
しかし，先行ブラックホール化を使えば，並列プログラム中の何度も行われる計算を避けることができます．
そして多くの場合並列性にとって重要であることが判ります．</p>
<p>並列に走らせたいコードはどれも <a class="reference internal" href="#ghc-flag--feager-blackholing"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-feager-blackholing</span></code></a> フラグを付けてコンパイルすることを推奨します．</p>
</dd></dl>

</div>
<div class="section" id="smp-rts">
<span id="parallel-options"></span><h2>7.5.2. SMP 並列のための RTS オプション<a class="headerlink" href="#smp-rts" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>マルチプロセッサ上でプログラムを走らせる方法は2とおりあります．
プログラムから <a class="reference external" href="../libraries/base-4.10.1.0/Control.Concurrent.html#v:setNumCapabilities">Control.Concurrent.setNumCapabilities</a> を呼ぶ方法と，
RTSオプション <a class="reference internal" href="#rts-flag--N ⟨x⟩"><code class="xref std std-rts-flag docutils literal"><span class="pre">-N</span> <span class="pre">⟨x⟩</span></code></a> を使う方法です．</p>
<dl class="rts-flag">
<dt id="rts-flag--N ⟨x⟩">
<code class="descname">-N</code><code class="descclassname"> ⟨x⟩</code><a class="headerlink" href="#rts-flag--N ⟨x⟩" title="この定義へのパーマリンク">¶</a></dt>
<dt id="rts-flag--maxN ⟨x⟩">
<code class="descname">-maxN</code><code class="descclassname"> ⟨x⟩</code><a class="headerlink" href="#rts-flag--maxN ⟨x⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>プログラムを走らせる際， ⟨x⟩本のスレッドを同時に使います．</p>
<p>実行時システムは仮想プロセッサ一式を管理します．
<em>ケーパビリティ</em> と呼ぶ仮想プロセッサの数は <code class="docutils literal"><span class="pre">-N</span></code> オプションで指定します．
各ケーパビリティは一度に1つのHaskellスレッドを走らせられます．
したがって，ケーパビリティ数は物理的に並列に走れるHaskellスレッドの数と等しくなります．
1つのケーパビリティは1つ以上のOSスレッドによって起動されます．
実行時システムは各ケーパビリティに対応するOSスレッドプールを管理します．
Haskellスレッドが外部呼び出し(<a class="reference internal" href="ffi-chap.html#ffi-threads"><span class="std std-ref">Multi-threading and the FFI</span></a> 参照)をすると，
別のOSスレッドがこのケーパビリティを引き継げるようになっています．</p>
<p>通常⟨x⟩はマシン上のCPUコアの数と一致させるべきです <a class="footnote-reference" href="#id4" id="id2">[1]</a> ．
たとえば，デュアルコアマシンであれば <code class="docutils literal"><span class="pre">+RTS</span> <span class="pre">-N2</span> <span class="pre">-RTS</span></code> を使うことになるでしょう．</p>
<p>⟨x⟩を省略して <code class="docutils literal"><span class="pre">+RTS</span> <span class="pre">-N</span> <span class="pre">-RTS</span></code> のように書くと，実行時システムがマシン上のプロセッサ数にもとづいて⟨x⟩の値を決めます．</p>
<p><code class="docutils literal"><span class="pre">-maxN</span> <span class="pre">⟨x⟩</span></code> を使って <code class="docutils literal"><span class="pre">+RTS</span> <span class="pre">-maxN3</span> <span class="pre">-RTS</span></code> のように書くと，実行時システムは
高々⟨x⟩の値に決めることになります．この値の上限はシステム上のプロセッサ数です．
⟨x⟩を省略するとエラーになります．デフォルトでの値が必要なら <code class="docutils literal"><span class="pre">-N</span></code> オプションを使って下さい．</p>
<p>マシン内のすべてのプロセッサを使用する場合は注意が必要です．
一部のプロセッサが他のプログラムで使用されている場合，パフォーマンスは向上せず，パフォーマンスに悪影響を与えます．
どのような場合でも，GHCに物理スレッドよりも多くのケーパビリティを作成させるのは良くない考えです．</p>
<p><code class="docutils literal"><span class="pre">-N</span></code> を設定すると，並列ガーベッジコレクタ(<a class="reference internal" href="runtime_control.html#rts-options-gc"><span class="std std-ref">RTS options to control the garbage collector</span></a> 参照)も有効になります．</p>
<p>現在の <code class="docutils literal"><span class="pre">-N</span></code> オプションの値は，Haskellのプログラム内から，
<code class="docutils literal"><span class="pre">Control.Concurrent.getNumCapabilities</span></code> を通じて利用可能で <code class="docutils literal"><span class="pre">Control.Concurrent.setNumCapabilities</span></code>
を呼べば，プログラムを走らせながら変更することも可能です．</p>
</dd></dl>

<p>以下のオプションを指定すると実行時システムがCPUにスレッドを割り振る方法に影響を与えられます．</p>
<dl class="rts-flag">
<dt id="rts-flag--qa">
<code class="descname">-qa</code><code class="descclassname"></code><a class="headerlink" href="#rts-flag--qa" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>OS アフィニティ機能を使って OS スレッドを CPUコアにピン留めします．</p>
<p>このオプションが有効なら，ケーパビリティ <span class="math">\(i\)</span> に対応する OS のスレッドは
OS が適用する API でスレッドアフィニティ(Linunx 用の GHC なら <code class="docutils literal"><span class="pre">sched_setaffinity()</span></code> を使って)を設定すれば，
CPUのコア <span class="math">\(i\)</span> に束縛できます．</p>
<p>ワークロードやマシン上の他のアクティビティーによって，パフォーマンスが向上する場合もあれば，
そうでない場合もあります．実際に試して、違いを測定することをお勧めします．</p>
</dd></dl>

<dl class="rts-flag">
<dt id="rts-flag--qm">
<code class="descname">-qm</code><code class="descclassname"></code><a class="headerlink" href="#rts-flag--qm" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>負荷分散のための自動マイグレーションを無効にします．
通常実行時システムは，ひまなCPUを活用するためにCPUをまたいでスレッドをスケジュールしようとします．
このオプションはこの振る舞いを無効にします．
マイグレーションはスレッドにしか適用されないことに注意してください．
<code class="docutils literal"><span class="pre">par</span></code> によって作られたスパークは，別途 work-stealing で負荷分散されます．</p>
<p>このオプションが役に立つのは，並行プログラムで
<a class="reference external" href="../libraries/base-4.10.1.0/Control-Concurrent.html#v:forkOn">Control.Concurrent.forkOn</a> を使ってスレッドを
明示的にCPUにスケジュールする場合だけでしょう．</p>
</dd></dl>

</div>
<div class="section" id="id3">
<h2>7.5.3. SMP 並列を使うためのヒント<a class="headerlink" href="#id3" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>プログラムの実行時に <a class="reference internal" href="runtime_control.html#rts-flag--s [⟨file⟩]"><code class="xref std std-rts-flag docutils literal"><span class="pre">-s</span> <span class="pre">[⟨file⟩]</span></code></a> という RTS オプションを付けると，
時間統計情報を見られます．これを使えば，使用するCPU数を増やしたことでプログラムが速くなったかを確認できます．
ユーザ(user)時間が消費時間(elapsed)時間よりも大きいなら，プログラムは複数のCPUを使ったことになります．
比較のために <a class="reference internal" href="#rts-flag--N ⟨x⟩"><code class="xref std std-rts-flag docutils literal"><span class="pre">-N</span> <span class="pre">⟨x⟩</span></code></a> なしでプログラムを走らせてみるのもよいでしょう．</p>
<p><code class="docutils literal"><span class="pre">+RTS</span> <span class="pre">-s</span></code> による出力を見れば，プログラム実行中にいくつの「スパーク」(sparks)が作られ，実行されたかが判ります
(<a class="reference internal" href="runtime_control.html#rts-options-gc"><span class="std std-ref">RTS options to control the garbage collector</span></a> 参照)．
そうすれば <code class="docutils literal"><span class="pre">par</span></code> がどの程度うまく働らいているかの感触が得られることでしょう．</p>
<p>多くの実験と実行時システムのチューニングにより，GHC の並列性サポートは 6.12.1 で改善されました．
この機能がどの程度上手くいっているかについては引き続き，教えていただきたいと思います．
また，ベンチマーク用の並列プログラムも集めたいと考えています．</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>Whether hyperthreading cores should be counted or not is an open
question; please feel free to experiment and let us know what results you
find.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="flags.html" title="7.6. Flag reference"
             >次へ</a> |</li>
        <li class="right" >
          <a href="using-optimisation.html" title="7.3. 最適化 (コードの改善)"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.2.2 User&#39;s Guide</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="usage.html" >7. GHCを使う</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, GHC Team.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6 で生成しました。
    </div>
  </body>
</html>