
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>11. Foreign function interface (FFI) &#8212; Glasgow Haskell Compiler &lt;release&gt; Users Guide</title>
    
    <link rel="stylesheet" href="_static/ghc-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="12. Extending and using GHC as a Library" href="extending_ghc.html" />
    <link rel="prev" title="10.39. Safe Haskell" href="safe_haskell.html" /> 
  </head>
  <body role="document">
<div class="logo">
    <h1><a href="index.html">Glasgow Haskell Compiler Users Guide</a></h1>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="extending_ghc.html" title="12. Extending and using GHC as a Library"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="safe_haskell.html" title="10.39. Safe Haskell"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.0.2 Users Guide</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">11. Foreign function interface (FFI)</a><ul>
<li><a class="reference internal" href="#ghc-extensions-to-the-ffi-addendum">11.1. GHC extensions to the FFI Addendum</a><ul>
<li><a class="reference internal" href="#unboxed-types">11.1.1. Unboxed types</a></li>
<li><a class="reference internal" href="#newtype-wrapping-of-the-io-monad">11.1.2. Newtype wrapping of the IO monad</a></li>
<li><a class="reference internal" href="#primitive-imports">11.1.3. Primitive imports</a></li>
<li><a class="reference internal" href="#interruptible-foreign-calls">11.1.4. Interruptible foreign calls</a></li>
<li><a class="reference internal" href="#the-capi-calling-convention">11.1.5. The CAPI calling convention</a></li>
<li><a class="reference internal" href="#hs-thread-done">11.1.6. <code class="docutils literal"><span class="pre">hs_thread_done()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-the-ffi-with-ghc">11.2. Using the FFI with GHC</a><ul>
<li><a class="reference internal" href="#using-foreign-export-and-foreign-import-ccall-wrapper-with-ghc">11.2.1. Using <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code> and <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">ccall</span> <span class="pre">&quot;wrapper&quot;</span></code> with GHC</a><ul>
<li><a class="reference internal" href="#using-your-own-main">11.2.1.1. Using your own <code class="docutils literal"><span class="pre">main()</span></code></a></li>
<li><a class="reference internal" href="#making-a-haskell-library-that-can-be-called-from-foreign-code">11.2.1.2. Making a Haskell library that can be called from foreign code</a></li>
</ul>
</li>
<li><a class="reference internal" href="#using-header-files">11.2.2. Using header files</a></li>
<li><a class="reference internal" href="#memory-allocation">11.2.3. Memory Allocation</a></li>
<li><a class="reference internal" href="#multi-threading-and-the-ffi">11.2.4. Multi-threading and the FFI</a><ul>
<li><a class="reference internal" href="#foreign-imports-and-multi-threading">11.2.4.1. Foreign imports and multi-threading</a></li>
<li><a class="reference internal" href="#the-relationship-between-haskell-threads-and-os-threads">11.2.4.2. The relationship between Haskell threads and OS threads</a></li>
<li><a class="reference internal" href="#foreign-exports-and-multi-threading">11.2.4.3. Foreign exports and multi-threading</a></li>
<li><a class="reference internal" href="#on-the-use-of-hs-exit">11.2.4.4. On the use of <code class="docutils literal"><span class="pre">hs_exit()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#floating-point-and-the-ffi">11.2.5. Floating point and the FFI</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="safe_haskell.html"
                        title="previous chapter">10.39. Safe Haskell</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="extending_ghc.html"
                        title="next chapter">12. Extending and using GHC as a Library</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ffi-chap.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="foreign-function-interface-ffi">
<span id="ffi"></span><h1>11. Foreign function interface (FFI)<a class="headerlink" href="#foreign-function-interface-ffi" title="Permalink to this headline">¶</a></h1>
<p id="index-0">GHC (mostly) conforms to the Haskell Foreign Function Interface, whose
definition is part of the Haskell Report on
<a class="reference external" href="http://www.haskell.org/">http://www.haskell.org/</a>.</p>
<p>FFI support is enabled by default, but can be enabled or disabled
explicitly with the <code class="xref std std-ghc-flag docutils literal"><span class="pre">-XForeignFunctionInterface</span></code> flag.</p>
<p>GHC implements a number of GHC-specific extensions to the FFI Addendum.
These extensions are described in <a class="reference internal" href="#ffi-ghcexts"><span class="std std-ref">GHC extensions to the FFI Addendum</span></a>, but please note
that programs using these features are not portable. Hence, these
features should be avoided where possible.</p>
<p>The FFI libraries are documented in the accompanying library
documentation; see for example the <a class="reference external" href="../libraries/base-4.9.1.0/Foreign">Foreign</a> module.</p>
<div class="section" id="ghc-extensions-to-the-ffi-addendum">
<span id="ffi-ghcexts"></span><h2>11.1. GHC extensions to the FFI Addendum<a class="headerlink" href="#ghc-extensions-to-the-ffi-addendum" title="Permalink to this headline">¶</a></h2>
<p>The FFI features that are described in this section are specific to GHC.
Your code will not be portable to other compilers if you use them.</p>
<div class="section" id="unboxed-types">
<h3>11.1.1. Unboxed types<a class="headerlink" href="#unboxed-types" title="Permalink to this headline">¶</a></h3>
<p>The following unboxed types may be used as basic foreign types (see FFI
Addendum, Section 3.2): <code class="docutils literal"><span class="pre">Int#</span></code>, <code class="docutils literal"><span class="pre">Word#</span></code>, <code class="docutils literal"><span class="pre">Char#</span></code>, <code class="docutils literal"><span class="pre">Float#</span></code>,
<code class="docutils literal"><span class="pre">Double#</span></code>, <code class="docutils literal"><span class="pre">Addr#</span></code>, <code class="docutils literal"><span class="pre">StablePtr#</span> <span class="pre">a</span></code>, <code class="docutils literal"><span class="pre">MutableByteArray#</span></code>,
<code class="docutils literal"><span class="pre">ForeignObj#</span></code>, and <code class="docutils literal"><span class="pre">ByteArray#</span></code>.</p>
</div>
<div class="section" id="newtype-wrapping-of-the-io-monad">
<span id="ffi-newtype-io"></span><h3>11.1.2. Newtype wrapping of the IO monad<a class="headerlink" href="#newtype-wrapping-of-the-io-monad" title="Permalink to this headline">¶</a></h3>
<p>The FFI spec requires the IO monad to appear in various places, but it
can sometimes be convenient to wrap the IO monad in a <code class="docutils literal"><span class="pre">newtype</span></code>, thus:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">newtype</span> <span class="kt">MyIO</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">MIO</span> <span class="p">(</span><span class="kt">IO</span> <span class="n">a</span><span class="p">)</span>
</pre></div>
</div>
<p>(A reason for doing so might be to prevent the programmer from calling
arbitrary IO procedures in some part of the program.)</p>
<p>The Haskell FFI already specifies that arguments and results of foreign
imports and exports will be automatically unwrapped if they are newtypes
(Section 3.2 of the FFI addendum). GHC extends the FFI by automatically
unwrapping any newtypes that wrap the IO monad itself. More precisely,
wherever the FFI specification requires an <code class="docutils literal"><span class="pre">IO</span></code> type, GHC will accept any
newtype-wrapping of an <code class="docutils literal"><span class="pre">IO</span></code> type. For example, these declarations are OK:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">MyIO</span> <span class="kt">Int</span>
<span class="nf">foreign</span> <span class="kr">import</span> <span class="s">&quot;dynamic&quot;</span> <span class="nn">baz</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">MyIO</span> <span class="kt">Int</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">CInt</span> <span class="ow">-&gt;</span> <span class="kt">MyIO</span> <span class="kt">Int</span>
</pre></div>
</div>
</div>
<div class="section" id="primitive-imports">
<span id="ffi-prim"></span><h3>11.1.3. Primitive imports<a class="headerlink" href="#primitive-imports" title="Permalink to this headline">¶</a></h3>
<p>GHC extends the FFI with an additional calling convention <code class="docutils literal"><span class="pre">prim</span></code>,
e.g.:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">prim</span> <span class="s">&quot;foo&quot;</span> <span class="n">foo</span> <span class="ow">::</span> <span class="kt">ByteArray</span><span class="o">#</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="o">#</span> <span class="kt">Int</span><span class="o">#</span><span class="p">,</span> <span class="kt">Int</span><span class="o">#</span> <span class="o">#</span><span class="p">)</span>
</pre></div>
</div>
<p>This is used to import functions written in Cmm code that follow an
internal GHC calling convention. The arguments and results must be
unboxed types, except that an argument may be of type <code class="docutils literal"><span class="pre">Any</span></code> (by way of
<code class="docutils literal"><span class="pre">unsafeCoerce#</span></code>) and the result type is allowed to be an unboxed tuple
or the type <code class="docutils literal"><span class="pre">Any</span></code>.</p>
<p>This feature is not intended for use outside of the core libraries that
come with GHC. For more details see the
<a class="reference external" href="http://ghc.haskell.org/trac/ghc/wiki/Commentary/PrimOps">GHC developer wiki</a>.</p>
</div>
<div class="section" id="interruptible-foreign-calls">
<span id="ffi-interruptible"></span><h3>11.1.4. Interruptible foreign calls<a class="headerlink" href="#interruptible-foreign-calls" title="Permalink to this headline">¶</a></h3>
<p>This concerns the interaction of foreign calls with
<code class="docutils literal"><span class="pre">Control.Concurrent.throwTo</span></code>. Normally when the target of a
<code class="docutils literal"><span class="pre">throwTo</span></code> is involved in a foreign call, the exception is not raised
until the call returns, and in the meantime the caller is blocked. This
can result in unresponsiveness, which is particularly undesirable in the
case of user interrupt (e.g. Control-C). The default behaviour when a
Control-C signal is received (<code class="docutils literal"><span class="pre">SIGINT</span></code> on Unix) is to raise the
<code class="docutils literal"><span class="pre">UserInterrupt</span></code> exception in the main thread; if the main thread is
blocked in a foreign call at the time, then the program will not respond
to the user interrupt.</p>
<p>The problem is that it is not possible in general to interrupt a foreign
call safely. However, GHC does provide a way to interrupt blocking
system calls which works for most system calls on both Unix and Windows.
When the <code class="docutils literal"><span class="pre">InterruptibleFFI</span></code> extension is enabled, a foreign call can
be annotated with <code class="docutils literal"><span class="pre">interruptible</span></code> instead of <code class="docutils literal"><span class="pre">safe</span></code> or <code class="docutils literal"><span class="pre">unsafe</span></code>:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">ccall</span> <span class="n">interruptible</span>
   <span class="s">&quot;sleep&quot;</span> <span class="n">sleepBlock</span> <span class="ow">::</span> <span class="kt">CUint</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">CUint</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">interruptible</span></code> behaves exactly as <code class="docutils literal"><span class="pre">safe</span></code>, except that when a
<code class="docutils literal"><span class="pre">throwTo</span></code> is directed at a thread in an interruptible foreign call, an
OS-specific mechanism will be used to attempt to cause the foreign call
to return:</p>
<dl class="docutils">
<dt>Unix systems</dt>
<dd>The thread making the foreign call is sent a <code class="docutils literal"><span class="pre">SIGPIPE</span></code> signal
using <code class="docutils literal"><span class="pre">pthread_kill()</span></code>. This is usually enough to cause a blocking
system call to return with <code class="docutils literal"><span class="pre">EINTR</span></code> (GHC by default installs an
empty signal handler for <code class="docutils literal"><span class="pre">SIGPIPE</span></code>, to override the default
behaviour which is to terminate the process immediately).</dd>
<dt>Windows systems</dt>
<dd>[Vista and later only] The RTS calls the Win32 function
<code class="docutils literal"><span class="pre">CancelSynchronousIO</span></code>, which will cause a blocking I/O operation
to return with the error <code class="docutils literal"><span class="pre">ERROR_OPERATION_ABORTED</span></code>.</dd>
</dl>
<p>If the system call is successfully interrupted, it will return to
Haskell whereupon the exception can be raised. Be especially careful
when using <code class="docutils literal"><span class="pre">interruptible</span></code> that the caller of the foreign function is
prepared to deal with the consequences of the call being interrupted; on
Unix it is good practice to check for <code class="docutils literal"><span class="pre">EINTR</span></code> always, but on Windows
it is not typically necessary to handle <code class="docutils literal"><span class="pre">ERROR_OPERATION_ABORTED</span></code>.</p>
</div>
<div class="section" id="the-capi-calling-convention">
<span id="ffi-capi"></span><h3>11.1.5. The CAPI calling convention<a class="headerlink" href="#the-capi-calling-convention" title="Permalink to this headline">¶</a></h3>
<p>The <code class="docutils literal"><span class="pre">CApiFFI</span></code> extension allows a calling convention of <code class="docutils literal"><span class="pre">capi</span></code> to be
used in foreign declarations, e.g.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">capi</span> <span class="s">&quot;header.h f&quot;</span> <span class="n">f</span> <span class="ow">::</span> <span class="kt">CInt</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">CInt</span>
</pre></div>
</div>
<p>Rather than generating code to call <code class="docutils literal"><span class="pre">f</span></code> according to the platform&#8217;s
ABI, we instead call <code class="docutils literal"><span class="pre">f</span></code> using the C API defined in the header
<code class="docutils literal"><span class="pre">header.h</span></code>. Thus <code class="docutils literal"><span class="pre">f</span></code> can be called even if it may be defined as a
CPP <code class="docutils literal"><span class="pre">#define</span></code> rather than a proper function.</p>
<p>When using <code class="docutils literal"><span class="pre">capi</span></code>, it is also possible to import values, rather than
functions. For example,</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">foreign</span> <span class="kr">import</span> <span class="nn">capi</span> <span class="s">&quot;pi.h value pi&quot;</span> <span class="n">c_pi</span> <span class="ow">::</span> <span class="kt">CDouble</span>
</pre></div>
</div>
<p>will work regardless of whether <code class="docutils literal"><span class="pre">pi</span></code> is defined as</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">const</span> <span class="n">double</span> <span class="n">pi</span> <span class="ow">=</span> <span class="mf">3.14</span><span class="p">;</span>
</pre></div>
</div>
<p>or with</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="o">#</span><span class="n">define</span> <span class="n">pi</span> <span class="mf">3.14</span>
</pre></div>
</div>
<p>In order to tell GHC the C type that a Haskell type corresponds to when
it is used with the CAPI, a <code class="docutils literal"><span class="pre">CTYPE</span></code> pragma can be used on the type
definition. The header which defines the type can optionally also be
specified. The syntax looks like:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">data</span>    <span class="cm">{-# CTYPE &quot;unistd.h&quot; &quot;useconds_t&quot; #-}</span> <span class="kt">T</span> <span class="ow">=</span> <span class="o">...</span>
<span class="kr">newtype</span> <span class="cm">{-# CTYPE            &quot;useconds_t&quot; #-}</span> <span class="kt">T</span> <span class="ow">=</span> <span class="o">...</span>
</pre></div>
</div>
</div>
<div class="section" id="hs-thread-done">
<h3>11.1.6. <code class="docutils literal"><span class="pre">hs_thread_done()</span></code><a class="headerlink" href="#hs-thread-done" title="Permalink to this headline">¶</a></h3>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">void</span> <span class="n">hs_thread_done</span><span class="p">(</span><span class="n">void</span><span class="p">);</span>
</pre></div>
</div>
<p>GHC allocates a small amount of thread-local memory when a thread calls
a Haskell function via a <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code>. This memory is not normally
freed until <code class="docutils literal"><span class="pre">hs_exit()</span></code>; the memory is cached so that subsequent calls
into Haskell are fast. However, if your application is long-running and
repeatedly creates new threads that call into Haskell, you probably want
to arrange that this memory is freed in those threads that have finished
calling Haskell functions. To do this, call <code class="docutils literal"><span class="pre">hs_thread_done()</span></code> from
the thread whose memory you want to free.</p>
<p>Calling <code class="docutils literal"><span class="pre">hs_thread_done()</span></code> is entirely optional. You can call it as
often or as little as you like. It is safe to call it from a thread that
has never called any Haskell functions, or one that never will. If you
forget to call it, the worst that can happen is that some memory remains
allocated until <code class="docutils literal"><span class="pre">hs_exit()</span></code> is called. If you call it too often, the
worst that can happen is that the next call to a Haskell function incurs
some extra overhead.</p>
</div>
</div>
<div class="section" id="using-the-ffi-with-ghc">
<span id="ffi-ghc"></span><h2>11.2. Using the FFI with GHC<a class="headerlink" href="#using-the-ffi-with-ghc" title="Permalink to this headline">¶</a></h2>
<p>The following sections also give some hints and tips on the use of the
foreign function interface in GHC.</p>
<div class="section" id="using-foreign-export-and-foreign-import-ccall-wrapper-with-ghc">
<span id="foreign-export-ghc"></span><h3>11.2.1. Using <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code> and <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">ccall</span> <span class="pre">&quot;wrapper&quot;</span></code> with GHC<a class="headerlink" href="#using-foreign-export-and-foreign-import-ccall-wrapper-with-ghc" title="Permalink to this headline">¶</a></h3>
<p id="index-1">When GHC compiles a module (say <code class="docutils literal"><span class="pre">M.hs</span></code>) which uses <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code>
or <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">import</span> <span class="pre">&quot;wrapper&quot;</span></code>, it generates a <code class="docutils literal"><span class="pre">M_stub.h</span></code> for use by
C programs.</p>
<p>For a plain <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code>, the file <code class="docutils literal"><span class="pre">M_stub.h</span></code> contains a C
prototype for the foreign exported function. For example, if we compile
the following module:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">module</span> <span class="nn">Foo</span> <span class="kr">where</span>

<span class="nf">foreign</span> <span class="n">export</span> <span class="n">ccall</span> <span class="n">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Int</span>

<span class="nf">foo</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="kt">Int</span>
<span class="nf">foo</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">return</span> <span class="p">(</span><span class="n">length</span> <span class="p">(</span><span class="n">f</span> <span class="n">n</span><span class="p">))</span>

<span class="nf">f</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="kt">Int</span><span class="p">]</span>
<span class="nf">f</span> <span class="mi">0</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">f</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span><span class="kt">:</span><span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
</pre></div>
</div>
<p>Then <code class="docutils literal"><span class="pre">Foo_stub.h</span></code> will contain something like this:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;HsFFI.h&quot;</span><span class="cp"></span>
<span class="k">extern</span> <span class="n">HsInt</span> <span class="nf">foo</span><span class="p">(</span><span class="n">HsInt</span> <span class="n">a0</span><span class="p">);</span>
</pre></div>
</div>
<p>To invoke <code class="docutils literal"><span class="pre">foo()</span></code> from C, just <code class="docutils literal"><span class="pre">#include</span> <span class="pre">&quot;Foo_stub.h&quot;</span></code> and call
<code class="docutils literal"><span class="pre">foo()</span></code>.</p>
<p>The <code class="docutils literal"><span class="pre">Foo_stub.h</span></code> file can be redirected using the <code class="docutils literal"><span class="pre">-stubdir</span></code> option;
see <a class="reference internal" href="separate_compilation.html#options-output"><span class="std std-ref">Redirecting the compilation output(s)</span></a>.</p>
<div class="section" id="using-your-own-main">
<span id="using-own-main"></span><h4>11.2.1.1. Using your own <code class="docutils literal"><span class="pre">main()</span></code><a class="headerlink" href="#using-your-own-main" title="Permalink to this headline">¶</a></h4>
<p>Normally, GHC&#8217;s runtime system provides a <code class="docutils literal"><span class="pre">main()</span></code>, which arranges to
invoke <code class="docutils literal"><span class="pre">Main.main</span></code> in the Haskell program. However, you might want to
link some Haskell code into a program which has a main function written
in another language, say C. In order to do this, you have to initialize
the Haskell runtime system explicitly.</p>
<p>Let&#8217;s take the example from above, and invoke it from a standalone C
program. Here&#8217;s the C code:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;HsFFI.h&quot;</span><span class="cp"></span>

<span class="cp">#ifdef __GLASGOW_HASKELL__</span>
<span class="cp">#include</span> <span class="cpf">&quot;Foo_stub.h&quot;</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="n">hs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2500</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">hs_exit</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We&#8217;ve surrounded the GHC-specific bits with
<code class="docutils literal"><span class="pre">#ifdef</span> <span class="pre">__GLASGOW_HASKELL__</span></code>; the rest of the code should be portable
across Haskell implementations that support the FFI standard.</p>
<p>The call to <code class="docutils literal"><span class="pre">hs_init()</span></code> initializes GHC&#8217;s runtime system. Do NOT try
to invoke any Haskell functions before calling <code class="docutils literal"><span class="pre">hs_init()</span></code>: bad things
will undoubtedly happen.</p>
<p>We pass references to <code class="docutils literal"><span class="pre">argc</span></code> and <code class="docutils literal"><span class="pre">argv</span></code> to <code class="docutils literal"><span class="pre">hs_init()</span></code> so that it
can separate out any arguments for the RTS (i.e. those arguments between
<code class="docutils literal"><span class="pre">+RTS...-RTS</span></code>).</p>
<p>After we&#8217;ve finished invoking our Haskell functions, we can call
<code class="docutils literal"><span class="pre">hs_exit()</span></code>, which terminates the RTS.</p>
<p>There can be multiple calls to <code class="docutils literal"><span class="pre">hs_init()</span></code>, but each one should be
matched by one (and only one) call to <code class="docutils literal"><span class="pre">hs_exit()</span></code> <a class="footnote-reference" href="#id2" id="id1">[1]</a>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When linking the final program, it is normally easiest to do the
link using GHC, although this isn&#8217;t essential. If you do use GHC, then
don&#8217;t forget the flag <a class="reference internal" href="phases.html#ghc-flag--no-hs-main"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-no-hs-main</span></code></a>, otherwise GHC
will try to link to the <code class="docutils literal"><span class="pre">Main</span></code> Haskell module.</p>
</div>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>The outermost <code class="docutils literal"><span class="pre">hs_exit()</span></code> will actually de-initialise the system.
Note that currently GHC&#8217;s runtime cannot reliably re-initialise after
this has happened, see <a class="reference internal" href="bugs.html#infelicities-ffi"><span class="std std-ref">The Foreign Function Interface</span></a>.</td></tr>
</tbody>
</table>
<p>To use <code class="docutils literal"><span class="pre">+RTS</span></code> flags with <code class="docutils literal"><span class="pre">hs_init()</span></code>, we have to modify the example
slightly. By default, GHC&#8217;s RTS will only accept &#8220;safe&#8221; <code class="docutils literal"><span class="pre">+RTS</span></code> flags
(see <a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>), and the <a class="reference internal" href="phases.html#ghc-flag--rtsopts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-rtsopts</span></code></a>
link-time flag overrides this. However, <a class="reference internal" href="phases.html#ghc-flag--rtsopts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-rtsopts</span></code></a> has no effect when
<a class="reference internal" href="phases.html#ghc-flag--no-hs-main"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-no-hs-main</span></code></a> is in use (and the same goes for <a class="reference internal" href="phases.html#ghc-flag--with-rtsopts"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-with-rtsopts</span></code></a>). To
set these options we have to call a GHC-specific API instead of
<code class="docutils literal"><span class="pre">hs_init()</span></code>:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;HsFFI.h&quot;</span><span class="cp"></span>

<span class="cp">#ifdef __GLASGOW_HASKELL__</span>
<span class="cp">#include</span> <span class="cpf">&quot;Foo_stub.h&quot;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;Rts.h&quot;</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#if __GLASGOW_HASKELL__ &gt;= 703</span>
  <span class="p">{</span>
      <span class="n">RtsConfig</span> <span class="n">conf</span> <span class="o">=</span> <span class="n">defaultRtsConfig</span><span class="p">;</span>
      <span class="n">conf</span><span class="p">.</span><span class="n">rts_opts_enabled</span> <span class="o">=</span> <span class="n">RtsOptsAll</span><span class="p">;</span>
      <span class="n">hs_init_ghc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">,</span> <span class="n">conf</span><span class="p">);</span>
  <span class="p">}</span>
<span class="cp">#else</span>
  <span class="n">hs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">argv</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2500</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">hs_exit</span><span class="p">();</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Note two changes: we included <code class="docutils literal"><span class="pre">Rts.h</span></code>, which defines the GHC-specific
external RTS interface, and we called <code class="docutils literal"><span class="pre">hs_init_ghc()</span></code> instead of
<code class="docutils literal"><span class="pre">hs_init()</span></code>, passing an argument of type <code class="docutils literal"><span class="pre">RtsConfig</span></code>. <code class="docutils literal"><span class="pre">RtsConfig</span></code>
is a struct with various fields that affect the behaviour of the runtime
system. Its definition is:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">RtsOptsEnabledEnum</span> <span class="n">rts_opts_enabled</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">rts_opts</span><span class="p">;</span>
<span class="p">}</span> <span class="n">RtsConfig</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="n">RtsConfig</span> <span class="n">defaultRtsConfig</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span>
    <span class="n">RtsOptsNone</span><span class="p">,</span>         <span class="c1">// +RTS causes an error</span>
    <span class="n">RtsOptsSafeOnly</span><span class="p">,</span>     <span class="c1">// safe RTS options allowed; others cause an error</span>
    <span class="n">RtsOptsAll</span>           <span class="c1">// all RTS options allowed</span>
  <span class="p">}</span> <span class="n">RtsOptsEnabledEnum</span><span class="p">;</span>
</pre></div>
</div>
<p>There is a default value <code class="docutils literal"><span class="pre">defaultRtsConfig</span></code> that should be used to
initialise variables of type <code class="docutils literal"><span class="pre">RtsConfig</span></code>. More fields will undoubtedly
be added to <code class="docutils literal"><span class="pre">RtsConfig</span></code> in the future, so in order to keep your code
forwards-compatible it is best to initialise with <code class="docutils literal"><span class="pre">defaultRtsConfig</span></code>
and then modify the required fields, as in the code sample above.</p>
</div>
<div class="section" id="making-a-haskell-library-that-can-be-called-from-foreign-code">
<span id="ffi-library"></span><h4>11.2.1.2. Making a Haskell library that can be called from foreign code<a class="headerlink" href="#making-a-haskell-library-that-can-be-called-from-foreign-code" title="Permalink to this headline">¶</a></h4>
<p>The scenario here is much like in <a class="reference internal" href="#using-own-main"><span class="std std-ref">Using your own main()</span></a>, except that the
aim is not to link a complete program, but to make a library from
Haskell code that can be deployed in the same way that you would deploy
a library of C code.</p>
<p>The main requirement here is that the runtime needs to be initialized
before any Haskell code can be called, so your library should provide
initialisation and deinitialisation entry points, implemented in C or
C++. For example:</p>
<div class="highlight-c"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&quot;HsFFI.h&quot;</span><span class="cp"></span>

<span class="n">HsBool</span> <span class="nf">mylib_init</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="kt">int</span> <span class="n">argc</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;+RTS&quot;</span><span class="p">,</span> <span class="s">&quot;-A32m&quot;</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">};</span>
  <span class="kt">char</span> <span class="o">**</span><span class="n">pargv</span> <span class="o">=</span> <span class="n">argv</span><span class="p">;</span>

  <span class="c1">// Initialize Haskell runtime</span>
  <span class="n">hs_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">argc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pargv</span><span class="p">);</span>

  <span class="c1">// do any other initialization here and</span>
  <span class="c1">// return false if there was a problem</span>
  <span class="k">return</span> <span class="n">HS_BOOL_TRUE</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">mylib_end</span><span class="p">(</span><span class="kt">void</span><span class="p">){</span>
  <span class="n">hs_exit</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The initialisation routine, <code class="docutils literal"><span class="pre">mylib_init</span></code>, calls <code class="docutils literal"><span class="pre">hs_init()</span></code> as
normal to initialise the Haskell runtime, and the corresponding
deinitialisation function <code class="docutils literal"><span class="pre">mylib_end()</span></code> calls <code class="docutils literal"><span class="pre">hs_exit()</span></code> to shut
down the runtime.</p>
</div>
</div>
<div class="section" id="using-header-files">
<span id="glasgow-foreign-headers"></span><h3>11.2.2. Using header files<a class="headerlink" href="#using-header-files" title="Permalink to this headline">¶</a></h3>
<p id="index-2">C functions are normally declared using prototypes in a C header file.
Earlier versions of GHC (6.8.3 and earlier) <code class="docutils literal"><span class="pre">#include</span></code>d the header
file in the C source file generated from the Haskell code, and the C
compiler could therefore check that the C function being called via the
FFI was being called at the right type.</p>
<p>GHC no longer includes external header files when compiling via C, so
this checking is not performed. The change was made for compatibility
with the <a class="reference internal" href="codegens.html#native-code-gen"><span class="std std-ref">native code generator</span></a> (<a class="reference internal" href="phases.html#ghc-flag--fasm"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fasm</span></code></a>) and to
comply strictly with the FFI specification, which requires that FFI calls are
not subject to macro expansion and other CPP conversions that may be applied
when using C header files. This approach also simplifies the inlining of foreign
calls across module and package boundaries: there&#8217;s no need for the header file
to be available when compiling an inlined version of a foreign call, so the
compiler is free to inline foreign calls in any context.</p>
<p>The <code class="docutils literal"><span class="pre">-#include</span></code> option is now deprecated, and the <code class="docutils literal"><span class="pre">include-files</span></code>
field in a Cabal package specification is ignored.</p>
</div>
<div class="section" id="memory-allocation">
<h3>11.2.3. Memory Allocation<a class="headerlink" href="#memory-allocation" title="Permalink to this headline">¶</a></h3>
<p>The FFI libraries provide several ways to allocate memory for use with
the FFI, and it isn&#8217;t always clear which way is the best. This decision
may be affected by how efficient a particular kind of allocation is on a
given compiler/platform, so this section aims to shed some light on how
the different kinds of allocation perform with GHC.</p>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">alloca</span></code></dt>
<dd><p class="first">Useful for short-term allocation when the allocation is intended to
scope over a given <code class="docutils literal"><span class="pre">IO</span></code> computation. This kind of allocation is
commonly used when marshalling data to and from FFI functions.</p>
<p class="last">In GHC, <code class="docutils literal"><span class="pre">alloca</span></code> is implemented using <code class="docutils literal"><span class="pre">MutableByteArray#</span></code>, so
allocation and deallocation are fast: much faster than C&#8217;s
<code class="docutils literal"><span class="pre">malloc/free</span></code>, but not quite as fast as stack allocation in C. Use
<code class="docutils literal"><span class="pre">alloca</span></code> whenever you can.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">mallocForeignPtr</span></code></dt>
<dd><p class="first">Useful for longer-term allocation which requires garbage collection.
If you intend to store the pointer to the memory in a foreign data
structure, then <code class="docutils literal"><span class="pre">mallocForeignPtr</span></code> is <em>not</em> a good choice,
however.</p>
<p class="last">In GHC, <code class="docutils literal"><span class="pre">mallocForeignPtr</span></code> is also implemented using
<code class="docutils literal"><span class="pre">MutableByteArray#</span></code>. Although the memory is pointed to by a
<code class="docutils literal"><span class="pre">ForeignPtr</span></code>, there are no actual finalizers involved (unless you
add one with <code class="docutils literal"><span class="pre">addForeignPtrFinalizer</span></code>), and the deallocation is
done using GC, so <code class="docutils literal"><span class="pre">mallocForeignPtr</span></code> is normally very cheap.</p>
</dd>
<dt><code class="docutils literal"><span class="pre">malloc/free</span></code></dt>
<dd>If all else fails, then you need to resort to <code class="docutils literal"><span class="pre">Foreign.malloc</span></code> and
<code class="docutils literal"><span class="pre">Foreign.free</span></code>. These are just wrappers around the C functions of
the same name, and their efficiency will depend ultimately on the
implementations of these functions in your platform&#8217;s C library. We
usually find <code class="docutils literal"><span class="pre">malloc</span></code> and <code class="docutils literal"><span class="pre">free</span></code> to be significantly slower than
the other forms of allocation above.</dd>
<dt><code class="docutils literal"><span class="pre">Foreign.Marshal.Pool</span></code></dt>
<dd>Pools are currently implemented using <code class="docutils literal"><span class="pre">malloc/free</span></code>, so while they
might be a more convenient way to structure your memory allocation
than using one of the other forms of allocation, they won&#8217;t be any
more efficient. We do plan to provide an improved-performance
implementation of Pools in the future, however.</dd>
</dl>
</div>
<div class="section" id="multi-threading-and-the-ffi">
<span id="ffi-threads"></span><h3>11.2.4. Multi-threading and the FFI<a class="headerlink" href="#multi-threading-and-the-ffi" title="Permalink to this headline">¶</a></h3>
<p>In order to use the FFI in a multi-threaded setting, you must use the
<a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a> option (see <a class="reference internal" href="phases.html#options-linker"><span class="std std-ref">Options affecting linking</span></a>).</p>
<div class="section" id="foreign-imports-and-multi-threading">
<h4>11.2.4.1. Foreign imports and multi-threading<a class="headerlink" href="#foreign-imports-and-multi-threading" title="Permalink to this headline">¶</a></h4>
<p>When you call a <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">import</span></code>ed function that is annotated as
<code class="docutils literal"><span class="pre">safe</span></code> (the default), and the program was linked using <a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a>,
then the call will run concurrently with other running Haskell threads.
If the program was linked without <a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a>, then the other Haskell
threads will be blocked until the call returns.</p>
<p>This means that if you need to make a foreign call to a function that
takes a long time or blocks indefinitely, then you should mark it
<code class="docutils literal"><span class="pre">safe</span></code> and use <a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a>. Some library functions make such calls
internally; their documentation should indicate when this is the case.</p>
<p>If you are making foreign calls from multiple Haskell threads and using
<a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a>, make sure that the foreign code you are calling is
thread-safe. In particularly, some GUI libraries are not thread-safe and
require that the caller only invokes GUI methods from a single thread.
If this is the case, you may need to restrict your GUI operations to a
single Haskell thread, and possibly also use a bound thread (see
<a class="reference internal" href="#haskell-threads-and-os-threads"><span class="std std-ref">The relationship between Haskell threads and OS threads</span></a>).</p>
<p>Note that foreign calls made by different Haskell threads may execute in
<em>parallel</em>, even when the <code class="docutils literal"><span class="pre">+RTS</span> <span class="pre">-N</span></code> flag is not being used
(<a class="reference internal" href="using-concurrent.html#parallel-options"><span class="std std-ref">RTS options for SMP parallelism</span></a>). The <a class="reference internal" href="using-concurrent.html#rts-flag--N"><code class="xref std std-rts-flag docutils literal"><span class="pre">-N</span></code></a> flag controls parallel
execution of Haskell threads, but there may be an arbitrary number of
foreign calls in progress at any one time, regardless of the <code class="docutils literal"><span class="pre">+RTS</span> <span class="pre">-N</span></code>
value.</p>
<p>If a call is annotated as <code class="docutils literal"><span class="pre">interruptible</span></code> and the program was
multithreaded, the call may be interrupted in the event that the Haskell
thread receives an exception. The mechanism by which the interrupt
occurs is platform dependent, but is intended to cause blocking system
calls to return immediately with an interrupted error code. The
underlying operating system thread is not to be destroyed. See
<a class="reference internal" href="#ffi-interruptible"><span class="std std-ref">Interruptible foreign calls</span></a> for more details.</p>
</div>
<div class="section" id="the-relationship-between-haskell-threads-and-os-threads">
<span id="haskell-threads-and-os-threads"></span><h4>11.2.4.2. The relationship between Haskell threads and OS threads<a class="headerlink" href="#the-relationship-between-haskell-threads-and-os-threads" title="Permalink to this headline">¶</a></h4>
<p>Normally there is no fixed relationship between Haskell threads and OS
threads. This means that when you make a foreign call, that call may
take place in an unspecified OS thread. Furthermore, there is no
guarantee that multiple calls made by one Haskell thread will be made by
the same OS thread.</p>
<p>This usually isn&#8217;t a problem, and it allows the GHC runtime system to
make efficient use of OS thread resources. However, there are cases
where it is useful to have more control over which OS thread is used,
for example when calling foreign code that makes use of thread-local
state. For cases like this, we provide <em>bound threads</em>, which are
Haskell threads tied to a particular OS thread. For information on bound
threads, see the documentation for the <a class="reference external" href="../libraries/base-4.9.1.0/Control.Concurrent">Control.Concurrent</a> module.</p>
</div>
<div class="section" id="foreign-exports-and-multi-threading">
<h4>11.2.4.3. Foreign exports and multi-threading<a class="headerlink" href="#foreign-exports-and-multi-threading" title="Permalink to this headline">¶</a></h4>
<p>When the program is linked with <a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a>, then you may invoke
<code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code>ed functions from multiple OS threads concurrently.
The runtime system must be initialised as usual by calling
<code class="docutils literal"><span class="pre">hs_init()</span></code>, and this call must complete before invoking any
<code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code>ed functions.</p>
</div>
<div class="section" id="on-the-use-of-hs-exit">
<span id="hs-exit"></span><h4>11.2.4.4. On the use of <code class="docutils literal"><span class="pre">hs_exit()</span></code><a class="headerlink" href="#on-the-use-of-hs-exit" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal"><span class="pre">hs_exit()</span></code> normally causes the termination of any running Haskell
threads in the system, and when <code class="docutils literal"><span class="pre">hs_exit()</span></code> returns, there will be no
more Haskell threads running. The runtime will then shut down the system
in an orderly way, generating profiling output and statistics if
necessary, and freeing all the memory it owns.</p>
<p>It isn&#8217;t always possible to terminate a Haskell thread forcibly: for
example, the thread might be currently executing a foreign call, and we
have no way to force the foreign call to complete. What&#8217;s more, the
runtime must assume that in the worst case the Haskell code and runtime
are about to be removed from memory (e.g. if this is a
<a class="reference internal" href="win32-dlls.html#win32-dlls"><span class="std std-ref">Windows DLL</span></a>, <code class="docutils literal"><span class="pre">hs_exit()</span></code> is normally called before unloading
the DLL). So <code class="docutils literal"><span class="pre">hs_exit()</span></code> <em>must</em> wait until all outstanding foreign
calls return before it can return itself.</p>
<p>The upshot of this is that if you have Haskell threads that are blocked
in foreign calls, then <code class="docutils literal"><span class="pre">hs_exit()</span></code> may hang (or possibly busy-wait)
until the calls return. Therefore it&#8217;s a good idea to make sure you
don&#8217;t have any such threads in the system when calling <code class="docutils literal"><span class="pre">hs_exit()</span></code>.
This includes any threads doing I/O, because I/O may (or may not,
depending on the type of I/O and the platform) be implemented using
blocking foreign calls.</p>
<p>The GHC runtime treats program exit as a special case, to avoid the need
to wait for blocked threads when a standalone executable exits. Since
the program and all its threads are about to terminate at the same time
that the code is removed from memory, it isn&#8217;t necessary to ensure that
the threads have exited first. (Unofficially, if you want to use this
fast and loose version of <code class="docutils literal"><span class="pre">hs_exit()</span></code>, then call
<code class="docutils literal"><span class="pre">shutdownHaskellAndExit()</span></code> instead).</p>
</div>
</div>
<div class="section" id="floating-point-and-the-ffi">
<span id="ffi-floating-point"></span><h3>11.2.5. Floating point and the FFI<a class="headerlink" href="#floating-point-and-the-ffi" title="Permalink to this headline">¶</a></h3>
<p id="index-3">The standard C99 <code class="docutils literal"><span class="pre">fenv.h</span></code> header provides operations for inspecting
and modifying the state of the floating point unit. In particular, the
rounding mode used by floating point operations can be changed, and the
exception flags can be tested.</p>
<p>In Haskell, floating-point operations have pure types, and the
evaluation order is unspecified. So strictly speaking, since the
<code class="docutils literal"><span class="pre">fenv.h</span></code> functions let you change the results of, or observe the
effects of floating point operations, use of <code class="docutils literal"><span class="pre">fenv.h</span></code> renders the
behaviour of floating-point operations anywhere in the program
undefined.</p>
<p>Having said that, we <em>can</em> document exactly what GHC does with respect
to the floating point state, so that if you really need to use
<code class="docutils literal"><span class="pre">fenv.h</span></code> then you can do so with full knowledge of the pitfalls:</p>
<ul class="simple">
<li>GHC completely ignores the floating-point environment, the runtime
neither modifies nor reads it.</li>
<li>The floating-point environment is not saved over a normal thread
context-switch. So if you modify the floating-point state in one
thread, those changes may be visible in other threads. Furthermore,
testing the exception state is not reliable, because a context switch
may change it. If you need to modify or test the floating point state
and use threads, then you must use bound threads
(<code class="docutils literal"><span class="pre">Control.Concurrent.forkOS</span></code>), because a bound thread has its own
OS thread, and OS threads do save and restore the floating-point
state.</li>
<li>It is safe to modify the floating-point unit state temporarily during
a foreign call, because foreign calls are never pre-empted by GHC.</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="extending_ghc.html" title="12. Extending and using GHC as a Library"
             >next</a> |</li>
        <li class="right" >
          <a href="safe_haskell.html" title="10.39. Safe Haskell"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.0.2 Users Guide</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, GHC Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.2.
    </div>
  </body>
</html>