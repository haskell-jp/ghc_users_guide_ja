
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml" lang="ja">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.3. 最適化 (コードの改善) &#8212; Glasgow Haskell Compiler 8.2.2 User&#39;s Guide</title>
    
    <link rel="stylesheet" href="_static/ghc-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.2.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="_static/translations.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="search" type="application/opensearchdescription+xml"
          title="Glasgow Haskell Compiler 8.2.2 User&#39;s Guide 内を検索"
          href="_static/opensearch.xml"/>
    <link rel="index" title="索引" href="genindex.html" />
    <link rel="search" title="検索" href="search.html" />
    <link rel="next" title="7.4. Using Concurrent Haskell" href="using-concurrent.html" />
    <link rel="prev" title="7.2. 警告と整合性検査" href="using-warnings.html" /> 
  </head>
  <body role="document">
<div class="logo">
    <h1><a href="index.html">Glasgow Haskell Compiler User's Guide</a></h1>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="using-concurrent.html" title="7.4. Using Concurrent Haskell"
             accesskey="N">次へ</a> |</li>
        <li class="right" >
          <a href="using-warnings.html" title="7.2. 警告と整合性検査"
             accesskey="P">前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.2.2 User&#39;s Guide</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="usage.html" accesskey="U">7. GHCを使う</a> &#187;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">目次</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.3. 最適化 (コードの改善)</a><ul>
<li><a class="reference internal" href="#o">7.3.1. <code class="docutils literal"><span class="pre">-O*</span></code>: 便利な最適化フラグの「詰め合わせ」</a></li>
<li><a class="reference internal" href="#f">7.3.2. <code class="docutils literal"><span class="pre">-f*</span></code>: プラットフォーム非依存のフラグ</a></li>
</ul>
</li>
</ul>

  <h4>前のトピックへ</h4>
  <p class="topless"><a href="using-warnings.html"
                        title="前の章へ">7.2. 警告と整合性検査</a></p>
  <h4>次のトピックへ</h4>
  <p class="topless"><a href="using-concurrent.html"
                        title="次の章へ">7.4. Using Concurrent Haskell</a></p>
  <div role="note" aria-label="source link">
    <h3>このページ</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/using-optimisation.rst.txt"
            rel="nofollow">ソースコードを表示</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>クイック検索</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="検索" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>7.3. 最適化 (コードの改善)<a class="headerlink" href="#id1" title="このヘッドラインへのパーマリンク">¶</a></h1>
<p id="index-0"><code class="docutils literal"><span class="pre">-O*</span></code> オプションば便利な最適化フラグの「詰め合わせ」を指定するのに使います．
<em>個別の</em> 最適化を有効/無効にするには，後述する <code class="docutils literal"><span class="pre">-f*</span></code> オプションを使います．
<em>マシン固有</em> の最適化を有効/無効にするには <code class="docutils literal"><span class="pre">-m*</span></code> オプションを使います．</p>
<p>こうしたオプションのほとんどは，オプションをオン/オフする論理値になっています(オフにする場合は <code class="docutils literal"><span class="pre">no-</span></code> が前置されます)．
<code class="docutils literal"><span class="pre">-fspecialise</span></code> は特定化を有効にし，<code class="docutils literal"><span class="pre">-fno-specialise</span></code> は無効にします．
同じオプションに関して複数のフラグが1つのコマンドラインにあらわれたときは左から右への順で評価されますので，
<code class="docutils literal"><span class="pre">-fno-specialise</span> <span class="pre">-fspecialise</span></code> という指定では，特定化は有効になります．</p>
<p><code class="docutils literal"><span class="pre">-O*</span></code> という型のフラグは大まかにいって <code class="docutils literal"><span class="pre">-f*</span></code> という型のフラグの組み合わせを指定しているものになっているということに注意をしてください．
したがって <code class="docutils literal"><span class="pre">-O*</span></code> フラグと <code class="docutils literal"><span class="pre">-f*</span></code> フラグの効果はコマンドライン中にあらわれる順番に依存します．</p>
<p><code class="docutils literal"><span class="pre">-fno-specialise</span> <span class="pre">-O1</span></code> を例にとってみましょう．
コマンドラインに <code class="docutils literal"><span class="pre">-fno-specialise</span></code> があっても，特定化(specialisation)は有効になります．
これは <code class="docutils literal"><span class="pre">-O1</span></code> が <code class="docutils literal"><span class="pre">-fspecialise</span></code> を有効にするので，先に指定したフラグを上書きしてしまいます．
これとは対照的に <code class="docutils literal"><span class="pre">-O1</span> <span class="pre">-fno-specialise</span></code> のようにすると予想どおり特定化は発動しません．</p>
<div class="section" id="o">
<h2>7.3.1. <code class="docutils literal"><span class="pre">-O*</span></code>: 便利な最適化フラグの「詰め合わせ」<a class="headerlink" href="#o" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p>GHCが生成するコードの質に影響を与えるオプションは <em>大量に</em> あります．
ほとんどの人にとっては，最適化の目標は「素早くコンパイルする」とか「電光石火のごとく走るプログラムコードを生成する」など一般的なものです．
したがって，以下にしめすような最適化の「詰め合わせ」を指定(あるいは指定しない)する選択をするだけで十分です．</p>
<p>最適化のレベルを高くすると，モジュールを跨ぐ最適化が増えます．
これは，ソースコードを変更したときにどの程度の再コンパイルする必要があるかに大きく影響します．
これは開発中は最適化をしないようにすることの理由の1つです．</p>
<p><strong>``-O*``-タイプのオプションを指定することはありません．</strong>
このオプション意味は，「急いでコンパイルしてね．生成したコードのインスタンスについてはうるさいことは言わないから」です．
たとえば <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-c</span> <span class="pre">Foo.hs</span></code> のようにします．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--O0">
<code class="descname">-O0</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--O0" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>「すべての最適化を無効にする」という意味です． <code class="docutils literal"><span class="pre">-O``オプションを全く指定しないのと同じ状態にするということです．</span>
<span class="pre">わざわざ</span> <span class="pre">``-O0</span></code> を指定するのは <code class="docutils literal"><span class="pre">make</span></code> が既に <code class="docutils literal"><span class="pre">-O</span></code> オプションを指定してしまっているときに便利です．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--O">
<code class="descname">-O</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--O" title="この定義へのパーマリンク">¶</a></dt>
<dt id="ghc-flag--O1">
<code class="descname">-O1</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--O1" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-1">「高品質のコードをそれほど時間をかけないで生成する」という意味です．
<code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-c</span> <span class="pre">-O</span> <span class="pre">Main.lhs</span></code> のように使います．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--O2">
<code class="descname">-O2</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--O2" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-2">「危険のない最適化をすべて適用する．コンパイルにかなりの時間を書けてもよい」という意味です．</p>
<p>ここで回避しようとしている「危険な」最適化とは，運が悪ければ，実行時における時間・空間性能を <em>悪化させる</em> 可能性があるということです．
通常これらの最適化は個別に指定します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--Odph">
<code class="descname">-Odph</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--Odph" title="この定義へのパーマリンク">¶</a></dt>
<dd><p id="index-3">すべての <code class="docutils literal"><span class="pre">-O2</span></code> の最適化を有効にした上で <code class="docutils literal"><span class="pre">-fmax-simplifier-iterations=20</span></code> と <code class="docutils literal"><span class="pre">-fsimplifier-phases=3</span></code> を設定します．
<a class="reference internal" href="parallel.html#dph"><span class="std std-ref">Data Parallel Haskell (DPH)</span></a> を使うときように設計されました．</p>
</dd></dl>

<p>日常の作業で <code class="docutils literal"><span class="pre">-O*</span></code> フラグを使うことはありません．
それなりの速度が必要なときには <code class="docutils literal"><span class="pre">-O</span></code> を使います．
たとえば，何かを計測したいときなどです．
ちょっと休憩したいときには <code class="docutils literal"><span class="pre">-O2</span></code> を使い(たっぷりのコーヒーブレイクに行き)ます．</p>
<p><code class="docutils literal"><span class="pre">-O</span></code> (など)の「実際の意味」を知りたければ <a class="reference internal" href="using.html#ghc-flag--v"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-v</span></code></a> を付ければいいでしょう．
びっくりして，後ずさりすることになるでしょうね．</p>
</div>
<div class="section" id="f">
<h2>7.3.2. <code class="docutils literal"><span class="pre">-f*</span></code>: プラットフォーム非依存のフラグ<a class="headerlink" href="#f" title="このヘッドラインへのパーマリンク">¶</a></h2>
<p id="index-4">これらのフラグは個々の最適化を有効/無効にするのに使います．
<code class="docutils literal"><span class="pre">-O</span></code> を使えば，「デフォルトで有効」となっているフラグをすべて有効にできます．
したがって，明示的に指定する必要はないはずです．
<code class="docutils literal"><span class="pre">-fwombat</span></code> というフラグの否定は <code class="docutils literal"><span class="pre">-fno-wombat</span></code> です．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fcase-merge">
<code class="descname">-fcase-merge</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fcase-merge" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>直接入れ子になった case 式の検査対象が同じ変数である場合，1つにまとめます．
たとえば，</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Red</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
            <span class="kt">Blue</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
            <span class="kt">Green</span> <span class="ow">-&gt;</span> <span class="n">e3</span>
</pre></div>
</div>
<p>は以下のよう変換します．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Red</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="kt">Blue</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
   <span class="kt">Green</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
</pre></div>
</div>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcase-folding">
<code class="descname">-fcase-folding</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fcase-folding" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>あるプリミティブ演算を確認する <code class="docutils literal"><span class="pre">case</span></code> 式で定数畳み込みを可能にします．
たとえば，</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">x</span> <span class="p">`</span><span class="n">minusWord</span><span class="o">#</span><span class="p">`</span> <span class="mi">10</span><span class="o">##</span> <span class="kr">of</span>
   <span class="mi">10</span><span class="o">##</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="mi">20</span><span class="o">##</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
   <span class="n">v</span>    <span class="ow">-&gt;</span> <span class="n">e3</span>
</pre></div>
</div>
<p>は以下のように変換します．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="mi">20</span><span class="o">##</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="mi">30</span><span class="o">##</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
   <span class="kr">_</span>    <span class="ow">-&gt;</span> <span class="kr">let</span> <span class="n">v</span> <span class="ow">=</span> <span class="n">x</span> <span class="p">`</span><span class="n">minusWord</span><span class="o">#</span><span class="p">`</span> <span class="mi">10</span><span class="o">##</span> <span class="kr">in</span> <span class="n">e3</span>
</pre></div>
</div>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcall-arity">
<code class="descname">-fcall-arity</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fcall-arity" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>コール・アリティ解析を有効にします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcmm-elim-common-blocks">
<code class="descname">-fcmm-elim-common-blocks</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fcmm-elim-common-blocks" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>コード生成器における共通ブロック除去を有効にします．
この最適化の目的は，同一の Cmm ブロックを探し，それを除去します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcmm-sink">
<code class="descname">-fcmm-sink</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fcmm-sink" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>コード生成器におけるシンキング(コード位置を後ろにずらすこと)のパスを有効にします．
この最適化の目的は Cmm の同一のブロックを探すことです．
その重複を除去すれば変数束縛を使う場所に近づけられます．
このパスではリテラルやレジスタなどの単純な式を埋め込みます．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcpr-off">
<code class="descname">-fcpr-off</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fcpr-off" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>デマンド解析器における CPR 解析を無効にする．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcse">
<code class="descname">-fcse</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fcse" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>共通部分式除去の最適化を有効にします．
共通式としてまとめたくないような <code class="docutils literal"><span class="pre">unsafePerformIO</span></code> 式を使っている場合にはこれを無効にするのが便利です．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstg-cse">
<code class="descname">-fstg-cse</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fstg-cse" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>STG 中間言語での共通部分式除去の最適化を有効にします．
この段階で表現は同じで型の異なる部分式をまとめられます．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdicts-cheap">
<code class="descname">-fdicts-cheap</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fdicts-cheap" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>かなり実験的なフラグで，辞書を値にもつような式のコストを最適化器が安く見積るようにします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdicts-strict">
<code class="descname">-fdicts-strict</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fdicts-strict" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>辞書を正格にします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdmd-tx-dict-sel">
<code class="descname">-fdmd-tx-dict-sel</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fdmd-tx-dict-sel" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>辞書選択子ように特別な要求変換子を使います．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdo-eta-reduction">
<code class="descname">-fdo-eta-reduction</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fdo-eta-reduction" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>λ抽象式をη簡約することで，複数のλ抽象式をまとめて除去できるなら，そうします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdo-lambda-eta-expansion">
<code class="descname">-fdo-lambda-eta-expansion</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fdo-lambda-eta-expansion" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>アリティを増やすために let 束縛をη展開します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--feager-blackholing">
<code class="descname">-feager-blackholing</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--feager-blackholing" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>通常 GHC はスレッドを切り替える場合にのみサンクをブラックホール化します．
このフラグは，サンクに入ってすぐにこれを行うようにします．
以下を参照してください． <a class="reference external" href="http://community.haskell.org/~simonmar/papers/multiproc.pdf">Haskell on a shared-memory
multiprocessor</a></p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fexcess-precision">
<code class="descname">-fexcess-precision</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fexcess-precision" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>このオプションを指定すると，中間の浮動小数点数が最終的な型よりも <em>大きな</em> 精度/範囲をもつことを許すことになります．
このことは一般的には良いことです．
しかし <code class="docutils literal"><span class="pre">Float</span></code>/<code class="docutils literal"><span class="pre">Double</span></code> 値がその精度/範囲に正確におさまっていることに依存するプログラムが存在することもあり，
そのようなプログラムにはこのオプションを指定してコンパイルしてはいけません．</p>
<p>32-bit x86 のネイティブコード生成器は excess-precision モードしかサポートしておらず <code class="docutils literal"><span class="pre">-fexcess-precision</span></code> も
<code class="docutils literal"><span class="pre">-fno-excess-precision</span></code> も効果を持ちません．これは既知のバグです． <a class="reference internal" href="bugs.html#bugs-ghc"><span class="std std-ref">Bugs in GHC</span></a> を参照してください．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fexpose-all-unfoldings">
<code class="descname">-fexpose-all-unfoldings</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fexpose-all-unfoldings" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>実験的なフラグです．非常に大きな関数や再帰関数も含め，すべての展開を露出します．
通常GHCは大きい関数をインライン化することを避けますが，このフラグによって，全ての関数がインライン化可能になります．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ffloat-in">
<code class="descname">-ffloat-in</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--ffloat-in" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>let 束縛を内側，利用位置に近づく方向に移動します．
<a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs
(ICFP&#8216;96)</a>
を参照してください．</p>
<p>この最適化は let 束縛を仕様の位置に近づけます．
こうすることの利点は，let の移動先の選択肢が実行されない場合，不要なメモリ領域確保を防ぐことができる点です．
また，局所的により多くの情報が得られることになるので，他の最適化パスがより効率よく機能できることになります．</p>
<p>この最適化は常によい方向の効果があるというわけではありません．
そういうわけで，GHC はこれを適用するかどうかをある種のヒューリスティクスを使って決定しています．
詳細は複雑ですが，この最適化がよい効果をもたらさない単純な例としては，let 束縛を外側に移動することで，
複数の束縛を1つの大きな束縛にまとめ，メモリ領域の確保を一度に行うことで，ガーベッジコレクタとアロケータが楽になるという場合です．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ffull-laziness">
<code class="descname">-ffull-laziness</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--ffull-laziness" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>完全遅延性最適化(let-floating ともいいます)を走らせます．
これは let 束縛を計算が少くなるようにと願って，それを囲むλ抽象の外へ移動させることです．
これについては
<a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs
(ICFP&#8216;96)</a>
を参照してください．共有を促進する完全遅延性はメモリの使用量を増加させることになります．</p>
<div class="admonition note">
<p class="first admonition-title">注釈</p>
<p class="last">GHC は完全遅延性を完全には実装していません．
最適化が有効で <code class="docutils literal"><span class="pre">-fno-full-laziness</span></code> が指定されていなければ，
共有を促進するある種の変換が実施されます．
たとえば，ループの中から繰り返し計算される部分を抽出するといった変換です．
この変換は完全遅延の実装で行われるのと同じものですが，GHC は常に完全遅延性を適用するとは限らないので，これに頼ってはいけません．</p>
</div>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ffun-to-thunk">
<code class="descname">-ffun-to-thunk</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--ffun-to-thunk" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>worker-wrapper は使われていない引数を削除しますが，通常はクロージャをサンクにしてしまわないように，全部を削除することはしません．
そんなことをしてしまうと，スペースリークしたり，インライン化の妨げになるからです．
このフラグは worker/wrapper が <em>すべての</em> λ抽象値を削除できるようにします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fignore-asserts">
<code class="descname">-fignore-asserts</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fignore-asserts" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>ソースコード中で <code class="docutils literal"><span class="pre">Exception.assert</span></code> を使っていても，GHC はこれを無視し(すなわち <code class="docutils literal"><span class="pre">Exception.assert</span> <span class="pre">p</span> <span class="pre">e</span></code> を <code class="docutils literal"><span class="pre">e</span></code> に書き換え)ます(<a class="reference internal" href="glasgow_exts.html#assertions"><span class="std std-ref">Assertions</span></a> を参照してください)．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fignore-interface-pragmas">
<code class="descname">-fignore-interface-pragmas</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fignore-interface-pragmas" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>インターフェイスファイルを読み込むときに不必要な情報はすべて無視するよう GHC に指示します．
すなわち <code class="file docutils literal"><span class="pre">M.hi</span></code> にある関数の展開情報や正格性情報があっても，GHC はこれらの情報を無視します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--flate-dmd-anal">
<code class="descname">-flate-dmd-anal</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--flate-dmd-anal" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>単純化パイプラインの最後に再度，要求解析(demand analysys)を走らせます．
前段階では見えなかった正格性を発見する場合があり
<a class="reference internal" href="#ghc-flag--fspec-constr"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fspec-constr</span></code></a> などの最適化によって作られた関数の未使用引数をこの後段階で取り除けることが判っています．
改善はささやかなものですが，コストもわずかです．
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/wiki/LateDmd">Trac wiki page</a> にある注も参照してください．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fliberate-case">
<code class="descname">-fliberate-case</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fliberate-case" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効だが， <a class="reference internal" href="#ghc-flag--O2"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O2</span></code></a> で有効</td>
</tr>
</tbody>
</table>
<p>liberate-case変換を有効にします．
これは再帰関数をその右辺で1回展開して，自由変数がくりかえしcaseで検査されるのを回避します．
これは，呼び出しパターンの特殊化(<a class="reference internal" href="#ghc-flag--fspec-constr"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fspec-constr</span></code></a>)に似ていますが
<a class="reference internal" href="#ghc-flag--fliberate-case"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fliberate-case</span></code></a> は引数ではなく自由変数を対象にしています．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fliberate-case-threshold=⟨n⟩">
<code class="descname">-fliberate-case-threshold</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fliberate-case-threshold=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">2000</td>
</tr>
</tbody>
</table>
<p>liberate-case変換サイズの閾値を設定します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--floopification">
<code class="descname">-floopification</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--floopification" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>この最適化を有効にするとコードジェネレータはすべての自己再帰的飽和末尾呼び出しを関数呼び出しではなくローカルジャンプに変換します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-inline-alloc-size=⟨n⟩">
<code class="descname">-fmax-inline-alloc-size</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-inline-alloc-size=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">128</td>
</tr>
</tbody>
</table>
<p>インライン配列の割り当ての最大サイズをnバイトに設定します．
GHCは現在の苗床ブロックに静的に判明しているサイズの非固定配列をnバイトで割り当てます．
GCの過熱を無視しての割り当てになります．この値はブロックサイズ（通常は4096）よりもかなり小さくする必要があります．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-inline-memcpy-insns=⟨n⟩">
<code class="descname">-fmax-inline-memcpy-insns</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-inline-memcpy-insns=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">32</td>
</tr>
</tbody>
</table>
<p>展開後の疑似命令が⟨n⟩バイトを超えない場合に <code class="docutils literal"><span class="pre">memcpy</span></code> の呼び出しをインライン展開します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-inline-memset-insns=⟨n⟩">
<code class="descname">-fmax-inline-memset-insns</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-inline-memset-insns=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">32</td>
</tr>
</tbody>
</table>
<p>展開後の疑似命令が⟨n⟩バイトを超えない場合に <code class="docutils literal"><span class="pre">memset</span></code> の呼び出しをインライン展開します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-relevant-binds=⟨n⟩">
<code class="descname">-fmax-relevant-binds</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-relevant-binds=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dt id="ghc-flag--fno-max-relevant-bindings">
<code class="descname">-fno-max-relevant-bindings</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fno-max-relevant-bindings" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">6</td>
</tr>
</tbody>
</table>
<p>型チェッカーは，エラーメッセージに型環境の断片を表示することがありますが，
このフラグによって設定される最大数までしか表示されません．
<code class="docutils literal"><span class="pre">-fno-max-relevant-bindings</span></code> でこれを無効にすると，無制限になります．
構文上のトップレベルの束縛も通常は除外されています(数が多すぎる可能性があるため)が，
<code class="docutils literal"><span class="pre">-fno-max-relevant-bindings</span></code> を使えばこれらも含められます．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-uncovered-patterns=⟨n⟩">
<code class="descname">-fmax-uncovered-patterns</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-uncovered-patterns=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">4</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="using-warnings.html#ghc-flag--Wincomplete-patterns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wincomplete-patterns</span></code></a> および <a class="reference internal" href="using-warnings.html#ghc-flag--Wincomplete-uni-patterns"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wincomplete-uni-patterns</span></code></a> で生成される警告に
含めるマッチしないパターンの最大数を設定します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-simplifier-iterations=⟨n⟩">
<code class="descname">-fmax-simplifier-iterations</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-simplifier-iterations=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">4</td>
</tr>
</tbody>
</table>
<p>単純化器の反復回数の最大値を設定します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-worker-args=⟨n⟩">
<code class="descname">-fmax-worker-args</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-worker-args=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">10</td>
</tr>
</tbody>
</table>
<p>この数までのワーカーの引数はアンパックされることはありません．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fno-opt-coercion">
<code class="descname">-fno-opt-coercion</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fno-opt-coercion" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>強制変換最適化を無効にします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fno-pre-inlining">
<code class="descname">-fno-pre-inlining</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fno-pre-inlining" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>事前インライン展開を無効にします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fno-state-hack">
<code class="descname">-fno-state-hack</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fno-state-hack" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal"><span class="pre">State#</span></code> トークンを引数とするλ抽象式をシングルエントリーであるとみなす &#8220;state hack&#8221; を無効にします．
これにより，その内部のものをインライン化してもよいことになります．
そうすると IOモナドおよびSTモナドのコードのパフォーマンスが向上する可能性があります．
しかし，共有を減らすリスクがあります．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fomit-interface-pragmas">
<code class="descname">-fomit-interface-pragmas</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fomit-interface-pragmas" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>GHCに，コンパイルしようとしているモジュール（例えば M）用に生成するインタフェースファイルから
すべての本質的ではないな情報を省略するよう指示します．
すなわち，M をインポートするモジュールには，M がエクスポートする関数の型だけが見えていますが，
展開や正格性情報などは見えません．したがって，Mがエクスポートする関数は，インポートモジュールでインライン展は開されません．
そのメリットは，Mをインポートするモジュールは再コンパイルしなければならない頻度が少なくなるということです．
(M のエクスポートで型が変更されたときのみで，実装ののみの変更時は再コンパイルが不要です．)</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fomit-yields">
<code class="descname">-fomit-yields</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fomit-yields" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>メモリが確保されない場合，GHC がヒープ検査を省略するようにします．
これによりバイナリのサイズが 5% ほど改善されますが，メモリ確保のないループを実行している場合，
すぐには割り込みがかからないということも意味します．
このようなスレッドで常にすぐに割り込みできることが重要な場合は，この最適化を無効にすべきです．
割り込みができることを保証したければ，この最適化を無効にしたうえで，
すべてのライブラリを再コンパイルすることを検討してください．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fpedantic-bottoms">
<code class="descname">-fpedantic-bottoms</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fpedantic-bottoms" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>GHC が底値(ボトム，⊥)をより精密に扱うようにします
(ただし <a class="reference internal" href="#ghc-flag--fno-state-hack"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fno-state-hack</span></code></a> も参照してください)．
具体的には，case 式を通しての η 展開が行われなくなります．
通常この η 展開は性能にはよいのですが，部分適用で <code class="docutils literal"><span class="pre">seq</span></code> を使っていると悪影響になります．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fregs-graph">
<code class="descname">-fregs-graph</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fregs-graph" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">性能を劣化させるバグ(<a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/7679">Trac #7679</a>)があるために無効</td>
</tr>
</tbody>
</table>
<p><em>ネイティブコード生成器との組み合わせでのみ適用します．</em>
ネイティブコード生成器において，グラフ彩色レジスタ割り付けをつかいます．
デフォルトでは，GHCはもっと単純で速い線形レジスタ割り付けを使います．
その欠点は，線形割り付けは通常，よりよくないコードを生成するいことがあるということです．</p>
<p>グラフ彩色割り付けはいくぶんか実験的な実装になっており，レジスタの使い方が厳しいコードでは失敗することがあります．
<a class="reference external" href="https://ghc.haskell.org/trac/ghc/ticket/8657">Trac #8657</a></p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fregs-iterative">
<code class="descname">-fregs-iterative</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fregs-iterative" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p><em>ネイティブコード生成器との組み合わせでのみ適用します．</em>
ネイティブコード生成器において，反復合併グラフ彩色レジスタ割り付けをつかいます．
これは <a class="reference internal" href="#ghc-flag--fregs-graph"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fregs-graph</span></code></a> で有効になるレジスタ割り付けと同じですが，
レジスタ割り付けのさなかの反復合併(iterative coalescing)が有効になります．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fsimplifier-phases=⟨n⟩">
<code class="descname">-fsimplifier-phases</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fsimplifier-phases=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">2</td>
</tr>
</tbody>
</table>
<p>単純化器のフェーズ数を指定の数値に設定します． <code class="docutils literal"><span class="pre">-O0</span></code> を指定すると，この値は無視します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fsimpl-tick-factor=⟨n⟩">
<code class="descname">-fsimpl-tick-factor</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fsimpl-tick-factor=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">100</td>
</tr>
</tbody>
</table>
<p>停止しない書き換え規則(<a class="reference internal" href="glasgow_exts.html#rewrite-rules"><span class="std std-ref">Rewrite rules</span></a>)を書いてしまったり，
(もうすこし嫌なことに)データ型を通して再帰するコードを書いてしまったりすると，
GHCの最適化器は発散してしまいます(<a class="reference internal" href="bugs.html#bugs-ghc"><span class="std std-ref">Bugs in GHC</span></a>)．
コンパイラが無限ループに陥いるのを避けるため，最適化器は「tickの回数」を保持し，
この回数を超過したときには，インライン化と書き換え規則の適用をやめます．
大きいプログラムが多くのtickを使えるように，この限界はプログラムのサイズの定数倍になります．
<code class="docutils literal"><span class="pre">-fsimpl-tick-factor</span></code> フラッグはこの定数を変更できるようにしたものです．
デフォルトの値は 100 で，100より大きな値を指定するとより多くのtick数が使え，
100より小さな値を指定するとより少ないtick数しか使えなくなります．</p>
<p>tick数が尽きると GHC は単純化器をとめ，それまで実行した部分を要約します．
<code class="docutils literal"><span class="pre">-fddump-simpl-stats</span></code> を使えばより詳細な一覧を生成できます．
これにより，ループのほとんどは正確に把握できます．いくつかの数値がかなりの大きさになるからである．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr">
<code class="descname">-fspec-constr</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fspec-constr" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効．<a class="reference internal" href="#ghc-flag--O2"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O2</span></code></a> によって有効になる．</td>
</tr>
</tbody>
</table>
<p>呼び出しパターン特殊化
(<a class="reference external" href="https://www.microsoft.com/en-us/research/publication/system-f-with-type-equality-coercions-2/">Call-pattern specialisation for
Haskell programs</a>
を参照してください)を有効にします．</p>
<p>この最適化は，引数の「シェイプ」にしたがって再帰関数を特殊化します．
このことは例で説明するのがよいでしょう．以下のような場合を考えましょう．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">last</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">last</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;last&quot;</span>
<span class="nf">last</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">last</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last</span> <span class="n">xs</span>
</pre></div>
</div>
<p>このコードでは，リストが空でないとき，帰納部でのパターン照合が冗長であることがわかります．
このような場合 <code class="docutils literal"><span class="pre">-fspec-constr</span></code> は上のコードを以下のように変換します．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="nf">last</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">last</span> <span class="kt">[]</span>       <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;last&quot;</span>
<span class="nf">last</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last&#39;</span> <span class="n">x</span> <span class="n">xs</span>
    <span class="kr">where</span>
      <span class="n">last&#39;</span> <span class="n">x</span> <span class="kt">[]</span>       <span class="ow">=</span> <span class="n">x</span>
      <span class="n">last&#39;</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last&#39;</span> <span class="n">y</span> <span class="n">ys</span>
</pre></div>
</div>
<p>不必要なパターン照合を避けるだけでなく，不要な割り当てを回避するのにも役立ちます．
これは，引数が自分自身への再帰呼び出しについて正格であっても，最初のエントリについては正格でない場合に適用します．
上記の例のように，関数の正格な再帰的分岐が作成されるのです．</p>
<p>またライブラリの作者が GHC に呼び出しパターンの特殊化を相当積極的に指示することもできます．
高度に最適化するライブラリでは，特殊化の数やコードサイズにかかわらず必要になります．
一例として <code class="docutils literal"><span class="pre">vector</span></code> ライブラリから単純化した場合を考えてみましょう．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">import</span> <span class="nn">GHC.Types</span> <span class="p">(</span><span class="kt">SPEC</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>

<span class="nf">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="cm">{-# INLINE foldl #-}</span>
<span class="nf">foldl</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">step</span> <span class="n">s</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldl_loop</span> <span class="kt">SPEC</span> <span class="n">z</span> <span class="n">s</span>
  <span class="kr">where</span>
    <span class="n">foldl_loop</span> <span class="o">!</span><span class="n">sPEC</span> <span class="n">z</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">step</span> <span class="n">s</span> <span class="kr">of</span>
                            <span class="kt">Yield</span> <span class="n">x</span> <span class="n">s&#39;</span> <span class="ow">-&gt;</span> <span class="n">foldl_loop</span> <span class="n">sPEC</span> <span class="p">(</span><span class="n">f</span> <span class="n">z</span> <span class="n">x</span><span class="p">)</span> <span class="n">s&#39;</span>
                            <span class="kt">Skip</span>       <span class="ow">-&gt;</span> <span class="n">foldl_loop</span> <span class="n">sPEC</span> <span class="n">z</span> <span class="n">s&#39;</span>
                            <span class="kt">Done</span>       <span class="ow">-&gt;</span> <span class="n">z</span>
</pre></div>
</div>
<p>ここで，ループ本体の引数に <code class="docutils literal"><span class="pre">SPEC</span></code> が使われていますので， GHC は <code class="docutils literal"><span class="pre">foldl</span></code> 本体を呼び出し側でインライン展開し，
<code class="docutils literal"><span class="pre">foldl_loop</span></code> で呼び出しパターンの特殊化を相当積極的に行います．
<code class="docutils literal"><span class="pre">GHC.Types</span></code> 由来の <code class="docutils literal"><span class="pre">SPEC</span></code> はコンパイラが特別に認識します．</p>
<p>(注意: <code class="docutils literal"><span class="pre">SPEC</span></code> 引数に対して <code class="docutils literal"><span class="pre">seq</span></code> またはバンパターンを使うことが非常に重要です．)</p>
<p>インライン展開した後では，ループ本体から <code class="docutils literal"><span class="pre">f</span></code> が直接見えるようになるので，
帰納部に対して激しい特殊化が可能になります．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr-keen">
<code class="descname">-fspec-constr-keen</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fspec-constr-keen" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>このフラグが有効であれば，呼び出しパターン特殊化が，明示的な構成子の引数をもつ，
たとえば <code class="docutils literal"><span class="pre">(f</span> <span class="pre">(Just</span> <span class="pre">x)</span></code> に対して行われます．これは関数本体が精査されてなくても行われます．
これは時として有益で，たとえば，引数はそれ自体が特殊化できる他の関数に渡せることもあります．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr-count=⟨n⟩">
<code class="descname">-fspec-constr-count</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fspec-constr-count=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">3</td>
</tr>
</tbody>
</table>
<p>SpecConstr 変換による1つの関数に対する特殊化の最大数を設定します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr-threshold=⟨n⟩">
<code class="descname">-fspec-constr-threshold</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fspec-constr-threshold=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">2000</td>
</tr>
</tbody>
</table>
<p>SpecConstr 変換用のサイズ閾値を設定します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspecialise">
<code class="descname">-fspecialise</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fspecialise" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>このモジュールで定義された，型クラスによる多重定義関数それぞれをこのモジュールで使われている型について特殊化します．
また，<a class="reference internal" href="#ghc-flag--fcross-module-specialise"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fcross-module-specialise</span></code></a> が有効である場合，
INLINABLE プラグマ (<a class="reference internal" href="glasgow_exts.html#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>) をもつインポートされた関数について，
このモジュールで呼ばれている型で特殊化します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspecialise-aggressively">
<code class="descname">-fspecialise-aggressively</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fspecialise-aggressively" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>デフォルトでは，型クラスメソッドおよび <code class="docutils literal"><span class="pre">INLINABLE</span></code> あるいは <code class="docutils literal"><span class="pre">INLINE</span></code> のマークが付いている関数だけ特殊化します．
このフラグを指定すると，展開可能であればそのサイズにかかわらず多重定義された関数を特殊化します．
コードサイズが著しく大きくなるので，このフラグはどの最適化レベルにも含まれていません．
すべての呼び出しを確実に特殊化したければ <a class="reference internal" href="#ghc-flag--fexpose-all-unfoldings"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fexpose-all-unfoldings</span></code></a> と同時に有効にすることもできます．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcross-module-specialise">
<code class="descname">-fcross-module-specialise</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fcross-module-specialise" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>他のモジュール由来の``INLINABLE`` (<a class="reference internal" href="glasgow_exts.html#inlinable-pragma"><span class="std std-ref">INLINABLE pragma</span></a>)の付いた型クラスにより多重定義された関数を
このモジュールで呼ばれる型について特殊化します．
これが効果を発揮するためには，特殊化が(<code class="docutils literal"><span class="pre">-fspecialise</span></code> によって)有効になっていなければなりません．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fsolve-constant-dicts">
<code class="descname">-fsolve-constant-dicts</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fsolve-constant-dicts" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>制約解決のときに，利用可能な辞書を使てスーパークラスを先行して解決します．</p>
<p>たとえば，</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">class</span> <span class="kt">M</span> <span class="n">a</span> <span class="n">b</span> <span class="kr">where</span> <span class="n">m</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>

<span class="kr">type</span> <span class="kt">C</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">M</span> <span class="n">a</span> <span class="n">b</span><span class="p">)</span>

<span class="nf">f</span> <span class="ow">::</span> <span class="kt">C</span> <span class="kt">Int</span> <span class="n">b</span> <span class="ow">=&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Int</span>
<span class="nf">f</span> <span class="kr">_</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
<p>の場合 <cite>f</cite> の本体には <cite>Num Int</cite> インスタンスが必要です．
この制約をコンテキストから解決できるのは <cite>C Int b</cite> が <cite>Num Int</cite> の解決をもたらすからです．
しかし，利用可能な <cite>Num Int</cite> の辞書を直接解決することで，より良いコードを生成できます．
そうすることで，潜在的に多くの関節参照レイヤを除去でき，ディクショナリが静的に識別され，
セレクタ関数がインライン展開されるために，その他の最適化に非常によく効きます．</p>
<p>この最適化は辞書を束縛する GADT でも有効です．
どのクラスのディクショナリが必要なのか静的に判れば，
実行時に渡されたものを関節的に使用するのではなく，直接解決できます．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstatic-argument-transformation">
<code class="descname">-fstatic-argument-transformation</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fstatic-argument-transformation" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p>静的引数変換を有効にします．静的引数変換は再帰関数を局所的なループをもつ非再帰関数に変換します．
<a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/santos-thesis.ps.gz">Andre Santos&#8217;s PhD
thesis</a>
の第7章を参照してください．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstrictness">
<code class="descname">-fstrictness</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fstrictness" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>正格性解析器を有効にします．GHC の正格性解析器に関するかなり古い論文に
<a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/simple-strictnes-analyser.ps.gz">Measuring the
effectiveness of a simple strictness
analyser</a>
がありますが，現在の正格性解析器はそれとはかなり違っています．</p>
<p>正格性解析器は，どの引数と変数が関数内で「正格に」使われている(つまり，その関数内でいずれ評価される)かを調べます．
これにより，lazyな引数に適用された場合にはプログラムの意味を変えてしまうような最適化(非ボックス化)を
GHCが適用できるようになります．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstrictness-before=⟨n⟩">
<code class="descname">-fstrictness-before</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fstrictness-before=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><p>単純化器フェーズ ⟨n⟩ の前に正格性解析を追加で走らせます．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funbox-small-strict-fields">
<code class="descname">-funbox-small-strict-fields</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--funbox-small-strict-fields" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p id="index-5">このオプションは，正格であると標示(つまり「!」)された構築子フィールドで，
表現がポインタ一個以下の大きさであるものを可能なら全てアンパックする．
これは，大きさの制約を満たす全ての正格なフィールドに
<code class="docutils literal"><span class="pre">UNPACK</span></code> プラグマ(<a class="reference internal" href="glasgow_exts.html#unpack-pragma"><span class="std std-ref">UNPACK pragma</span></a> を参照)を付けるのと同じです．</p>
<p>例として，以下のようなデータ型の構成子フィールドを考えましょう．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span></span><span class="kr">data</span> <span class="kt">A</span> <span class="ow">=</span> <span class="kt">A</span> <span class="o">!</span><span class="kt">Int</span>
<span class="kr">data</span> <span class="kt">B</span> <span class="ow">=</span> <span class="kt">B</span> <span class="o">!</span><span class="kt">A</span>
<span class="kr">newtype</span> <span class="kt">C</span> <span class="ow">=</span> <span class="kt">C</span> <span class="kt">B</span>
<span class="kr">data</span> <span class="kt">D</span> <span class="ow">=</span> <span class="kt">D</span> <span class="o">!</span><span class="kt">C</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">-funbox-small-strict-fields</span></code> を有効にすると，これらのフィールドは全て単一の
<code class="docutils literal"><span class="pre">Int#</span></code> (<a class="reference internal" href="glasgow_exts.html#primitives"><span class="std std-ref">Unboxed types and primitive operations</span></a> 参照)の値で表現されます．</p>
<p>このオプションは <code class="docutils literal"><span class="pre">-funbox-strict-fields</span></code> に比べると大槌を振り回す感は少なくなります．
<code class="docutils literal"><span class="pre">-funbox-small-strict-fields</span></code> を使えば，非ボックス化を有効にしている場合，
<code class="docutils literal"><span class="pre">NOUNPACK</span></code> プラグマ(<a class="reference internal" href="glasgow_exts.html#nounpack-pragma"><span class="std std-ref">NOUNPACK pragma</span></a> 参照)を使って個々の構成子フィールドについてこれを無効にできます．</p>
<p>32ビットプラットフォームでは <code class="docutils literal"><span class="pre">Double</span></code> ， <code class="docutils literal"><span class="pre">Word64</span></code> ， <code class="docutils literal"><span class="pre">Int64</span></code> の構成子フィールドは，
技術的にポインタよりも大きいにもかかわらず，アンパックされることに注意してください．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funbox-strict-fields">
<code class="descname">-funbox-strict-fields</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--funbox-strict-fields" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">無効</td>
</tr>
</tbody>
</table>
<p id="index-6">このオプションは，正格性を示すマーク(つまり「!」)が付けられた構成子フィールドで，
表現がポインタ一個以下の大きさであるものを可能なら全てアンパックします．
これは大きさの制約を満たす全ての正格なフィールドに <code class="docutils literal"><span class="pre">UNPACK</span></code> プラグマ(<a class="reference internal" href="glasgow_exts.html#unpack-pragma"><span class="std std-ref">UNPACK pragma</span></a> 参照)を
付けまわるのと同等です．</p>
<p>このオプションには少々大槌を振り回す感があります．
場合によっては事態を悪化させることもありえます．
<code class="docutils literal"><span class="pre">UNPACK</span></code> を使ってフィールドを選択的に非ボックス化する方が良いかもしれません．
あるいは <code class="docutils literal"><span class="pre">-funbox-strict-fields</span></code> を使ってデフォルトで非ボックス化を有効にしつつ，
<code class="docutils literal"><span class="pre">NOUNPACK</span></code> プラグマ(<a class="reference internal" href="glasgow_exts.html#nounpack-pragma"><span class="std std-ref">NOUNPACK pragma</span></a> 参照)で特定の構成子フィールドをについて
非ボックス化を無効する方が良いかもしれません．</p>
<p>あるいは <a class="reference internal" href="#ghc-flag--funbox-small-strict-fields"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-funbox-small-strict-fields</span></code></a> を使って「小さい」非ボックスフィールドだけにする手もあります．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-creation-threshold=⟨n⟩">
<code class="descname">-funfolding-creation-threshold</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-creation-threshold=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">750</td>
</tr>
</tbody>
</table>
<p id="index-7">Governs the maximum size that GHC will allow a
function unfolding to be. (An unfolding has a “size” that reflects
the cost in terms of “code bloat” of expanding (aka inlining) that
unfolding at a call site. A bigger function would be assigned a
bigger cost.)</p>
<p>Consequences:</p>
<ol class="loweralpha simple">
<li>nothing larger than this will be inlined (unless it has an <code class="docutils literal"><span class="pre">INLINE</span></code> pragma)</li>
<li>nothing larger than this will be spewed into an interface file.</li>
</ol>
<p>Increasing this figure is more likely to result in longer compile times
than faster code. The <a class="reference internal" href="#ghc-flag--funfolding-use-threshold=⟨n⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-funfolding-use-threshold=⟨n⟩</span></code></a> is more
useful.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-dict-discount=⟨n⟩">
<code class="descname">-funfolding-dict-discount</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-dict-discount=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">30</td>
</tr>
</tbody>
</table>
<p id="index-8">How eager should the compiler be to inline dictionaries?</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-fun-discount=⟨n⟩">
<code class="descname">-funfolding-fun-discount</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-fun-discount=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">60</td>
</tr>
</tbody>
</table>
<p id="index-9">How eager should the compiler be to inline functions?</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-keeness-factor=⟨n⟩">
<code class="descname">-funfolding-keeness-factor</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-keeness-factor=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">1.5</td>
</tr>
</tbody>
</table>
<p id="index-10">How eager should the compiler be to inline functions?</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-use-threshold=⟨n⟩">
<code class="descname">-funfolding-use-threshold</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-use-threshold=⟨n⟩" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">60</td>
</tr>
</tbody>
</table>
<p id="index-11">This is the magic cut-off figure for unfolding (aka
inlining): below this size, a function definition will be unfolded
at the call-site, any bigger and it won&#8217;t. The size computed for a
function depends on two things: the actual size of the expression
minus any discounts that apply depending on the context into which
the expression is to be inlined.</p>
<p>The difference between this and
<a class="reference internal" href="#ghc-flag--funfolding-creation-threshold=⟨n⟩"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-funfolding-creation-threshold=⟨n⟩</span></code></a> is that this one determines
if a function definition will be inlined <em>at a call site</em>. The other option
determines if a function definition will be kept around at all for
potential inlining.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fvectorisation-avoidance">
<code class="descname">-fvectorisation-avoidance</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fvectorisation-avoidance" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p id="index-12">Part of <a class="reference internal" href="parallel.html#dph"><span class="std std-ref">Data Parallel Haskell (DPH)</span></a>.</p>
<p>Enable the <em>vectorisation</em> avoidance optimisation.
This optimisation only works when used in combination with the
<code class="docutils literal"><span class="pre">-fvectorise</span></code> transformation.</p>
<p>While vectorisation of code using DPH is often a big win, it can
also produce worse results for some kinds of code. This optimisation
modifies the vectorisation transformation to try to determine if a
function would be better of unvectorised and if so, do just that.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fvectorise">
<code class="descname">-fvectorise</code><code class="descclassname"></code><a class="headerlink" href="#ghc-flag--fvectorise" title="この定義へのパーマリンク">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Part of <a class="reference internal" href="parallel.html#dph"><span class="std std-ref">Data Parallel Haskell (DPH)</span></a>.</p>
<p>Enable the <em>vectorisation</em> optimisation
transformation. This optimisation transforms the nested data
parallelism code of programs using DPH into flat data parallelism.
Flat data parallel programs should have better load balancing,
enable SIMD parallelism and friendlier cache behaviour.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>ナビゲーション</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="総合索引"
             >索引</a></li>
        <li class="right" >
          <a href="using-concurrent.html" title="7.4. Using Concurrent Haskell"
             >次へ</a> |</li>
        <li class="right" >
          <a href="using-warnings.html" title="7.2. 警告と整合性検査"
             >前へ</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.2.2 User&#39;s Guide</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="usage.html" >7. GHCを使う</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2015, GHC Team.
      このドキュメントは <a href="http://sphinx-doc.org/">Sphinx</a> 1.5.6 で生成しました。
    </div>
  </body>
</html>