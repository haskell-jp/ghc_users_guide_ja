
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. GHCiを使う &mdash; Glasgow Haskell Compiler &lt;release&gt; Users Guide</title>
    
    <link rel="stylesheet" href="_static/ghc-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Glasgow Haskell Compiler &lt;release&gt; Users Guide" href="index.html" />
    <link rel="next" title="6. Using runghc" href="runghc.html" />
    <link rel="prev" title="4. バージョン 8.0.2 のリリースノート" href="8.0.2-notes.html" /> 
  </head>
  <body role="document">
<div class="logo">
    <h1><a href="index.html">Glasgow Haskell Compiler Users Guide</a></h1>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="runghc.html" title="6. Using runghc"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="8.0.2-notes.html" title="4. バージョン 8.0.2 のリリースノート"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.0.2 Users Guide</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. GHCiを使う</a><ul>
<li><a class="reference internal" href="#ghci-introduction">5.1. GHCi入門</a></li>
<li><a class="reference internal" href="#loading-source-files">5.2. ソースファイルをロードする</a><ul>
<li><a class="reference internal" href="#ghci-modules-filenames">5.2.1. モジュールとファイル名</a></li>
<li><a class="reference internal" href="#id12">5.2.2. ソースコードの変更と再コンパイル</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghci-compiled">5.3. コンパイル済みコードをロードする</a></li>
<li><a class="reference internal" href="#interactive-evaluation">5.4. プロンプトで対話的に評価する</a><ul>
<li><a class="reference internal" href="#i-o">5.4.1. プロンプトでのI/Oアクション</a></li>
<li><a class="reference internal" href="#do">5.4.2. プロンプトで <code class="docutils literal"><span class="pre">do</span></code> 記法を使う</a></li>
<li><a class="reference internal" href="#ghci-multiline">5.4.3. 複数行入力</a></li>
<li><a class="reference internal" href="#ghci-decls">5.4.4. 型，クラス，その他の宣言</a></li>
<li><a class="reference internal" href="#ghci-scope">5.4.5. プロンプトのスコープにあるもの</a><ul>
<li><a class="reference internal" href="#load">5.4.5.1. スコープ内容に対する <code class="docutils literal"><span class="pre">:load</span></code> の影響</a></li>
<li><a class="reference internal" href="#import">5.4.5.2. <code class="docutils literal"><span class="pre">import</span></code> によるスコープ制御</a></li>
<li><a class="reference internal" href="#module">5.4.5.3. <code class="docutils literal"><span class="pre">:module</span></code> コマンドによるスコープ制御</a></li>
<li><a class="reference internal" href="#ghci-import-qualified">5.4.5.4. 修飾名</a></li>
<li><a class="reference internal" href="#module-load">5.4.5.5. <code class="docutils literal"><span class="pre">:module</span></code> と <code class="docutils literal"><span class="pre">:load</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#main-run">5.4.6. <code class="docutils literal"><span class="pre">:main</span></code> コマンドと <code class="docutils literal"><span class="pre">:run</span></code> コマンド</a></li>
<li><a class="reference internal" href="#it">5.4.7. <code class="docutils literal"><span class="pre">it</span></code> 変数</a></li>
<li><a class="reference internal" href="#extended-default-rules">5.4.8. GHCi でのデフォルト型設定</a></li>
<li><a class="reference internal" href="#ghci-interactive-print">5.4.9. 独自の対話表示関数を使う</a></li>
<li><a class="reference internal" href="#ghci-stack-traces">5.4.10. GHCiのスタックトレース</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghci-debugger">5.5. GHCiのデバッガ</a><ul>
<li><a class="reference internal" href="#breakpoints">5.5.1. ブレイクポイントと変数内容の表示</a><ul>
<li><a class="reference internal" href="#setting-breakpoints">5.5.1.1. ブレイクポイントの設定</a></li>
<li><a class="reference internal" href="#id27">5.5.1.2. ブレイクポイントの一覧と削除</a></li>
</ul>
</li>
<li><a class="reference internal" href="#single-stepping">5.5.2. ステップ実行</a></li>
<li><a class="reference internal" href="#nested-breakpoints">5.5.3. ブレイクポイントのネスト</a></li>
<li><a class="reference internal" href="#result">5.5.4. <code class="docutils literal"><span class="pre">_result</span></code> 変数</a></li>
<li><a class="reference internal" href="#tracing">5.5.5. トレースとヒストリ</a></li>
<li><a class="reference internal" href="#ghci-debugger-exceptions">5.5.6. 例外のデバッグ</a></li>
<li><a class="reference internal" href="#id32">5.5.7. 例：関数の調査</a></li>
<li><a class="reference internal" href="#id33">5.5.8. 制限</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghci-invocation">5.6. GHCi の起動</a><ul>
<li><a class="reference internal" href="#id35">5.6.1. パッケージ</a></li>
<li><a class="reference internal" href="#id36">5.6.2. 追加のライブラリ</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghci-commands">5.7. GHCi のコマンド群</a></li>
<li><a class="reference internal" href="#set-seti">5.8. <code class="docutils literal"><span class="pre">:set</span></code> コマンドと <code class="docutils literal"><span class="pre">:seti</span></code> コマンド</a><ul>
<li><a class="reference internal" href="#id38">5.8.1. GHCi のオプション</a></li>
<li><a class="reference internal" href="#ghcighc">5.8.2. GHCiからGHCのコマンドラインオプションを設定する</a></li>
<li><a class="reference internal" href="#ghci-interactive-options">5.8.3. 対話式評価についてのみのオプションを設定する</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghci-haskeline">5.9. <code class="docutils literal"><span class="pre">.ghci</span></code> ファイルと <code class="docutils literal"><span class="pre">.haskeline</span></code> ファイル</a><ul>
<li><a class="reference internal" href="#dot-ghci-files">5.9.1. <code class="docutils literal"><span class="pre">.ghci</span></code> ファイル</a></li>
<li><a class="reference internal" href="#haskeline">5.9.2. <code class="docutils literal"><span class="pre">.haskeline</span></code> ファイル</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghci-obj">5.10. GHCi内でオブジェクトコードにコンパイルする</a></li>
<li><a class="reference internal" href="#external-interpreter">5.11. インタプリタを別プロセスで走らせる</a></li>
<li><a class="reference internal" href="#faq">5.12. FAQ と注意事項</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="8.0.2-notes.html"
                        title="previous chapter">4. バージョン 8.0.2 のリリースノート</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="runghc.html"
                        title="next chapter">6. Using runghc</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ghci.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ghci">
<span id="id1"></span><h1>5. GHCiを使う<a class="headerlink" href="#ghci" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p>GHCi <a class="footnote-reference" href="#id3" id="id2">[1]</a> はGHCの対話環境であり，Haskellの式を対話方式で評価したり
プログラムを解釈実行したりできます．
<a class="reference external" href="http://www.haskell.org/hugs/">Hugs</a> の経験があるなら，
すぐにでもGHCiに慣れることでしょう．
しかしながら， GHCiはコンパイル済みのコードを対話的にロードすることができます．
また，GHCが提供する言語拡張のすべて[2]_ をサポートしています．
GHCi は対話方式のデバッガも備えています(<a class="reference internal" href="#ghci-debugger"><span>GHCiのデバッガ</span></a> 参照)．</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>&#8220;i&#8221;は“Interactive”の i です．</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>ただし今のところ <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code> は除きます．</td></tr>
</tbody>
</table>
<div class="section" id="ghci-introduction">
<span id="id5"></span><h2>5.1. GHCi入門<a class="headerlink" href="#ghci-introduction" title="Permalink to this headline">¶</a></h2>
<p>GHCiセッションの例を見ていくことから始めましょう．
GHCiは <code class="docutils literal"><span class="pre">ghci</span></code> コマンドで起動します．</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghci
GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help
Prelude&gt;
</pre></div>
</div>
<p>GHCiがプレリュードと標準ライブラリをロードするのにすこしかかるかもしれませんが，
それが完了するとプロンプトが現れます．
バナーにあるとおり，<a class="reference internal" href="#ghci-cmd-:?"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:?</span></code></a> をタイプすれば，利用可能なコマンド一覧と
それぞれの短い説明が表示されます．
これ以降ほとんどのコマンドを説明します．
すべてのコマンドの完全な説明は <a class="reference internal" href="#ghci-commands"><span>GHCi のコマンド群</span></a> にあります．</p>
<p>プロンプトにはHaskellの式をタイプします．</p>
<div class="highlight-none" id="index-1"><div class="highlight"><pre>Prelude&gt; 1+2
3
Prelude&gt; let x = 42
Preldue&gt; x / 9
4.666666666666667
Prelude&gt;
</pre></div>
</div>
<p>GHCiは行全体を1つの式だと解釈し，これを評価します．
式は複数行にまたがることはできません．
エンターキーを押したとたん，GHCiはそこまでにタイプされたものを評価しようとします．</p>
<p>Haskellでは <code class="docutils literal"><span class="pre">let</span></code> 式は <code class="docutils literal"><span class="pre">in</span></code> をともないます．
しかし，GHCiでは，式は <code class="docutils literal"><span class="pre">IO</span></code> モナドの中でも解釈されますので，上の例は
<code class="docutils literal"><span class="pre">in</span></code> を伴わない <code class="docutils literal"><span class="pre">let</span></code> 束縛文であることは，行が表示されないことで示されています．</p>
</div>
<div class="section" id="loading-source-files">
<span id="id6"></span><h2>5.2. ソースファイルをロードする<a class="headerlink" href="#loading-source-files" title="Permalink to this headline">¶</a></h2>
<p>次のようなHaskellのソースコードが <code class="docutils literal"><span class="pre">Main.hs</span></code> というファイルに書かれているとしましょう．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">fac</span> <span class="mi">20</span><span class="p">)</span>

<span class="nf">fac</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fac</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Main.hs</span></code> は好きな場所に置けますが，GHCiを起動したファイルがあるカレントディレクトリ
<a class="footnote-reference" href="#id8" id="id7">[3]</a> 以外の場所に置いたときには，GHCiでディレクトリを正しく変更する必要があります．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :cd dir
</pre></div>
</div>
<p>ここで ⟨dir⟩ は <code class="docutils literal"><span class="pre">Main.hs</span></code> を保存したディレクトリ(あるいはフォルダ）です．</p>
<p>HaskellのソースファイルをGHCiにロードするには <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> コマンドを使います．</p>
<div class="highlight-none" id="index-2"><div class="highlight"><pre>Prelude&gt; :load Main
Compiling Main             ( Main.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt;
</pre></div>
</div>
<p>GHCiは <code class="docutils literal"><span class="pre">Main</span></code> モジュールをロードし，プロンプトが <code class="docutils literal"><span class="pre">*Main&gt;</span></code> に変りました．
このプロンプトは，ここにユーザが入力する式を評価するときの文脈が，たったいまロードした
<code class="docutils literal"><span class="pre">Main</span></code> モジュールであることを示しています
(<code class="docutils literal"><span class="pre">*</span></code> の意味については <a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a> で説明します)．
これで <code class="docutils literal"><span class="pre">Main.hs</span></code> で定義した関数を含む式が評価できるようになりました．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; fac 17
355687428096000
</pre></div>
</div>
<p>複数のモジュールからなるプログラムをロードするのも同様に簡単です．
「最上位の」モジュールの名前を <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> コマンドに指定すればいいだけです
(ヒント: <code class="xref std std-ghci-cmd docutils literal"><span class="pre">load</span></code> は <code class="docutils literal"><span class="pre">:l</span></code> に短縮できます)．
最上位のモジュールはふつうは <code class="docutils literal"><span class="pre">Main</span></code> ですが，必ずしもそうである必要はありません．
GHCiは最上位のモジュールから直接・間接に必要とされているモジュールを見つけ，
それらを依存関係の順にロードします．</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td>コマンドラインから GHCi を起動した場合は GHCi のカレントディレクトリは
シェルから起動したときのカレントディレクトリと同じです．
Windowsの「スタート」メニューから GHCi を起動した場合は，
カレントディレクトリはおそく <code class="docutils literal"><span class="pre">C:\Documents</span> <span class="pre">and</span> <span class="pre">Settings\user</span> <span class="pre">name</span></code> あたりでしょう．</td></tr>
</tbody>
</table>
<div class="section" id="ghci-modules-filenames">
<span id="id9"></span><h3>5.2.1. モジュールとファイル名<a class="headerlink" href="#ghci-modules-filenames" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-3"></span><p>問: GHCi はモジュール ⟨M⟩ がどのファイルにあるかをどうやって知るのですか．
答: <code class="docutils literal"><span class="pre">M.hs</span></code> あるいは <code class="docutils literal"><span class="pre">M.lhs</span></code> というファイルを探します．
したがって，大部分のモジュールでは，モジュール名とファイル名は一致している必要があります．
一致しなかった場合，GHCiはモジュールを見つけ出すことができません．</p>
<p>この規則には一つの例外があります．
<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> を使ってプログラムをロードするとき，
あるいは <code class="docutils literal"><span class="pre">ghci</span></code> を起動するときには，モジュール名ではなくファイル名を指定することができます．
その名前のファイルがあれば，それをロードします．
このときそのファイルにはどのような名前のモジュールを含んでいてもかまいません．
これは，複数の <code class="docutils literal"><span class="pre">Main</span></code> モジュールが1つのディレクトリにある場合，
全てを <code class="docutils literal"><span class="pre">Main.hs</span></code> と呼ぶことはできませんので，特に便利です．</p>
<p>ソースファイルを探すときの探索パスは，次に示すように，
GHCiを起動するコマンドラインで <a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a> オプションで指定できます．</p>
<div class="highlight-none"><div class="highlight"><pre>ghci -idir1:...:dirn
</pre></div>
</div>
<p>あるいは，GHCiの中で <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> コマンドで指定できます
(<a class="reference internal" href="#ghci-cmd-line-options"><span>GHCiからGHCのコマンドラインオプションを設定する</span></a> 参照) <a class="footnote-reference" href="#id11" id="id10">[4]</a></p>
<p>GHCiは，このように依存関係を追ってロードすべきモジュールを見つけようとするので，
モジュールごとに，1つのソースファイルがなければなりません．
この規則の唯一の例外はパッケージ由来のモジュールで，それには <code class="docutils literal"><span class="pre">Prelude</span></code> のほか
<code class="docutils literal"><span class="pre">IO</span></code> や <code class="docutils literal"><span class="pre">Complex</span></code> といった標準ライブラリも含まれます．
モジュールをロードしようとしたとき，GHCiがソースファイルを見つけられなければ，
たとえ，そのモジュールのオブジェクトファイルやインターフェイスファイルがあったとしても，
エラーメッセージが表示されます．</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[4]</a></td><td>GHCiや <a class="reference internal" href="using.html#ghc-flag---make"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--make</span></code></a> モードでは <a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a> オプションは，
<em>ソースファイル</em> の探索パスを指定するのに対し，標準の一括コンパイルモードでは
<a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a> オプションはインターフェイスファイルの探索パスを指定することに注意してください．
詳しくは <a class="reference internal" href="separate_compilation.html#search-path"><span>The search path</span></a> を参照してください．</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id12">
<h3>5.2.2. ソースコードの変更と再コンパイル<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p id="index-4">ソースコードに変更を加えて，GHCiに再コンパイルさせたいときは <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a>
コマンドを使います．
プログラムは必要に応じて再コンパイルされます．
このとき，GHCiは依存関係の変化がないモジュールを実際に再コンパイルするのを避けようと最善をつくします．
これは一括コンパイル時に再コンパイルを避ける機構と同じです
(<a class="reference internal" href="separate_compilation.html#recomp"><span>The recompilation checker</span></a> 参照)．</p>
</div>
</div>
<div class="section" id="ghci-compiled">
<span id="id13"></span><h2>5.3. コンパイル済みコードをロードする<a class="headerlink" href="#ghci-compiled" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-5"></span><p>HaskellのソースモジュールをGHCiにロードすると，通常はバイトコードに変換され，インタプリタで実行されます．
しかし，GHCiでは解釈実行されるコードはコンパイル済みコードと一緒に実行することもできます．
実際，GHCiは起動すると通常は <code class="docutils literal"><span class="pre">base</span></code> パッケージのコンパイル済みのものをロードします．
その中には <code class="docutils literal"><span class="pre">Prelude</span></code> モジュールが含まれています．</p>
<p>なぜコンパイル済みのコードを使う必要があるのでしょうか．
コンパイル済みコードは解釈実行されるコードに比べて大体10倍速いですが，生成するのに2倍の時間がかります
(最適化が有効ならもっと長くなるでしょう)．
そのため、プログラムのあまり変更されない部分をコンパイルしておき，
活発に開発されている部分にはインタプリタを使ことにすればいいわけです．</p>
<p><a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> でソースモジュールをロードするとき，GHCiは通常対応する
コンパイル済みのオブジェクトファイルを探します．
可能ならソースコードの解釈実行よりも優先してそれを使います．
たとえば，A，B，C，Dという4つのモジュールからなるプログラムがあるとしましょう．
モジュールBとCはどちらもDのみをインポートしていて，AはBとCをインポートしているとしましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>  A
 / \
B   C
 \ /
  D
</pre></div>
</div>
<p>以下のように <code class="docutils literal"><span class="pre">D</span></code> をコンパイルしてから，プログラム全体をロードすることができます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :! ghc -c -dynamic D.hs
Prelude&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D (D.o).
*Main&gt;
</pre></div>
</div>
<p>コンパイラのメッセージ中に <code class="docutils literal"><span class="pre">D</span></code> についての行がありません．
これは，<code class="docutils literal"><span class="pre">D</span></code> のソースファイルとその依存関係が，最後にコンパイルされたときから変更されていないので，
<code class="docutils literal"><span class="pre">D</span></code> をコンパイルする必要ないからです．</p>
<p><a class="reference internal" href="phases.html#ghc-flag--dynamic"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dynamic</span></code></a> フラグはGHCに渡すものです．
これによって，GHCiはダイナミックリンクオブジェクトコードを使うようになります
(もちろんそれをサポートしているプラットフォームでの話です)．
したがって，GHCiでコンパイル済みのコードを利用するためには，そのコードは
ダイナミックリンク可能なようにコンパイルされていなければなりません．</p>
<p><a class="reference internal" href="#ghci-cmd-:show modules"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">modules</span></code></a> を使えば，いつでも，その時点でGHCiにロードされている
モジュールの一覧を表示できます．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :show modules
D                ( D.hs, D.o )
C                ( C.hs, interpreted )
B                ( B.hs, interpreted )
A                ( A.hs, interpreted )
*Main&gt;
</pre></div>
</div>
<p>ここで <code class="docutils literal"><span class="pre">D</span></code> を変更する(あるいは変更したふりをする: <code class="docutils literal"><span class="pre">touch</span></code> というUnixのコマンドを
使うのが簡単)と，コンパイラはオブジェクトファイルを使えなくなります．
その理由は，オブジェクトファイルがすでに古くなっているに違いないからです．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :! touch D.hs
*Main&gt; :reload
Compiling D                ( D.hs, interpreted )
Ok, modules loaded: A, B, C, D.
*Main&gt;
</pre></div>
</div>
<p>モジュール <code class="docutils literal"><span class="pre">D</span></code> がコンパイルされました．
しかし，この例では実際にはソースは変更されていないので，インターフェイスは同じままで，
再コンパイル検査器が <code class="docutils literal"><span class="pre">A</span></code> ， <code class="docutils literal"><span class="pre">B</span></code> ， <code class="docutils literal"><span class="pre">C</span></code> は再コンパイルする必要なしと判断したことに注意してください．</p>
<p>では，別のモジュールを1つコンパイルしてみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :! ghc -c C.hs
*Main&gt; :load A
Compiling D                ( D.hs, interpreted )
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">C</span></code> のコンパイル済みのバージョンが使われていません．
何が起きたのでしょうか．
GHCi ではコンパイル済みのモジュールは別のコンパイル済みのモジュールにしか依存できません．
この場合は <code class="docutils literal"><span class="pre">C</span></code> が <code class="docutils literal"><span class="pre">D</span></code> に依存していますが <code class="docutils literal"><span class="pre">D</span></code> にはオブジェクトファイルがないので
GHCiは <code class="docutils literal"><span class="pre">C</span></code> のオブジェクトファイルを利用しなかったのです．
では <code class="docutils literal"><span class="pre">D</span></code> もコンパイルしてみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :! ghc -c D.hs
*Main&gt; :reload
Ok, modules loaded: A, B, C, D.
</pre></div>
</div>
<p>何も起こりません．
もう1つ賢くなりました．
新しくコンパイルされたモジュールは <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> では拾えません．
<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> を使う必要があります．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C (C.o), D (D.o).
</pre></div>
</div>
<p>このようなオブジェクトファイルの自動ロードは混乱の原因になることがあります．
モジュールのエクスポートされていないトップレベルの定義をプロンプトの式で使えるのは，
そのモジュールが解釈実行されているときだけだからです
(<a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a> 参照)．
このため，GHCiにインタプリタを使ってモジュールのロードを強制したいことがあるかもしれません．
そうするには <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> を使うときにモジュール名またはファイル名の前に*を置きます．
たとえば，以下のようにします．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :load *A
Compiling A                ( A.hs, interpreted )
*A&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">*</span></code> を使うと，GHCiはコンパイル済みオブジェクトコードがあっても無視し，モジュールを解釈実行します．
既にモジュールをいくつかオブジェクトコードとしてロードしていて，そのうち1つを解釈実行したいときには，
全部を再ロードせず <code class="docutils literal"><span class="pre">:add</span> <span class="pre">*M</span></code> を使えば， <code class="docutils literal"><span class="pre">M</span></code> だけを解釈実行することを指定できます．
(これによって別のモジュールも解釈実行されるかもしれないことに注意してください．
これは，コンパイル済みモジュールは解釈実行モジュールに依存できないためです．)</p>
<p>いつでも，すべてコンパイル済みのオブジェクトコードにしたければ，
インタプリタを使ってはいけません．
<a class="reference internal" href="phases.html#ghc-flag--fobject-code"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fobject-code</span></code></a> オプションを使ってください(<a class="reference internal" href="#ghci-obj"><span>GHCi内でオブジェクトコードにコンパイルする</span></a> 参照)．</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">GHCi はコンパイル済みの版が最新であることが確かな場合にしか，
コンパイル済みオブジェクトファイルを使わないので，
大きいプロジェクトでは，ときどき <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--make</span></code> を実行してプロジェクト全体をコンパイルし
(たとえば，昼食を食べに行く前にね)，インタプリタを使って作業を続けるというのが良い方法です．
コードを変更したときは，そのモジュールは解釈実行されますが，プロジェクト中の他の部分は
変わらずコンパイル済みのものが使われます．</p>
</div>
</div>
<div class="section" id="interactive-evaluation">
<span id="id14"></span><h2>5.4. プロンプトで対話的に評価する<a class="headerlink" href="#interactive-evaluation" title="Permalink to this headline">¶</a></h2>
<p>プロンプトに式を入力すると，GHCi はただちに評価して結果を表示します．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; reverse &quot;hello&quot;
&quot;olleh&quot;
Prelude&gt; 5+5
10
</pre></div>
</div>
<div class="section" id="i-o">
<span id="actions-at-prompt"></span><h3>5.4.1. プロンプトでのI/Oアクション<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h3>
<p>GHCi がプロンプトで行うのは単なる式の評価だけではありません．
ある型 <code class="docutils literal"><span class="pre">a</span></code> に関して <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> 型の式を入力すると，GHCiはそれをIOコンピュテーションとして
<em>実行</em> します．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; &quot;hello&quot;
&quot;hello&quot;
Prelude&gt; putStrLn &quot;hello&quot;
hello
</pre></div>
</div>
<p>式の型がより一般的なものであっても <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> に <em>具体化</em> することができる限り動作します．
それ例が以下です．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; return True
True
</pre></div>
</div>
<p>さらに，GHCiは以下の条件を満す場合(かつその限りにおいて)，I/Oアクションの結果を表示します．</p>
<ul class="simple">
<li>結果の型が <code class="docutils literal"><span class="pre">Show</span></code> のインスタンスの場合．</li>
<li>結果の型が <code class="docutils literal"><span class="pre">()</span></code> ではない場合．</li>
</ul>
<p>以下はその例です．ただし， <code class="docutils literal"><span class="pre">putStrLn</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code> です．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; putStrLn &quot;hello&quot;
hello
Prelude&gt; do { putStrLn &quot;hello&quot;; return &quot;yes&quot; }
hello
&quot;yes&quot;
</pre></div>
</div>
</div>
<div class="section" id="do">
<span id="ghci-stmts"></span><h3>5.4.2. プロンプトで <code class="docutils literal"><span class="pre">do</span></code> 記法を使う<a class="headerlink" href="#do" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-6"></span><p>実際には，GHCiはプロンプトで受け付けているのは単なる式ではなく文です．
そのため，値や関数を名前に束縛して，後で式や文の中で使うことができます．</p>
<p>The syntax of a statement accepted at the GHCi prompt is exactly the
GHCiがプロンプトで受け付ける文の構文は，Haskellのdo式における文の構文と全く同じです．
ただし，こちらにはモナドの多重定義はありません．
プロンプトに入力される文はIOモナドの中になければなりません．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; x &lt;- return 42
Prelude&gt; print x
42
Prelude&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">return</span> <span class="pre">42</span></code> という文は「<code class="docutils literal"><span class="pre">return</span> <span class="pre">42</span></code> を <code class="docutils literal"><span class="pre">IO</span></code> モナド内で実行し，
その結果で <code class="docutils literal"><span class="pre">x</span></code> を束縛する」という意味です．
以降 <code class="docutils literal"><span class="pre">x</span></code> は文の中で使用できます．
たとえば，上でしたように値を印字できます．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fprint-bind-result">
<code class="descname">-fprint-bind-result</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fprint-bind-result" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghc-flag--fprint-bind-result"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fprint-bind-result</span></code></a> が設定されていれば，GHCiは次の場合(かつ，その場合に限り)
文の結果を表示します．</p>
<ul class="simple">
<li>当該の文が束縛ではないか，1つの変数だけを束縛するモナド束縛(<code class="docutils literal"><span class="pre">p</span> <span class="pre">&lt;-</span> <span class="pre">e</span></code>)の場合．</li>
<li>変数の型が多相的でなく， <code class="docutils literal"><span class="pre">()</span></code> でもなく， <code class="docutils literal"><span class="pre">Show</span></code> のインスタンスである場合．</li>
</ul>
</dd></dl>

<p>もちろん，<code class="docutils literal"><span class="pre">let</span></code> 文を使って，ふつうの非IO式で束縛することもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; let x = 42
Prelude&gt; x
42
Prelude&gt;
</pre></div>
</div>
<p>この2種類の束縛のもうひとつ重要な違いは，
モナド束縛(<code class="docutils literal"><span class="pre">p</span> <span class="pre">&lt;-</span> <span class="pre">e</span></code>)は <em>正格</em> (<code class="docutils literal"><span class="pre">e</span></code> を評価)ですが，
<code class="docutils literal"><span class="pre">let</span></code> 形式では式はすぐには評価されないということです．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; let x = error &quot;help!&quot;
Prelude&gt; print x
*** Exception: help!
Prelude&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">let</span></code> 束縛では，モナド束縛とは違い，束縛値が自動的に表示されることはありません．</p>
<p>プロンプトで関数を定義することもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; add a b = a + b
Prelude&gt; add 1 2
3
Prelude&gt;
</pre></div>
</div>
<p>しかし，複数の節からなる関数を定義したり，相互再帰的な関数を定義したりしようとすると，
このやりかたはすぐ面倒になります．
レイアウト規則が使えず，定義全体を明示的なブレースとセミコロンを使って一行で与えないといけないからです．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; f op n [] = n ; f op n (h:t) = h `op` f op n t
Prelude&gt; f (+) 0 [1..3]
6
Prelude&gt;
</pre></div>
</div>
<p>この問題を軽減するために，GHCi コマンドは複数行に渡って書くことができるようになっています．
<code class="docutils literal"><span class="pre">:{</span></code> および <code class="docutils literal"><span class="pre">:}</span></code> で，それぞれ1行を使います．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :{
Prelude| g op n [] = n
Prelude| g op n (h:t) = h `op` g op n t
Prelude| :}
Prelude&gt; g (*) 1 [1..3]
6
</pre></div>
</div>
<p>Such multiline commands can be used with any GHCi command, and note that
このような複数行コマンドは任意のGHCiコマンドについて用いることができます．
このときレイアウト規則が有効であることに注意してください．
複数行コマンドの主な目的は，モジュールのロードの代替にすることではなく，
.ghciファイル(<a class="reference internal" href="#ghci-dot-files"><span>.ghci ファイルと .haskeline ファイル</span></a> 参照)での定義を読みやすく保守しやするするためです．</p>
<p>Any exceptions raised during the evaluation or execution of the
文を評価または実行している間に発生した例外は，GHCiのコマンド行インターフェイスによって捕捉され，
表示されます(例外について詳しくはライブラリドキュメント <code class="docutils literal"><span class="pre">Control.Exception</span></code>
モジュールのライブラリ <a class="reference external" href="../libraries/base-4.9.1.0/Control-Exception.html">文書</a> を参照してください)．</p>
<p>新しい束縛は，同じ名前の既存の束縛をシャドウし(覆い隠し)ます．
これは現在のモジュールの文脈でスコープにある実体もシャドウします．</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">プロンプトで導入さた束縛あ一時的なもので，
次に <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> あるいは <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> コマンドが実行されるまでの間のことです．
これらのコマンドが実行されると，一時的な束縛は消えてしまいます．
ただし，<a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a>: で文脈を変更しても一時的は束縛は新しい場所へ移動し，
消えることはありません．</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p><a class="reference internal" href="#ghci-cmd-:show bindings"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">bindings</span></code></a> コマンドを使えば，その時点でスコープにある束縛の一覧がえられます．</p>
<div class="last highlight-none"><div class="highlight"><pre>Prelude&gt; :show bindings
x :: Int
Prelude&gt;
</pre></div>
</div>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p><code class="docutils literal"><span class="pre">+t</span></code> オプションを指定すると，GHCi は文が束縛したそれぞれの変数の型を表示するようになります．
以下はその例です．</p>
<div class="last highlight-none"><div class="highlight"><pre>Prelude&gt; :set +t
Prelude&gt; let (x:xs) = [1..]
x :: Integer
xs :: [Integer]
</pre></div>
</div>
<span class="target" id="index-7"></span></div>
</div>
<div class="section" id="ghci-multiline">
<span id="id15"></span><h3>5.4.3. 複数行入力<a class="headerlink" href="#ghci-multiline" title="Permalink to this headline">¶</a></h3>
<p>上で説明しあた <code class="docutils literal"><span class="pre">:{</span> <span class="pre">...</span> <span class="pre">:}</span></code> 構文による複数行入力のほかに，GHCiでは <code class="docutils literal"><span class="pre">:set</span> <span class="pre">+m</span></code>
とすると有効になる複数行モードがあります．
このモードでは，現在の文が入力途中であることをGHCiが自動的に検出します．
その先の入力ができるようになります．
複数行入力は空行で終端します．
実際の入力例は以下のとおりです．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :set +m
Prelude&gt; let x = 42
Prelude|
</pre></div>
</div>
<p>この <code class="docutils literal"><span class="pre">let</span></code> 文にはさらに束縛を追加できます．
GHCiのプロンプトが変り，直前の行の続きを入力できることが判ります．
レイアウト規則は有効ですので，この <code class="docutils literal"><span class="pre">let</span></code> にさらに束縛を加えるには
束縛の先頭位置をそろえる必要があることに注意してください．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :set +m
Prelude&gt; let x = 42
Prelude|     y = 3
Prelude|
Prelude&gt;
</pre></div>
</div>
<p>レイアウトではなく明示的にブレースをセミコロンを使うこともできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; do {
Prelude| putStrLn &quot;hello&quot;
Prelude| ;putStrLn &quot;world&quot;
Prelude| }
hello
world
Prelude&gt;
</pre></div>
</div>
<p>閉じブレースの後は，現在の文がおわっていることが判るので，空行は必要ありません．</p>
<p>複数行モードはモナドの <code class="docutils literal"><span class="pre">do</span></code> 文を入力するのに便利です．</p>
<div class="highlight-none"><div class="highlight"><pre>Control.Monad.State&gt; flip evalStateT 0 $ do
Control.Monad.State| i &lt;- get
Control.Monad.State| lift $ do
Control.Monad.State|   putStrLn &quot;Hello World!&quot;
Control.Monad.State|   print i
Control.Monad.State|
&quot;Hello World!&quot;
0
Control.Monad.State&gt;
</pre></div>
</div>
<p>複数行モードで入力中に中断してトップレベルのプロンプトに戻ることもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; do
Prelude| putStrLn &quot;Hello, World!&quot;
Prelude| ^C
Prelude&gt;
</pre></div>
</div>
</div>
<div class="section" id="ghci-decls">
<span id="id16"></span><h3>5.4.4. 型，クラス，その他の宣言<a class="headerlink" href="#ghci-decls" title="Permalink to this headline">¶</a></h3>
<p>GHCi のプロンプトには，Haskellの任意のトップレベル宣言を入力できます．
これには <code class="docutils literal"><span class="pre">data</span></code> ， <code class="docutils literal"><span class="pre">type</span></code> ， <code class="docutils literal"><span class="pre">newtype</span></code> ， <code class="docutils literal"><span class="pre">class</span></code> ， <code class="docutils literal"><span class="pre">instance</span></code> ，
<code class="docutils literal"><span class="pre">deriving</span></code> ， <code class="docutils literal"><span class="pre">foreign</span></code> 宣言が含まれています．
例は以下のとおり．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; data T = A | B | C deriving (Eq, Ord, Show, Enum)
Prelude&gt; [A ..]
[A,B,C]
Prelude&gt; :i T
data T = A | B | C      -- Defined at &lt;interactive&gt;:2:6
instance Enum T -- Defined at &lt;interactive&gt;:2:45
instance Eq T -- Defined at &lt;interactive&gt;:2:30
instance Ord T -- Defined at &lt;interactive&gt;:2:34
instance Show T -- Defined at &lt;interactive&gt;:2:39
</pre></div>
</div>
<p>As with ordinary variable bindings, later definitions shadow earlier
通常の変数束縛と同様に，後で定義されたものは古い定義をシャドウしてしまうので，
定義を再入力すれば，問題を修正したり拡張したりできます．
ただし，落とし穴があります．
新しい型宣言が古い型宣言をシャドウするとき，古い型の定義を参照している別の宣言があるかもしれません．
この古い型はまだ存在し，この別の宣言はまだ古い型を参照しているということを覚えておいてください．
古い型と新しい型は同じ名前ですが，GHCiはこれらを区別するということです．
たとえば，</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; data T = A | B
Prelude&gt; let f A = True; f B = False
Prelude&gt; data T = A | B | C
Prelude&gt; f A

&lt;interactive&gt;:4:3: error:
    • Couldn&#39;t match expected type ‘Ghci1.T’
                  with actual type ‘T’
      NB: ‘T’ is defined at &lt;interactive&gt;:3:1-18
          ‘Ghci1.T’ is defined at &lt;interactive&gt;:1:1-14
    • In the first argument of ‘f’, namely ‘A’
      In the expression: f A
      In an equation for ‘it’: it = f A
Prelude&gt;
</pre></div>
</div>
<p>シャドウされた古いほうの <code class="docutils literal"><span class="pre">T</span></code> は <code class="docutils literal"><span class="pre">Ghci1.T</span></code> と表示されています．
これは，単に <code class="docutils literal"><span class="pre">T</span></code> と表示されている新しい方と区別するためです．</p>
<p>クラスや型族のインスタンス宣言は，単に利用可能なインスタンスの一覧に追加されるだけです．
ただし例外が一つあります．
クラスや型族インスタンスは再定義したいこともあるので，
頭部あるいは左辺が同一であるインスタンスはそれぞれ新しいもので <em>置き換える</em> ことになります
(<a class="reference internal" href="glasgow_exts.html#type-families"><span>Type families</span></a> 参照)．</p>
</div>
<div class="section" id="ghci-scope">
<span id="id17"></span><h3>5.4.5. プロンプトのスコープにあるもの<a class="headerlink" href="#ghci-scope" title="Permalink to this headline">¶</a></h3>
<p>プロンプトに式を入力するとき，どの識別子や型がスコープにあるのでしょうか．
以下のように，GHCiでは，式を評価する際の環境を構成する方法を正確に指定できます．</p>
<ul class="simple">
<li><a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> コマンド
(<a class="reference internal" href="#ghci-load-scope"><span>スコープ内容に対する :load の影響</span></a>)．</li>
<li><code class="docutils literal"><span class="pre">import</span></code> 宣言(<a class="reference internal" href="#ghci-import-decl"><span>import によるスコープ制御</span></a>)．</li>
<li><a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> コマンド(<a class="reference internal" href="#ghci-module-cmd"><span>:module コマンドによるスコープ制御</span></a>)．</li>
</ul>
<p><a class="reference internal" href="#ghci-cmd-:show imports"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">imports</span></code></a> を使えば，トップレベルのスコープにどのモジュールがあるか要約を表示できます．</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">GHCi ではスコープ内にある名前をタブ補完できます．
たとえば，GHCiを起動して <code class="docutils literal"><span class="pre">J&lt;tab&gt;</span></code> と入力すると <code class="docutils literal"><span class="pre">Just</span></code> と展開されます．</p>
</div>
<div class="section" id="load">
<span id="ghci-load-scope"></span><h4>5.4.5.1. スコープ内容に対する <code class="docutils literal"><span class="pre">:load</span></code> の影響<a class="headerlink" href="#load" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> コマンド
(<a class="reference internal" href="#loading-source-files"><span>ソースファイルをロードする</span></a> と <a class="reference internal" href="#ghci-compiled"><span>コンパイル済みコードをロードする</span></a> を参照) はトップレベルのスコープに影響します．
単純な場合から始めましょう．
GHCi を起動すると最初のプロンプトは以下のようになります．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt;
</pre></div>
</div>
<p>これは現在のスコープにあるものはすべて <code class="docutils literal"><span class="pre">Prelude</span></code> モジュール由来であるということを示しています．
ここで見える識別子は <code class="docutils literal"><span class="pre">import</span></code> 宣言のないHaskellのソースファイルから見える識別子と一致しています．</p>
<p>ここで，GHCiにファイルをロードすると，プロンプトは変化します．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :load Main.hs
Compiling Main             ( Main.hs, interpreted )
*Main&gt;
</pre></div>
</div>
<p>新しいプロンプトは <code class="docutils literal"><span class="pre">*Main&gt;</span> <span class="pre">``</span> <span class="pre">です．</span>
<span class="pre">これはプロンプトに入力した式の文脈が</span> <span class="pre">``Main</span></code> モジュールのトップレベルの文脈であることを示しています．
ロードした <code class="docutils literal"><span class="pre">Main</span></code> モジュールのトップレベルのスコープにあるものはすべて，
このプロンプトのスコープにあります
(<code class="docutils literal"><span class="pre">Main</span></code> が明示的に隠蔽していなければ <code class="docutils literal"><span class="pre">Prelude</span></code> も含まれます）．</p>
<p>プロンプトの <code class="docutils literal"><span class="pre">*module</span></code> という構文は，このプロンプトに入力した式のスコープは
⟨module⟩ のトップレベルのスコープであることを示しています．
<code class="docutils literal"><span class="pre">*</span></code> が付かない場合は当該モジュールからエクスポートされたものだけが見えるということです．</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">技術的理由により，GHCi が <code class="docutils literal"><span class="pre">*</span></code> 形式で表示できるのは解釈実行するモジュールに限られます．
コンパイル済みのモジュールおよびパッケージモジュールの場合は，それらから，エクスポート
されたものだけが現在のスコープに入ります．
GHCi が解釈実行版のモジュールをロードするようにするには，モジュールをロードするときに
<code class="docutils literal"><span class="pre">*</span></code> を付けます．たとえば <code class="docutils literal"><span class="pre">:load</span> <span class="pre">*M</span></code> のようにロードします．</p>
</div>
<p>一般に <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> コマンドが発行された後，直近にロードされた「ターゲット」モジュールに対する
インポートが自動的にスコープに追加されます．
このとき，可能なら <code class="docutils literal"><span class="pre">*</span></code> 形式が使われます．
たとえば <code class="docutils literal"><span class="pre">:load</span> <span class="pre">foo.hs</span> <span class="pre">bar.hs</span></code> と入力したとき <code class="docutils literal"><span class="pre">bar.hs</span></code> に <code class="docutils literal"><span class="pre">Bar</span></code> というモジュールがあるとすると，
<code class="docutils literal"><span class="pre">Bar</span></code> が解釈実行されているなら，スコープは <code class="docutils literal"><span class="pre">*Bar</span></code> に設定され， <code class="docutils literal"><span class="pre">Bar</span></code> がコンパイル済みなら，
スコープは <code class="docutils literal"><span class="pre">Prelude</span> <span class="pre">Bar</span></code> になります
(GHCiは <code class="docutils literal"><span class="pre">Prelude</span></code> が指定されておらず，しかも <code class="docutils literal"><span class="pre">*</span></code> 形式のモジュールが一つもなければ <code class="docutils literal"><span class="pre">Prelude</span></code>
を自動的に付け加えます)．
これらの自動に追加されたインポートについては <a class="reference internal" href="#ghci-cmd-:show imports"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">imports</span></code></a> で表示できます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :load hello.hs
[1 of 1] Compiling Main             ( hello.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; :show imports
:module +*Main -- added automatically
*Main&gt;
</pre></div>
</div>
<p>この自動的に追加されたインポートは，次に <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ，
<a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> あるいは <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> を発行すると別のものに置き換えられます．
通常のインポートと同様に <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> で削除することもできます．</p>
</div>
<div class="section" id="import">
<span id="ghci-import-decl"></span><h4>5.4.5.2. <code class="docutils literal"><span class="pre">import</span></code> によるスコープ制御<a class="headerlink" href="#import" title="Permalink to this headline">¶</a></h4>
<p>GHCi が扱えるのは単一のモジュールだけではありません．
複数のモジュールからのスコープを組み合わせることもできます．
このとき <code class="docutils literal"><span class="pre">*</span></code> 形式とそうでない形式を混ぜて使えます．
GHCi はこのようなモジュールのスコープのを全て組み合わせて，プロンプトのスコープします．</p>
<p>モジュールをスコープに加えるには，通常はHaskellの <code class="docutils literal"><span class="pre">import</span></code> 構文を使います．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; import System.IO
Prelude System.IO&gt; hPutStrLn stdout &quot;hello&quot;
hello
Prelude System.IO&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">hiding</span></code> 節および <code class="docutils literal"><span class="pre">as</span></code> 節を含む完全なHaskellのインポート構文がサポートされています．
プロンプトには現在インポートされているモジュールが表示されていますが，
<code class="docutils literal"><span class="pre">hiding</span></code> や <code class="docutils literal"><span class="pre">as</span></code> やその他の詳細は省略されています．
その部分を知りたければ <a class="reference internal" href="#ghci-cmd-:show imports"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">imports</span></code></a> を使って下さい．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; import System.IO
Prelude System.IO&gt; import Data.Map as Map
Prelude System.IO Map&gt; :show imports
import Prelude -- implicit
import System.IO
import Data.Map as Map
Prelude System.IO Map&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Prelude</span></code> のインポートについては implicit (暗黙) と表示されることに注意してください．
明示的に <code class="docutils literal"><span class="pre">Prelude</span></code> をインポートすれば，他のモジュールと同じように表示されます．</p>
<p>複数のモジュールがスコープにあるとき，特に複数の <code class="docutils literal"><span class="pre">*</span></code> 形式のモジュールがあるときは，
名前の衝突が起こりやすくなります．
Haskell では名前の衝突が起こったことが報告されるのは，実際に曖昧な名前が使われたときに限ると規定されています．
GHCi もプロンプトで入力される式についてはこれにならった振る舞いをします．</p>
</div>
<div class="section" id="module">
<span id="ghci-module-cmd"></span><h4>5.4.5.3. <code class="docutils literal"><span class="pre">:module</span></code> コマンドによるスコープ制御<a class="headerlink" href="#module" title="Permalink to this headline">¶</a></h4>
<p>スコープを操作するもう1つの方法は <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> コマンドです．
構文は以下のとおりになります．</p>
<div class="highlight-none"><div class="highlight"><pre>:module +|- *mod1 ... *modn
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">+</span></code> 形式の <code class="docutils literal"><span class="pre">module</span></code> コマンドでモジュールを現在のスコープに追加し，
<code class="docutils literal"><span class="pre">-</span></code> 形式でモジュールを現在のスコープから削除します．
<code class="docutils literal"><span class="pre">+</span></code> 形式でも <code class="docutils literal"><span class="pre">-</span></code> 形式でもない場合には，指定されたモジュール群が現在のスコープに置き換わります．
<code class="docutils literal"><span class="pre">+</span></code> 形式でも <code class="docutils literal"><span class="pre">-</span></code> 形式でもなく，<code class="docutils literal"><span class="pre">Prelude</span></code> も指定に含まれていない場合は，
自動的に，暗黙に <code class="docutils literal"><span class="pre">Prelude</span></code> をインポートします．</p>
<p><a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> コマンドでは通常の <code class="docutils literal"><span class="pre">import</span></code> 宣言ではできないことが2つ可能になります．</p>
<ul class="simple">
<li><a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> コマンドでは，モジュールを <code class="docutils literal"><span class="pre">*</span></code> で修飾できます．そうすると，単にモジュールがエクスポートしているものだけではなく，モジュールのトップレベルのスコープが完全にオープンになります．</li>
<li><code class="docutils literal"><span class="pre">:module</span> <span class="pre">-M</span></code> 構文を使うと，文脈からモジュールを削除できます．<code class="docutils literal"><span class="pre">import</span></code> 構文は累積的(Haskellのモジュール内と同様)なので，これがスコープからモジュールを取り除く唯一の方法です．</li>
</ul>
</div>
<div class="section" id="ghci-import-qualified">
<span id="id18"></span><h4>5.4.5.4. 修飾名<a class="headerlink" href="#ghci-import-qualified" title="Permalink to this headline">¶</a></h4>
<p>To make life slightly easier, the GHCi prompt also behaves as if there
手間をすこし省くことができるように，GHCiのプロンプトは全てのパッケージの全てのモジュールと，現在GHCiにロードされている全てのモジュールについて，暗黙の <code class="docutils literal"><span class="pre">import</span> <span class="pre">qualified</span></code> 宣言があるかのように振る舞います．
これは <code class="docutils literal"><span class="pre">-fno-implicit-import-qualified</span></code> というフラグで無効にできます．</p>
<span class="target" id="index-8"></span></div>
<div class="section" id="module-load">
<h4>5.4.5.5. <code class="docutils literal"><span class="pre">:module</span></code> と <code class="docutils literal"><span class="pre">:load</span></code><a class="headerlink" href="#module-load" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a>/<code class="docutils literal"><span class="pre">import</span></code> と <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a>/<a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a>/<a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> とは同じものという気がするかもしれません．
どちらも，モジュールをスコープに入れるために使うものです．
しかし，この2つには大きな違いがあります．
GHCi は2種類のモジュール集合にかかわっています．</p>
<ul class="simple">
<li>現在 <em>ロード済み</em> のモジュール集合．
このモジュール集合は <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> で変更し，
<a class="reference internal" href="#ghci-cmd-:show modules"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">modules</span></code></a> で表示できます．</li>
<li>現在，プロンプトの <em>スコープ内</em> にあるモジュール集合．
このモジュール集合は <code class="docutils literal"><span class="pre">import</span></code> および <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> で変更します．
<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> コマンドを発行すると
このモジュール集合は，上述のように自動的に変更されます．
表示するためには <a class="reference internal" href="#ghci-cmd-:show imports"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">imports</span></code></a> を使います．</li>
</ul>
<p>(<a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> あるいは <code class="docutils literal"><span class="pre">import</span></code> 経由)モジュールをスコープに追加できるのは，
(a) ロード済みのモジュール，(b) GHCiが知っているパッケージ由来のモジュール，のどちらかだけです．
<a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> あるいは <code class="docutils literal"><span class="pre">import</span></code> を使って，ロードされていないモジュールをスコープに
追加しようとすると <code class="docutils literal"><span class="pre">module</span> <span class="pre">M</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">loaded</span></code> というメッセージが表示されることでしょう．</p>
</div>
</div>
<div class="section" id="main-run">
<h3>5.4.6. <code class="docutils literal"><span class="pre">:main</span></code> コマンドと <code class="docutils literal"><span class="pre">:run</span></code> コマンド<a class="headerlink" href="#main-run" title="Permalink to this headline">¶</a></h3>
<p>プログラムをコンパイルして実行するとき <code class="docutils literal"><span class="pre">getArgs</span></code> 関数を使っていれば，コマンドライン引数にアクセスできます．
しかし <code class="docutils literal"><span class="pre">main</span></code> は直接引数を取りませんので，ghci でテストしているときは単純にコマンドライン引数を渡すことができません．</p>
<p>その代りとして <a class="reference internal" href="#ghci-cmd-:main"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:main</span></code></a> コマンドを使います．
このコマンドはスコープ内にある <code class="docutils literal"><span class="pre">main</span></code> を以下のようにコマンドライン引数を渡した状態にして起動します．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; main = System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :main foo bar
[&quot;foo&quot;,&quot;bar&quot;]
</pre></div>
</div>
<p>スペースのような文字を含む文字列は引用符でかこって渡せます．
引数はそれぞれHaskellの文字列として扱われます．
また，Haskellのリスト構文をそのまま使うこともできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :main foo &quot;bar baz&quot;
[&quot;foo&quot;,&quot;bar baz&quot;]
Prelude&gt; :main [&quot;foo&quot;, &quot;bar baz&quot;]
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
<p>また <code class="docutils literal"><span class="pre">-main-is</span></code> フラグや <a class="reference internal" href="#ghci-cmd-:run"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:run</span></code></a> コマンドを使えば，その他の関数を呼べます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; foo = putStrLn &quot;foo&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; bar = putStrLn &quot;bar&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :set -main-is foo
Prelude&gt; :main foo &quot;bar baz&quot;
foo
[&quot;foo&quot;,&quot;bar baz&quot;]
Prelude&gt; :run bar [&quot;foo&quot;, &quot;bar baz&quot;]
bar
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
</div>
<div class="section" id="it">
<h3>5.4.7. <code class="docutils literal"><span class="pre">it</span></code> 変数<a class="headerlink" href="#it" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-9"></span><p>プロンプトに式(正確には非束縛文)を入力すると，
GHCi は暗黙のうちにその値で <code class="docutils literal"><span class="pre">it</span></code> を束縛します．
以下はその一例です．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; 1+2
3
Prelude&gt; it * 2
6
</pre></div>
</div>
<p>実際はなにが起こっているかというと，GHCi は型検査を行い，その式の型が <code class="docutils literal"><span class="pre">IO</span></code> 型でなければ，
次のように変形します．
すなわち，ここで当該の式を <code class="docutils literal"><span class="pre">e</span></code> とすると,</p>
<div class="highlight-none"><div class="highlight"><pre>let it = e;
print it
</pre></div>
</div>
<p>のように変形したのち，これをIOアクションとして実行します．</p>
<p>そういう訳で，元の式の型は <code class="docutils literal"><span class="pre">Show</span></code> クラスのインスタンスでなければなりません．
<code class="docutils literal"><span class="pre">Show</span></code> クラスのインスタンスでなかったら，GHCiは文句をいいます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; id

&lt;interactive&gt;:1:0:
    No instance for (Show (a -&gt; a))
      arising from use of `print&#39; at &lt;interactive&gt;:1:0-1
    Possible fix: add an instance declaration for (Show (a -&gt; a))
    In the expression: print it
    In a &#39;do&#39; expression: print it
</pre></div>
</div>
<p>このエラーメッセージから，内部の変形で何が起こったのか少しだけうかがい知ることができます．</p>
<p>式の型がなにがしかの型 <code class="docutils literal"><span class="pre">a</span></code> について <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> 型である場合には，
<code class="docutils literal"><span class="pre">it</span></code> はその <code class="docutils literal"><span class="pre">IO</span></code> コンピュテーションの結果，つまり <code class="docutils literal"><span class="pre">a</span></code> 型の値で束縛されます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; Time.getClockTime
Wed Mar 14 12:23:13 GMT 2001
Prelude&gt; print it
Wed Mar 14 12:23:13 GMT 2001
</pre></div>
</div>
<p>IO型の式 <code class="docutils literal"><span class="pre">e</span></code> に対する変形は，</p>
<div class="highlight-none"><div class="highlight"><pre>it &lt;- e
</pre></div>
</div>
<p>となります．</p>
<p>新しい式を評価するたびに <code class="docutils literal"><span class="pre">it</span></code> の値は新しい値でシャドウされ，古い <code class="docutils literal"><span class="pre">it</span></code> の値は失われることに注意してください．</p>
</div>
<div class="section" id="extended-default-rules">
<span id="id19"></span><h3>5.4.8. GHCi でのデフォルト型設定<a class="headerlink" href="#extended-default-rules" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-10"></span><p>次のGHCiセッションを考えていみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>ghci&gt; reverse []
</pre></div>
</div>
<p>GHCi は何をすべきでしょうか．
厳密にいえば，このプログラムは曖昧です．
<code class="docutils literal"><span class="pre">show</span> <span class="pre">(reverse</span> <span class="pre">[])</span></code> (ここでGHCiが計算するのはこれです)の型は，
<code class="docutils literal"><span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">String</span></code> であり，これをどのように表示するかは <code class="docutils literal"><span class="pre">a</span></code> の型に依存します．
たとえば，</p>
<div class="highlight-none"><div class="highlight"><pre>ghci&gt; reverse ([] :: String)
&quot;&quot;
ghci&gt; reverse ([] :: [Int])
[]
</pre></div>
</div>
<p>のようになります．
しかし，ユーザがこの型を指定しなければならないというのは面倒なので，
GHCiはHaskellのデフォルト型設定規則(Haskell 2010 Report の 4.3.4 節)
を以下のように拡張しています．
標準の規則では，個々の型変数 <code class="docutils literal"><span class="pre">a</span></code> についてのそれぞれ制約グループ <code class="docutils literal"><span class="pre">(C1</span> <span class="pre">a,</span> <span class="pre">C2</span> <span class="pre">a,</span> <span class="pre">...,</span> <span class="pre">Cn</span> <span class="pre">a)</span></code> を考え，
次の条件が満たされたとき，この型変数のデフォルトの型を設定します．</p>
<ol class="arabic simple">
<li>型変数 <code class="docutils literal"><span class="pre">a</span></code> が他のどの制約にも現れない．</li>
<li>クラス <code class="docutils literal"><span class="pre">Ci</span></code> はすべて標準のクラスである．</li>
<li>クラス <code class="docutils literal"><span class="pre">Ci</span></code> の少くとも1つは数値である．</li>
</ol>
<p>GHCiプロンプトあるいはGHCでは <code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExtendedDefaultRules</span></code> フラグが設定されていると，
以下のような規則変更がおこなわれます．</p>
<ul class="simple">
<li>規則2の緩和: クラス <code class="docutils literal"><span class="pre">Ci</span></code> は <em>すべて</em> 単一パラメータの型クラスである．</li>
<li>規則3の緩和: クラス <code class="docutils literal"><span class="pre">Ci</span></code> のうち少くとも1つは数値であるか <code class="docutils literal"><span class="pre">Show</span></code> ， <code class="docutils literal"><span class="pre">Eq</span></code> ， <code class="docutils literal"><span class="pre">Ord</span></code> ， <code class="docutils literal"><span class="pre">Foldable</span></code> ， <code class="docutils literal"><span class="pre">Traversable</span></code>
のどれかである．</li>
<li>ユニット型 <code class="docutils literal"><span class="pre">()</span></code> およびリスト型 <code class="docutils literal"><span class="pre">[]</span></code> がデフォルトの型として試されるリストの先頭に追加される．</li>
</ul>
<p>最後の点は，たとえば，以下のプログラムに影響します．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="n">def</span>

<span class="kr">instance</span> <span class="kt">Num</span> <span class="nb">()</span>

<span class="nf">def</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Enum</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span>
<span class="nf">def</span> <span class="ow">=</span> <span class="n">toEnum</span> <span class="mi">0</span>
</pre></div>
</div>
<p>このプログラムは <code class="docutils literal"><span class="pre">0</span></code> ではなく <code class="docutils literal"><span class="pre">()</span></code> を表示します．
それは <code class="docutils literal"><span class="pre">a</span></code> のデフォルトの型が <code class="docutils literal"><span class="pre">Integer</span></code> ではなく <code class="docutils literal"><span class="pre">()</span></code> に設定されるからです．</p>
<p>このような変更を行う動機は <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> アクションのデフォルトの型は <code class="docutils literal"><span class="pre">IO</span> <span class="pre">()</span></code> になるので，
これを実行したときghciは結果を表示する面倒がないというものです．
とくに <code class="docutils literal"><span class="pre">printf</span></code> にとってはこれが重要で <code class="docutils literal"><span class="pre">printf</span></code> のインスタンスで <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> を返すものがありますが，
それができることといえば <code class="docutils literal"><span class="pre">undefined</span></code> を返すこと以外ありません
(printf が型クラスシステムの拡張を必要としないようにというのがその理由)．
したがって，もしここでデフォルトの型が <code class="docutils literal"><span class="pre">Integer</span></code> だと，printfを走らせると，ghciがエラーになってしまいます．</p>
<p>計算を扱うモナドは，可能であるなら <code class="docutils literal"><span class="pre">IO</span></code> がデフォルトであることについては <a class="reference internal" href="#actions-at-prompt"><span>プロンプトでのI/Oアクション</span></a> を参照してください．</p>
</div>
<div class="section" id="ghci-interactive-print">
<span id="id20"></span><h3>5.4.9. 独自の対話表示関数を使う<a class="headerlink" href="#ghci-interactive-print" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-11"></span><p>GHC 7.6.1 以降，GHCiはプロンプトに入力された式の結果を <code class="docutils literal"><span class="pre">System.IO.print</span></code> を使って表示します．
この関数の型シグネチャは <code class="docutils literal"><span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code> で，値を <code class="docutils literal"><span class="pre">show</span></code> を使って <code class="docutils literal"><span class="pre">String</span></code> に変換しています．</p>
<p>このやり方が理想的ではない場合があります．
出力が長い場合や非アスキー文字が含まれるというような場合です．</p>
<p><a class="reference internal" href="#ghc-flag--interactive-print"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-interactive-print</span></code></a> フラグを使えば，何らかの制約を <code class="docutils literal"><span class="pre">C</span></code> として，
<code class="docutils literal"><span class="pre">C</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code> という型の関数を評価済みの式の値を表示する関数として指定できるようになります．
この関数はロード済みのモジュールまたは登録済みのパッケージに置いてあればよいのですが，
登録済みのパッケージに置いてある場合のみ <a class="reference internal" href="#ghci-cmd-:cd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cd</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> あるいは <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> というコマンドをくぐり抜けられます．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--interactive-print">
<code class="descname">-interactive-print</code><code class="descclassname"> ⟨expr⟩</code><a class="headerlink" href="#ghc-flag--interactive-print" title="Permalink to this definition">¶</a></dt>
<dd><p>GHCiが評価結果を表示するのに使う関数を設定します．
このとき〈expr〉の型は <code class="docutils literal"><span class="pre">C</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code> でなければなりません．</p>
</dd></dl>

<p>例として，以下の特別な表示モジュールがあるとしましょう．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">SpecPrinter</span> <span class="kr">where</span>
<span class="kr">import</span> <span class="nn">System.IO</span>

<span class="nf">sprint</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot;!&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sprint</span></code> 関数は表示された値の最後に感嘆符を追加します．
以下のコマンド</p>
<div class="highlight-none"><div class="highlight"><pre>ghci -interactive-print=SpecPrinter.sprinter SpecPrinter
</pre></div>
</div>
<p>でGHCiを起動すると，対話セッションが始まり，そこでは値は <code class="docutils literal"><span class="pre">sprint</span></code> で表示されます．</p>
<div class="highlight-none"><div class="highlight"><pre>*SpecPrinter&gt; [1,2,3]
[1,2,3]!
*SpecPrinter&gt; 42
42!
</pre></div>
</div>
<p>これには独自の整形表示関数が使えます．
たとえばツリー構造や入れ子構造をよりよみやすい形式で表示できます．</p>
<p><a class="reference internal" href="#ghc-flag--interactive-print"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-interactive-print</span></code></a> フラグはGHCを <code class="docutils literal"><span class="pre">-e</span> <span class="pre">mode</span></code> で起動したときにも使えます．</p>
<div class="highlight-none"><div class="highlight"><pre>% ghc -e &quot;[1,2,3]&quot; -interactive-print=SpecPrinter.sprint SpecPrinter
[1,2,3]!
</pre></div>
</div>
</div>
<div class="section" id="ghci-stack-traces">
<span id="id21"></span><h3>5.4.10. GHCiのスタックトレース<a class="headerlink" href="#ghci-stack-traces" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-12"></span><p>[ この機能は GHC 8.0.1 で導入された実験的機能で，
<code class="docutils literal"><span class="pre">-fexternal-interpreter</span></code> フラグで有効になります．
現時点ではWindowsでは利用できません．]</p>
<p>GHCi では解釈実行コードを走らせるときに，プロファイリングシステムを使って，
スタックトレース情報を収集できます．
スタックトレースにアクセスするには，GHCiを次のように起動します．</p>
<div class="highlight-none"><div class="highlight"><pre>ghci -fexternal-interpreter -prof
</pre></div>
</div>
<p>こうすると，解釈実行コードは別プロセスで(<a class="reference internal" href="#external-interpreter"><span>インタプリタを別プロセスで走らせる</span></a> 参照)，
プロファイリングモードで走らせてコールスタック情報を収集します．
解釈実行コードをプロファイリングモードで走らせることになりますので，
使用するすべてのパッケージはプロファイリング用にコンパイルされている必要があります．
GHCi に対する <code class="docutils literal"><span class="pre">-prof</span></code> フラグは <code class="docutils literal"><span class="pre">-fexternal-interpreter</span></code> と同時に使うときだけ有効です．</p>
<p>現在のコールスタックにアクセスする方法は3つあります．</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">error</span></code> と <code class="docutils literal"><span class="pre">undefined</span></code> は自動的にエラーメッセージにカレントスタックをアタッチします．
これは通常 <code class="docutils literal"><span class="pre">HasCallStack</span></code> スタック(<a class="reference internal" href="glasgow_exts.html#hascallstack"><span>HasCallStack</span></a> 参照)を補足するもので，
その時には両方のスタックが表示されます．</li>
<li><code class="docutils literal"><span class="pre">Debug.Trace.traceStack</span></code> は <code class="docutils literal"><span class="pre">Debug.Trace.trace</span></code> の変形版で現在のコールスタックも表示します．</li>
<li><code class="docutils literal"><span class="pre">GHC.Stack</span></code> にある関数を使って現在のスタックを取得し，表示できます．</li>
</ul>
<p>解釈実行するモジュールについては <code class="docutils literal"><span class="pre">-fprof-auto</span></code> を使う必要はありません．
注釈は自動的に細かく追加されますので，個別のコールサイトを区別できます．
しかしながら，コンパイル済みコードのコールスタック情報は，そのコードを
<code class="docutils literal"><span class="pre">-fprof-auto</span></code> 付きでコンパイルしているか，明示的に <code class="docutils literal"><span class="pre">SCC</span></code> 注釈
(<a class="reference internal" href="profiling.html#scc-pragma"><span>Inserting cost centres by hand</span></a> 参照)を付けていないかぎり見ることはできません．</p>
</div>
</div>
<div class="section" id="ghci-debugger">
<span id="id22"></span><h2>5.5. GHCiのデバッガ<a class="headerlink" href="#ghci-debugger" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-13"></span><p>GHCi は単純な命令スタイルのデバッガを備えています．
これを使うと，変数の値を確認するために進行中の計算を止められます．
このデバッガはGHCiに統合されていて，デフォルトで有効になっています．
デバッグ機能を有効にするのにフラグは必要ありません．
1つ重要な制限があります．
それは，ブレイクポイントとステップ実行は解釈実行されているモジュールでしか使えないということです．
コンパイル済みのコードはデバッガからは見えません <a class="footnote-reference" href="#id43" id="id23">[5]</a> ．</p>
<p>このデバッガが提供する機能は以下のとおりです．</p>
<ul class="simple">
<li>プログラム中の関数定義や式にブレイクポイントを設定する機能．
関数が呼ばれたとき，式が評価されたとき，GHCiは実行を中断しプロンプトに戻ります．
このプロンプトで局所変数の値を調べたあと，実行を再開継続できます．</li>
<li>ステップ実行機能．
評価器はほぼ簡約ごとに実行を中断し，局所変数の値を調べられるようにします．
これはプログラムのあらゆるポイントにブレイクポイントを設定するのと同じことです．</li>
<li>トレースモードでの実行機能．
トレースモードで実行すると，評価器は発生した評価ステップをすべて記憶します．
ただし，実際のブレイクポイントに到達するまでは，実行を中断することはありません．
実行が中断されたら，評価ステップの履歴を調べることができるようになります．</li>
<li>例外(たとえば，パターン照合の失敗あるいは <code class="docutils literal"><span class="pre">error</span></code> など)をブレイクポイントとして扱えます．
これにより，プログラム中の例外発生源を特定しやすくなります．</li>
</ul>
<p>現時点では「スタックトレース」を得る手段は提供されていませんが，
トレース機能と履歴機能が次善の策として提供されており，
エラー発生時の状況を知るには十分であることも多いのです．
たとえコンパイル済みのコードから例外が投げられたときでも，自動的にブレイクするようにできます
(<a class="reference internal" href="#ghci-debugger-exceptions"><span>例外のデバッグ</span></a> 参照)．</p>
<div class="section" id="breakpoints">
<span id="id24"></span><h3>5.5.1. ブレイクポイントと変数内容の表示<a class="headerlink" href="#breakpoints" title="Permalink to this headline">¶</a></h3>
<p>実際に動く例としてクイックソートを使いましょう．以下がそのコードです．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">qsort</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">qsort</span> <span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">as</span><span class="p">)</span> <span class="ow">=</span> <span class="n">qsort</span> <span class="n">left</span> <span class="o">++</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">++</span> <span class="n">qsort</span> <span class="n">right</span>
  <span class="kr">where</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&lt;=</span><span class="n">a</span><span class="p">)</span> <span class="n">as</span><span class="p">,</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="n">a</span><span class="p">)</span> <span class="n">as</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">qsort</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">18</span><span class="p">])</span>
</pre></div>
</div>
<p>ます，このモジュールをGHCiにロードしましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :l qsort.hs
[1 of 1] Compiling Main             ( qsort.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt;
</pre></div>
</div>
<p>次に，qsort の定義2つめの等式の右辺にブレイクポイントを設定します．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :break 2
Breakpoint 0 activated at qsort.hs:2:16-47
*Main&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">:break</span> <span class="pre">2</span></code> というコマンドは直近にロードしたモジュールの2行目にブレイクポイントを設定するものです．
この場合は <code class="docutils literal"><span class="pre">qsort.hs</span></code> の2行目です．
詳しくいえば，ブレイクポイントを設定した行にある完全な部分式のうちもっとも左側にあるものが選ばれます．
この場合は <code class="docutils literal"><span class="pre">(qsort</span> <span class="pre">left</span> <span class="pre">++</span> <span class="pre">[a]</span> <span class="pre">++</span> <span class="pre">qsort</span> <span class="pre">right)</span></code> です．</p>
<p>[&#8211;ここから&#8211; GHC Users Manual 原文の記述とghciの実際の挙動が異なるので，実際の挙動に沿って非公式に説明します．]</p>
<p>さて，このプログラムを走らせてみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; main
Stopped in Main.qsort, qsort.hs:2:16-47
_result :: [Integer] = _
a :: Integer = 8
left :: [Integer] = _
right :: [Integer] = _
[qsort.hs:2:16-47] *Main&gt;
</pre></div>
</div>
<p>[&#8211;ここまで&#8211; 実際の挙動に沿った非公式な記述]</p>
<p>ブレイクポイントのところで実行が中断されました．
プロンプトが変化して，ブレイクポイントで止っていること，
その場所が <code class="docutils literal"><span class="pre">[qsort.hs:2:16-47]</span></code> であることが判ります．
その場所をさらに明確にするには <a class="reference internal" href="#ghci-cmd-:list"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:list</span></code></a> コマンドを使います．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :list
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
</pre></div>
</div>
<p><a class="reference internal" href="#ghci-cmd-:list"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:list</span></code></a> コマンドは，現在のブレイクポイントの周囲のコードを表示します．
出力デバイスがサポートしている場合は，注目している部分式がボールド体で表示されます．</p>
<p>GHCiは，ブレイクポイントを置いた式の自由変数 <a class="footnote-reference" href="#id44" id="id25">[6]</a> (<code class="docutils literal"><span class="pre">a</span></code> ， <code class="docutils literal"><span class="pre">left</span></code> ， <code class="docutils literal"><span class="pre">right</span></code>)
に対する束縛および当該式の結果(<code class="docutils literal"><span class="pre">_result</span></code>)に対する束縛も提供しています．
これらの変数は，GHCi上で普通に定義する他の変数と同じです．
プロンプトで入力する式の中で使ったり， <a class="reference internal" href="#ghci-cmd-:type"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span></code></a> コマンドで型を確認するなどが可能です．</p>
<p>[&#8211;ここから&#8211; GHC Users Manual 原文の記述とghciの実際の挙動が異なるので，実際の挙動に沿って非公式に説明します．]</p>
<p>例を見ましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :type left
left :: [Integer]
</pre></div>
</div>
<p>[&#8211;ここまで&#8211; 実際の挙動に沿って非公式説明]</p>
<p>デバッガにはジェネリックな表示コマンド
<a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> があり，これを使えば，変数の実行時の値と型を調べられます．
<code class="docutils literal"><span class="pre">left</span></code> に対して使ってみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :print left
left = (_t1::[Integer])
</pre></div>
</div>
<p>あまり細かいことは判りません．
<code class="docutils literal"><span class="pre">left</span></code> は未評価の計算(サスペンションあるいはサンク)に束縛されています．
これは <code class="docutils literal"><span class="pre">left</span></code> は未評価ですが <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> が評価を強制しないからです．</p>
<p><a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> はブレイクポイントで値を検査する際に副作用を起こさないようにしてあるのです．
評価を強制しないので，通常の評価と違う結果になったり，例外が投げられたり，無限ループや別のブレイクポイントに遭遇することもありません
(<a class="reference internal" href="#nested-breakpoints"><span>ブレイクポイントのネスト</span></a> 参照)．
<a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> は各サンクにアンダースコアで始まるフレッシュ(まだ使われていない)変数，ここでは <code class="docutils literal"><span class="pre">_t1</span></code> を束縛します．</p>
<p>[&#8211;ここでは&#8211; GHC Users Manual 原文の記述とghciの実際の挙動が異なる部分に関連する説明を省いています．]</p>
<p>変数の評価状態を変えてしまってかまわないのなら <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> ではなく <a class="reference internal" href="#ghci-cmd-:force"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:force</span></code></a> を使うこともできます．
<a class="reference internal" href="#ghci-cmd-:force"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:force</span></code></a> コマンドはサンクのときは評価を強制する以外は <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> と同じ振る舞いになります．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :force left
left = [4,0,3,1]
</pre></div>
</div>
<p>[&#8211;ここから&#8211; GHC Users Manual 原文の記述とghciの実際の挙動が異なるので，実際の挙動に沿って非公式に説明します．]</p>
<p>ここで <a class="reference internal" href="#ghci-cmd-:show bindings"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">bindings</span></code></a> を使うと，関連する束縛を表示できます．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :show bindings
right :: [Integer] = _
left :: [Integer] = [4,0,3,1]
a :: Integer = 8
_result :: [Integer] = _
_t1 :: [Integer] = [4,0,3,1]
</pre></div>
</div>
<p>式全体を:forceで評価してしまうのではなく，個々のサンクを評価したい場合には，Haskellの
<code class="docutils literal"><span class="pre">seq</span></code> 関数が便利でしょう．以下のように使います．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :print right
right = (_t2::[Integer])
[qsort.hs:2:16-47] *Main&gt; seq _t2 ()
()
[qsort.hs:2:16-47] *Main&gt; :print right
right = 23 : (_t3::[Integer])
</pre></div>
</div>
<p>We evaluated only the <code class="docutils literal"><span class="pre">_t1</span></code> thunk, revealing the head of the list, and
ここでは，サンク <code class="docutils literal"><span class="pre">_t2</span></code> だけを評価して，リストの先頭が判明しました．
<code class="docutils literal"><span class="pre">seq</span></code> 関数はすこし使いにくいので <a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> を使ってもっとよいインターフェイスを作るといいでしょう
(どうするかは練習問題にしておきます！)．</p>
<p>そして，実行を再開することもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :continue
Stopped in Main.qsort, qsort.hs:2:16-47
_result :: [Integer] = _
a :: Integer = 4
left :: [Integer] = _
right :: [Integer] = _
[qsort.hs:2:16-47] *Main&gt;
</pre></div>
</div>
<p>実行が前に停止した点から再開し，同じブレイクで再び停止しました．</p>
<p>[&#8211;ここまで&#8211; 実際の挙動に沿った非公式説明．]</p>
<div class="section" id="setting-breakpoints">
<span id="id26"></span><h4>5.5.1.1. ブレイクポイントの設定<a class="headerlink" href="#setting-breakpoints" title="Permalink to this headline">¶</a></h4>
<p>ブレークポイントを設定する方法はいくつかあります．
おそらくもっとも簡単な方法は最上位の関数の名前を使うことです．</p>
<div class="highlight-none"><div class="highlight"><pre>:break identifier
</pre></div>
</div>
<p>ここで ⟨identifier⟩ はGHCiにロードされて解釈実行されるモジュールのトップレベルにある関数の名前です
(これには修飾名も使えます)．
ブレイクポイントは関数の本体部分に設定されます．
関数が完全に適用されパターン照合が行われる直前に設定されます．</p>
<p>行番号(および列番号)でブレイクポイントを設定することもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>:break line
:break line column
:break module line
:break module line column
</pre></div>
</div>
<p>ブレークポイントを特定の行に設定する場合，GHCiはその行で始まりその行で終わる部分式の中で
もっとも左側にあるものに設定します．
2つの完全な部分式が同じカラムから始まっているなら長い方が選ばれます．
その行に完全な部分式が無い場合，その行で始まっている部分式の中でもっとも左側にあるものが選ばれます．
それも失敗したら，その行を一部あるいは全部覆う式の中でもっとも右側にあるものが選ばれます．</p>
<p>ブレークポイントを特定の行の特定のカラムに設定する場合，GHCiはその位置を含む式の中で最小のものを選びます．
注意: GHCはTAB文字を現れた位置に関わらず幅1とみなします．
言い換えれば，カラム数を数えるのではなく文字を数えます．
振る舞いと合うエディタもあり，合わないエディタもあります．
最善はそもそもソースコード中でタブ文字を使わないことです
(<a class="reference internal" href="using-warnings.html#options-sanity"><span>Warnings and sanity-checking</span></a> にある <a class="reference internal" href="using-warnings.html#ghc-flag--Wtabs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wtabs</span></code></a> を参照してください)．</p>
<p>モジュールが省略された場合，直近にロードされたモジュールが使われます．</p>
<p>ブレークポイントを設定できない部分式もあります．
単一の変数は通常ブレークポイント位置とはみなされません(ただし，その変数が関数定義かλかcaseの選択肢の右辺である場合は除きます)．
大まかにいうと，ブレークポイントになるのは，全ての簡約基，関数やλ抽象の本体，caseの選択肢，束縛文です．
通常let式はブレークポイントになりませんが，その本体は常にブレークポイントになります．
そのletで束縛された変数の値を調べたいと思うのが普通だからです．</p>
</div>
<div class="section" id="id27">
<h4>5.5.1.2. ブレイクポイントの一覧と削除<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>現在有効になっているブレイクポイントを一覧するには
<a class="reference internal" href="#ghci-cmd-:show breaks"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">breaks</span></code></a> を使います．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :show breaks
[0] Main qsort.hs:1:12-13
[1] Main qsort.hs:2:16-47
</pre></div>
</div>
<p>To delete a breakpoint, use the command with the number
ブレイクポイントを削除するには <a class="reference internal" href="#ghci-cmd-:delete"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:delete</span></code></a> コマンドを使い <a class="reference internal" href="#ghci-cmd-:show breaks"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">breaks</span></code></a> で出力されるブレイクポイント番号を指定します．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :delete 0
*Main&gt; :show breaks
[1] Main qsort.hs:2:16-47
</pre></div>
</div>
<p>全てのブレイクポイントを一度に削除するには <code class="docutils literal"><span class="pre">:delete</span> <span class="pre">*</span></code> とします．</p>
</div>
</div>
<div class="section" id="single-stepping">
<span id="id28"></span><h3>5.5.2. ステップ実行<a class="headerlink" href="#single-stepping" title="Permalink to this headline">¶</a></h3>
<p>ステップ実行は，プログラムの実行を可視化する素晴しい方法であり，バグの原因を同定する手段としても有用である．
<a class="reference internal" href="#ghci-cmd-:step"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:step</span></code></a> コマンドを使うと，プログラム中の全てのブレークポイントが有効にされ、次のブレークポイントに達するまで実行される．
<a class="reference internal" href="#ghci-cmd-:steplocal"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:steplocal</span></code></a> とすれば，現在のトップレベル関数の中にあるブレークポイントのみ有効になります．
同様に <a class="reference internal" href="#ghci-cmd-:stepmodule"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:stepmodule</span></code></a> とすると現在のモジュール中にあるブレークポイントのみ有効にします．
たとえば以下のようになる．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :step main
Stopped in Main.main, qsort.hs:5:8-48
_result :: IO () = _
</pre></div>
</div>
<p><a class="reference internal" href="#ghci-cmd-:step"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:step</span> <span class="pre">expr</span></code></a> コマンドは⟨expr⟩のステップ実行を開始します．
⟨expr⟩ が省略されたときは，現在のブレイクポイントからステップ実行します．
<a class="reference internal" href="#ghci-cmd-:steplocal"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:steplocal</span></code></a> および <a class="reference internal" href="#ghci-cmd-:stepmodule"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:stepmodule</span></code></a> も同様に動作します．</p>
<p>ステップ実行中は <a class="reference internal" href="#ghci-cmd-:list"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:list</span></code></a> コマンドが特に便利で，いまどこを実行しているかが判ります．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:5:8-48] *Main&gt; :list
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:8-48] *Main&gt;
</pre></div>
</div>
<p>実は，GHCiにはブレイクポイントにきたときにコマンドを実行するという機能があり，
自動的に <a class="reference internal" href="#ghci-cmd-:list"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:list</span></code></a> するようにできます．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:5:8-48] *Main&gt; :set stop :list
[qsort.hs:5:8-48] *Main&gt; :step
Stopped in Main.main, qsort.hs:5:15-47
_result :: [Integer] = _
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:15-47] *Main&gt;
</pre></div>
</div>
</div>
<div class="section" id="nested-breakpoints">
<span id="id29"></span><h3>5.5.3. ブレイクポイントのネスト<a class="headerlink" href="#nested-breakpoints" title="Permalink to this headline">¶</a></h3>
<p>GHCi がブレイクポイントで停止したとき，プロンプトに式を入力すると，次のブレイクポイントまで進みます．
この新しいブレイクポイントが現在のブレイクポイントとなり，古いブレイクポイントはスタックに保存されます．
任意の数のブレイクポイント文脈はこうして作られます．
以下はその例です．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :step qsort [1,3]
Stopped in Main.qsort, qsort.hs:2:16-47
_result :: [t] = _
a :: t = _
left :: [t] = _
right :: [t] = _
... [qsort.hs:2:16-47] *Main&gt;
</pre></div>
</div>
<p>前に設定した2行目のブレークポイントで停止したところで <code class="docutils literal"><span class="pre">:step</span> <span class="pre">qsort</span> <span class="pre">[1,3]</span></code> として新しい評価を開始したしました．
この新しい評価は1ステップの後に(<code class="docutils literal"><span class="pre">qsort</span></code> の定義で)停止しました．
ここで，プロンプトが変わって先頭に <code class="docutils literal"><span class="pre">...</span></code> が付きます．
これが現在のブレークポイントの他に保存されたブレークポイントがあることを示しています．
この文脈スタックを見るには <a class="reference internal" href="#ghci-cmd-:show context"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">context</span></code></a> を使えばいいでしょう．</p>
<div class="highlight-none"><div class="highlight"><pre>... [qsort.hs:2:16-47] *Main&gt; :show context
--&gt; main
Stopped in Main.qsort, qsort.hs:2:16-47
--&gt; qsort [1,3]
Stopped in Main.qsort, qsort.hs:2:16-47
... [qsort.hs:2:16-47] *Main&gt;
</pre></div>
</div>
<p>現在の評価の結果を捨てるには <a class="reference internal" href="#ghci-cmd-:abandon"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:abandon</span></code></a>: を使います．</p>
<div class="highlight-none"><div class="highlight"><pre>... [qsort.hs:2:16-47] *Main&gt; :abandon
[qsort.hs:2:16-47] *Main&gt; :abandon
*Main&gt;
</pre></div>
</div>
</div>
<div class="section" id="result">
<span id="ghci-debugger-result"></span><h3>5.5.4. <code class="docutils literal"><span class="pre">_result</span></code> 変数<a class="headerlink" href="#result" title="Permalink to this headline">¶</a></h3>
<p>ブレークポイントで停止したときやステップ実行するとき，GHCiは <code class="docutils literal"><span class="pre">_result</span></code> という変数を用意して，
現在注目されている式の結果に束縛します．
<code class="docutils literal"><span class="pre">_result</span></code> の値はおそらくまだ存在しない(その評価を止めたので)が，
その評価を強制することはできます．
その型が既知で表示できるなら <code class="docutils literal"><span class="pre">_result</span></code> とプロンプトに入力するだけで表示できます．
ただし，警告が一つあります．
<code class="docutils literal"><span class="pre">_result</span></code> を評価すると，別のブレークポイントにあたる可能性が高いということです．
特に <a class="reference internal" href="#ghci-cmd-:step"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:step</span></code></a> ではなく真のブレークポイントで停止していたら，このブレークポイントに最初にあたります．
このため <code class="docutils literal"><span class="pre">_result</span></code> を評価する時には，即座に <a class="reference internal" href="#ghci-cmd-:continue"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:continue</span></code></a> を発行しなければならなく可能性が高くなります．
別の方法としては <a class="reference internal" href="#ghci-cmd-:force"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:force</span></code></a> はブレークポイントを無視するので，これを使うこともできます．</p>
</div>
<div class="section" id="tracing">
<span id="id30"></span><h3>5.5.5. トレースとヒストリ<a class="headerlink" href="#tracing" title="Permalink to this headline">¶</a></h3>
<p>プログラムをデバッグしている時によく「どうやってここに来たの？」と思うことがあります．
伝統的な命令的デバッガは通常なにがしかのスタックトレース機能を持っていて，
それを使ってアクティブな関数呼び出しのスタック(「レキシカルコールスタック」と呼ばれることも)を
確認できます．
このスタックによって，現在の位置に至るまでのコード上の道のりが判ります．
残念ながら，これをHaskellで用意するのは難しいのです．
正格な言語と違って，実行は深さ優先ではなく必要に応じて進むからです．
GHCの実行エンジンにある「スタック」は字句的呼び出しスタックとは大きく異なります．
理想的には，GHCがこの動的な呼び出しスタックに加えて，字句的呼び出しスタックを管理すれば良く，
実はプロファイルシステムはまさにこれを行っています(<a class="reference internal" href="profiling.html#profiling"><span>Profiling</span></a>)．
他のHaskellデバッガにもこれをしているものがある．
しかし，現在のところGHCiは字句的呼び出しスタックを管理していません
(克服せねばならない技術的困難がいくつかあります)．
代わりにブレークポイントから直前の評価ステップに戻る方法を用意しています．
これは要するにステップ実行を逆向きにするのと同じです．
多くの場合「どうやってここに来たの？」という疑問を解決するのに十分な情報がえられます．</p>
<p>トレース機能を使うには，式を <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> コマンドで評価します．
たとえば <code class="docutils literal"><span class="pre">qsort</span></code> のベースケースにブレイクポイントを設定します．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :list qsort
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
*Main&gt; :break 1
Breakpoint 0 activated at qsort.hs:1:12-13
*Main&gt;
</pre></div>
</div>
<p>こうしておいて，小さいデータに <code class="docutils literal"><span class="pre">qsort</span></code> をトレース付きで実行します．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :trace qsort [3,2,1]
Stopped in Main.qsort, qsort.hs:1:12-13
_result :: [a] = _
[qsort.hs:1:12-13] *Main&gt;
</pre></div>
</div>
<p>これで評価ステップのヒストリを確認できます．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:1:12-13] *Main&gt; :history
-1  : qsort:(...) (qsort.hs:3:25-39)
-2  : qsort:(...) (qsort.hs:3:24-56)
-3  : qsort (qsort.hs:2:16-25)
-4  : qsort (qsort.hs:2:16-47)
-5  : qsort:(...) (qsort.hs:3:25-39)
-6  : qsort:(...) (qsort.hs:3:24-56)
-7  : qsort (qsort.hs:2:16-25)
-8  : qsort (qsort.hs:2:16-47)
-9  : qsort:(...) (qsort.hs:3:25-39)
-10 : qsort:(...) (qsort.hs:3:24-56)
-11 : qsort (qsort.hs:2:16-25)
-12 : qsort (qsort.hs:2:16-47)
&lt;end of history&gt;
</pre></div>
</div>
<p>ヒストリ中の特定のステップを調べるには <a class="reference internal" href="#ghci-cmd-:back"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:back</span></code></a> を使います．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:1:12-13] *Main&gt; :back
Logged breakpoint at qsort.hs:3:25-39
_result :: [Integer]
a :: Integer
as :: [Integer]
[-1: qsort.hs:3:25-39] *Main&gt;
</pre></div>
</div>
<p>ヒストリ中の各ステップにおけるローカル変数は保存されており，
通常と同じように値を調べられるということに注目してください．
さらに，プロンプトが変わって <code class="docutils literal"><span class="pre">-1</span></code> のように，ヒストリの最初のステップを調べていることを示しています．
<a class="reference internal" href="#ghci-cmd-:forward"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:forward</span></code></a> コマンドを使えば，ヒストリを前方にたどれます．</p>
<p><a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> コマンドには式を与えても与えなくてもかまいません．
式を与えなかった場合は <a class="reference internal" href="#ghci-cmd-:step"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:step</span></code></a> と同様，現在のブレイクポイントからトレースが始まります．</p>
<p>ヒストリは <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> を使ったときにしか記録されません．
そのようになっているのは，全てのブレイクポイントをヒストリに記録することで性能が2倍以上に悪化することが判っているからである．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fghci-hist-size">
<code class="descname">-fghci-hist-size</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fghci-hist-size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">50</td>
</tr>
</tbody>
</table>
<p>GHCi で追跡する評価ヒストリの深さを変更する</p>
</dd></dl>

</div>
<div class="section" id="ghci-debugger-exceptions">
<span id="id31"></span><h3>5.5.6. 例外のデバッグ<a class="headerlink" href="#ghci-debugger-exceptions" title="Permalink to this headline">¶</a></h3>
<p>デバッグの際にもうひとつ思うことは「この例外はどこから来たの？」ということです．
<code class="docutils literal"><span class="pre">error</span></code> や <code class="docutils literal"><span class="pre">head</span> <span class="pre">[]</span></code> などが引き起こすような例外には文脈情報がついていません．
プログラム中のどの <code class="docutils literal"><span class="pre">head</span></code> 呼び出しがエラーになったかを探すのは骨の折れる仕事です．
たいていの場合 <code class="docutils literal"><span class="pre">Debug.Trace.trace</span></code> を仕込むか，プロファイル指定でコンパイルして
<code class="docutils literal"><span class="pre">Debug.Trace.traceStack</span></code> を使うか <code class="docutils literal"><span class="pre">+RTS</span> <span class="pre">-xc</span></code> (<a class="reference internal" href="runtime_control.html#rts-flag--xc"><code class="xref std std-rts-flag docutils literal"><span class="pre">-xc</span></code></a> 参照)を使うかです．</p>
<p>GHCiデバッガはソースコードを書き換えたり，再コンパイルしたりすることなく，
てばやく，この手のエラーに光を当てる方法を提供しています．
ひとつの方法は，ソースコード中で例外を投げる場所にブレークポイントを設定し <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> と <a class="reference internal" href="#ghci-cmd-:history"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:history</span></code></a> を使って
文脈を把握することです．
しかし <code class="docutils literal"><span class="pre">head</span></code> はライブラリ中にあり，そこに直接ブレークポイントを設定できません．
そういうわけで，GHCiには <a class="reference internal" href="#ghc-flag--fbreak-on-exception"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbreak-on-exception</span></code></a> フラグが用意されています．
これを使うと例外が投げられた時に評価器を停止できます．
<a class="reference internal" href="#ghc-flag--fbreak-on-error"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbreak-on-error</span></code></a> も同様ですが，こちらは例外が捕捉されなかった場合のみ停止します．
例外で停止すると，GHCiはちょうどブレークポイントに当ったのと同じように振る舞います．
違うのは，ソースコード中の位置が表示されないということです．
したがって <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> と組み合わせて，例外が発生する直前までのステップを記録するようにしないと
あまり役には立ちません．
たとえば，以下のようにします．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :set -fbreak-on-exception
*Main&gt; :trace qsort (&quot;abc&quot; ++ undefined)
&quot;Stopped in &lt;exception thrown&gt;, &lt;unknown&gt;
_exception :: e = _
[&lt;unknown&gt;] *Main&gt; :hist
-1  : qsort:(...) (qsort.hs:3:25-39)
-2  : qsort:(...) (qsort.hs:3:24-56)
-3  : qsort (qsort.hs:2:16-25)
-4  : qsort (qsort.hs:2:16-47)
&lt;end of history&gt;
[&lt;unknown&gt;] *Main&gt; :back
Logged breakpoint at qsort.hs:3:25-39
_result :: [Char]
a :: Char
as :: [Char]
[-1: qsort.hs:3:25-39] *Main&gt; :force as
*** Exception: Prelude.undefined
CallStack (from HasCallStack):
error, called at libraries/base/GHC/Err.hs:79:14 in base:GHC.Err
undefined, called at &lt;interactive&gt;:2:17 in interactive:Ghci1
[-1: qsort.hs:3:25-39] *Main&gt; :print as
as = &#39;b&#39; : &#39;c&#39; : (_t1::[Char])
</pre></div>
</div>
<p>新しい変数 <code class="docutils literal"><span class="pre">_exception</span></code> が例外に束縛されます．</p>
<p>例外発生時にブレークする機能は，プログラムが無限ループしているとき，それが何をしているかを調べるのに特に便利です．
Ctrl-C を叩いて，履歴を見て，何が起こっていたかを調べればいいのです．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fbreak-on-exception">
<code class="descname">-fbreak-on-exception</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fbreak-on-exception" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--fbreak-on-error">
<code class="descname">-fbreak-on-error</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fbreak-on-error" title="Permalink to this definition">¶</a></dt>
<dd><p>GHCiが，例外のイベントで，評価を停止して対話プロンプトに戻るようにします．
<a class="reference internal" href="#ghc-flag--fbreak-on-exception"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbreak-on-exception</span></code></a> はすべての例外でブレイクするのに対して，
<a class="reference internal" href="#ghc-flag--fbreak-on-error"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbreak-on-error</span></code></a> は捕捉されない例外でのみブレイクします．</p>
</dd></dl>

</div>
<div class="section" id="id32">
<h3>5.5.7. 例：関数の調査<a class="headerlink" href="#id32" title="Permalink to this headline">¶</a></h3>
<p>このデバッガを使って関数値を調べられます．
ブレークポイントで停止し，スコープに関数があるとき，デバッガでその関数のソースコードを表示させることはできません．
しかし，その関数をいくつかの引数に適用して結果を観察することで，いくらかの情報をえることはできます．</p>
<p>束縛が多相的な場合には，このプロセスはすこし複雑になります．
例で見ましょう．
簡単に考えるために，よく知られた <code class="docutils literal"><span class="pre">map</span></code> 関数を例にとります．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">map</span><span class="p">)</span>

<span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">map</span> <span class="n">f</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">map</span></code> にブレイクポイントを設定して，呼び出してみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :break 5
Breakpoint 0 activated at map.hs:5:16-29
*Main&gt; map Just [1..5]
Stopped in Main.map, map.hs:5:16-29
_result :: [b] = _
f :: Integer -&gt; b = _
x :: Integer = 1
xs :: [Integer] = _
[map.hs:5:16-29] *Main&gt;
</pre></div>
</div>
<p>GHCi の表示を見れば <code class="docutils literal"><span class="pre">f</span></code> がスコープにあることがわかります．
しかし，その型は完全に判明しているわけではありません．
とはいうものの，最初の引数の型を見れば，これが <code class="docutils literal"><span class="pre">x</span></code> の型と同じ <code class="docutils literal"><span class="pre">Integer</span></code> であることも，
<code class="docutils literal"><span class="pre">_result</span></code> の型が同じ <code class="docutils literal"><span class="pre">Integer</span></code> を要素とするリストであることも判ります．</p>
<p>[&#8211;ここでは&#8211; GHC Users Guide 原文の記述とghciの実際の挙動が異なる部分に関連する説明を省いています．]</p>
<p>以降 <code class="docutils literal"><span class="pre">f</span></code> を <code class="docutils literal"><span class="pre">Integer</span></code> 型の任意の引数に適用してその結果を観察できます．
[&#8211;ここから&#8211; GHC Users Manual 原文の記述とghciの実際の挙動が異なるので，実際の挙動に沿って非公式に説明します．]</p>
<div class="highlight-none"><div class="highlight"><pre>[map.hs:5:16-29] *Main&gt; :abandon
*Main&gt; let b = f 10
*Main&gt; :t b
b :: b
*Main&gt; :p b
b = (_t1::b)
*Main&gt; seq b ()
()
*Main&gt; :t b
b :: Maybe Integer
*Main&gt; :t f
f :: Integer -&gt; Maybe Integer
*Main&gt; f 20
Just 20
*Main&gt; :delete *
*Main&gt; map f [1..5]
[Just 1,Just 2,Just 3,Just 4,Just 5]
</pre></div>
</div>
<p>[&#8211;ここまで&#8211; 実際の挙動に沿った非公式説明．]</p>
<p>最初の <code class="docutils literal"><span class="pre">f</span></code> の適用では <code class="docutils literal"><span class="pre">f</span></code> の結果の型を復元するために，型の再構築をもう少し行う必要がありました．
しかし，それ以降は <code class="docutils literal"><span class="pre">f</span></code> を通常の方法で自由に使うことができます．</p>
</div>
<div class="section" id="id33">
<h3>5.5.8. 制限<a class="headerlink" href="#id33" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">ブレークポイントで停止したとき，既に評価中の変数を評価しようとすると，2回目の評価はハングする．
その変数が評価中であることをGHCが知っていて，後の評価は先の結果を待ってからでないと続けられないからです．
先の評価はブレークポイントで停止しているので，もちろん結果は得られません．
評価がハングしたときは Ctrl-C で中断すれば，プロンプトに戻ることができます．</p>
<p>ありがちなのは，CAF(たとえば <code class="docutils literal"><span class="pre">main</span></code>)を評価していて，ブレークポイントで停止し，そのCAFの値を再びプロンプトで要求するという場合です．</p>
</li>
<li><p class="first">暗黙パラメータ(<a class="reference internal" href="glasgow_exts.html#implicit-parameters"><span>Implicit parameters</span></a> 参照)がブレイクポイントで利用できるのは，型が明示されている場合だけです．</p>
</li>
</ul>
</div>
</div>
<div class="section" id="ghci-invocation">
<span id="id34"></span><h2>5.6. GHCi の起動<a class="headerlink" href="#ghci-invocation" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-14"></span><p>GHCiは <code class="docutils literal"><span class="pre">ghci</span></code> または <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--interactive</span></code> というコマンドで起動します．
1つまたは複数のモジュールやファイル名をコマンド行で指定することもできます．
そうすると，GHCiはプロンプトで <code class="docutils literal"><span class="pre">:load</span> <span class="pre">モジュール名</span></code> と入力したとき同じように(<a class="reference internal" href="#ghci-commands"><span>GHCi のコマンド群</span></a> 参照)，指定されたモジュールやファイル(と，それらが依存するモジュール)をロードします．
たとえば、GHCiを起動して(Main.hsに最上位モジュールがある)プログラムをロードするには，
次のようにすればよい．</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghci Main.hs
</pre></div>
</div>
<p>GHCが受け付けるコマンドラインオプション(<a class="reference internal" href="using.html#using-ghc"><span>Using GHC</span></a> 参照)の大部分は対話モードでも有効です．
GHCiで有効でないものは見れば判ります．</p>
<div class="section" id="id35">
<h3>5.6.1. パッケージ<a class="headerlink" href="#id35" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-15"></span><p>ほとんどのパッケージ(<a class="reference internal" href="packages.html#using-packages"><span>Using Packages</span></a> 参照)は追加でフラグを指定しなくても利用できます．
最初に必要になったときに自動的ロードされます．</p>
<p>一方で，隠されたパッケージについては <a class="reference internal" href="phases.html#ghc-flag--package"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-package</span></code></a> フラグを使ってロードを要求する必要があります．</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghci -package ghc-8.0.2
GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help
Prelude&gt; :show packages
active package flags:
  -package ghc-8.0.2
</pre></div>
</div>
<p>以下のコマンドを使えば起動中のGHCiに新しいパッケージをロードできます．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :set -package ghc-8.0.2
package flags have changed, resetting and loading new packages...
Prelude&gt;
</pre></div>
</div>
<p>ただし，すでにロードされているモジュールが全て未ロードになり <code class="docutils literal"><span class="pre">Prelude</span></code> に戻されることになるので注意が必要です．</p>
</div>
<div class="section" id="id36">
<h3>5.6.2. 追加のライブラリ<a class="headerlink" href="#id36" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-16"></span><p>追加のライブラリは，コマンドラインから通常の <code class="docutils literal"><span class="pre">-llib</span></code> オプションを使って指定できます．
(ここでいうライブラリとは，他言語のオブジェクトコードのライブラリのことです．
Haskellソースのライブラリを使うことについては <a class="reference internal" href="#ghci-modules-filenames"><span>モジュールとファイル名</span></a> を参照してください．)
たとえば，「m」ライブラリをロードするには，次のようにします．</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghci -lm
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">.so</span></code>-形式の共有ライブラリを使うシステムでは，実際にロードされるライブラリは <code class="docutils literal"><span class="pre">liblib.so</span></code> です．
GHCiは以下の順にライブラリを探します．</p>
<ul class="simple">
<li><a class="reference internal" href="phases.html#ghc-flag--L"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-L</span></code></a> コマンドラインオプションで指定したパス．</li>
<li>システムの標準ライブラリ検索パス．これはシステムによっては環境変数 <span class="target" id="index-17"></span><code class="xref std std-envvar docutils literal"><span class="pre">LD_LIBRARY_PATH</span></code> を設定することで変更可能です．</li>
</ul>
<p><code class="docutils literal"><span class="pre">.dll</span></code>-形式の共有ライブラリを使うシステムでは，実際にロードされるライブラリは <code class="docutils literal"><span class="pre">lib.dll</span></code> です．
GHCi指定のライブラリが見つからなければ，ここでもエラーになります．</p>
<p>GHCi は単なるオブジェクトファイル(プラットフォームによって <code class="docutils literal"><span class="pre">.o</span></code> か <code class="docutils literal"><span class="pre">.obj</span></code> のどちらか)をコマンドラインで指定してロードできます．オブジェクトファイル名をコマンドラインに追加するだけです．</p>
<p><code class="docutils literal"><span class="pre">-l</span></code> オプションの順序は重要です．ライブラリ指定は，そのライブラリが依存しているライブラリよりも <em>前に</em> 書いておく必要があります(<a class="reference internal" href="phases.html#options-linker"><span>Options affecting linking</span></a> 参照)．</p>
</div>
</div>
<div class="section" id="ghci-commands">
<span id="id37"></span><h2>5.7. GHCi のコマンド群<a class="headerlink" href="#ghci-commands" title="Permalink to this headline">¶</a></h2>
<p>GHCi のコマンドはすべて「 <code class="docutils literal"><span class="pre">:</span></code> 」ではじまり，1つのコマンド名と0個以上のパラメータからなります．
コマンド名は短縮可能です．
短縮の結果曖昧になった場合は，よりよく使われるコマンドを優先します．</p>
<dl class="ghci-cmd">
<dt id="ghci-cmd-:abandon">
<code class="descname">:abandon</code><a class="headerlink" href="#ghci-cmd-:abandon" title="Permalink to this definition">¶</a></dt>
<dd><p>現在の評価を破棄します(これはブレイクポイントで停止しているときのみ有効)．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:add">
<code class="descname">:add[*] ⟨module⟩</code><a class="headerlink" href="#ghci-cmd-:add" title="Permalink to this definition">¶</a></dt>
<dd><p>⟨module⟩ を現在のターゲット集合に追加しリロードを実行します．
通常，可能ならそのモジュールのコンパイル済みコードをロードし，そうでなければ，そのモジュールはバイトコードにコンパイルします．
<code class="docutils literal"><span class="pre">*</span></code> 接頭辞を使えば，強制的にバイトコードとしてロードできます．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:all-types">
<code class="descname">:all-types</code><a class="headerlink" href="#ghci-cmd-:all-types" title="Permalink to this definition">¶</a></dt>
<dd><p>(<a class="reference internal" href="#ghci-cmd-:set +c"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+c</span></code></a> をアクティブにしておいてからロードされた)現在ロードしている式や（局所）束縛の型を収集したものを一覧にします．
このとき，それぞれの式の始点と終点を含むソースコード上の位置情報が同時に表示します．
以下はその表示例です．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">GhciTypes</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">all</span><span class="o">-</span><span class="n">types</span>
<span class="kt">GhciTypes</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">38</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">38</span><span class="p">,</span><span class="mi">24</span><span class="p">)</span><span class="kt">:</span> <span class="kt">Maybe</span> <span class="kt">Id</span>
<span class="kt">GhciTypes</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">29</span><span class="p">)</span><span class="kt">:</span> <span class="kt">Outputable</span> <span class="kt">SpanInfo</span>
<span class="kt">GhciTypes</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">29</span><span class="p">)</span><span class="kt">:</span> <span class="p">(</span><span class="kt">Rational</span> <span class="ow">-&gt;</span> <span class="kt">SpanInfo</span> <span class="ow">-&gt;</span> <span class="kt">SDoc</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Outputable</span> <span class="kt">SpanInfo</span>
</pre></div>
</div>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:back">
<code class="descname">:back ⟨n⟩</code><a class="headerlink" href="#ghci-cmd-:back" title="Permalink to this definition">¶</a></dt>
<dd><p>履歴を ⟨n⟩ ステップ戻ります．⟨n⟩ の指定が省略されれば，1ステップ戻ります．
GHCi のデバッグ機能に関してより詳しくは <a class="reference internal" href="#tracing"><span>トレースとヒストリ</span></a> ， <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:history"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:history</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:forward"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:forward</span></code></a> などを参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:break">
<code class="descname">:break [⟨identifier⟩ | [⟨module⟩] ⟨line⟩ [⟨column⟩]]</code><a class="headerlink" href="#ghci-cmd-:break" title="Permalink to this definition">¶</a></dt>
<dd><p>関数あるいは行を指定してそこにブレイクポイントを設定します．
<a class="reference internal" href="#setting-breakpoints"><span>ブレイクポイントの設定</span></a> を参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:browse">
<code class="descname">:browse[!] [[*] ⟨module⟩]</code><a class="headerlink" href="#ghci-cmd-:browse" title="Permalink to this definition">¶</a></dt>
<dd><p>⟨module⟩ からエクスポートされている識別子を表示します．
⟨module⟩ はGHCiにロードされているか，パッケージの要素でなければなりません．
⟨module⟩ が省略されれば，直近にロードされたモジュールを使います．</p>
<p>他のGHCiのコマンドと同様，出力は現在のGHCiのスコープ(<a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a>)で表示されます．</p>
<p>browseコマンドには2つの変種があります．</p>
<ul>
<li><p class="first"><code class="docutils literal"><span class="pre">*</span></code> 記号がモジュール名の前に置くと，その⟨module⟩のスコープにある <em>すべての</em> 識別子が（エクスポートされたものだけではなく）表示されます．</p>
<p><code class="docutils literal"><span class="pre">*</span></code>-形式の指定は解釈実行するモジュールにのみ有効です．
コンパイル済みモジュール(パッケージ由来のものを含めて)については <a class="reference internal" href="#ghci-cmd-:browse"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:browse</span></code></a> は <code class="docutils literal"><span class="pre">*</span></code>-形式ではない指定のみ有効です．</p>
</li>
<li><p class="first">データ構成子とクラスメソッドは通常そのデータ型あるいはクラス宣言の文脈で表示されます．
しかし <code class="docutils literal"><span class="pre">!</span></code> 記号をコマンドの後に付けると，すなわち <code class="docutils literal"><span class="pre">:browse!</span></code> のようにすると個別の一覧表示になります．
<code class="docutils literal"><span class="pre">!</span></code>-形式にするとコメントで各エントリーグループごとにコメント付きで表示します．
以下はその例です．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">browse</span><span class="o">!</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span>
<span class="c1">-- not currently imported</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">catMaybes</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">fromJust</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">fromMaybe</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">isJust</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">isNothing</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">listToMaybe</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">mapMaybe</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">maybeToList</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="c1">-- imported via Prelude</span>
<span class="nf">maybe</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
<span class="kt">Just</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
<span class="kt">Nothing</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span>
</pre></div>
</div>
<p>この出力は現在のセッションの文脈(すなわち <code class="docutils literal"><span class="pre">Prelude</span></code> の有効範囲)で，
最初の <code class="docutils literal"><span class="pre">Data.Maybe</span></code> 由来の項目グループは有効範囲にないことを示しています
(ただし，GHCiのセッションでは完全修飾すれば，これらの項目は利用可能です．
<a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a> を参照)．
しかし，2つめの項目グループは(<code class="docutils literal"><span class="pre">Prelude</span></code> 経由で)有効範囲内にあり，
修飾しなくても，あるいは <code class="docutils literal"><span class="pre">Prelude.</span></code> という修飾をつけて使えるということを示しています．</p>
</li>
</ul>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:cd">
<code class="descname">:cd ⟨dir⟩</code><a class="headerlink" href="#ghci-cmd-:cd" title="Permalink to this definition">¶</a></dt>
<dd><p>現在の作業ディレクトリを ⟨dir⟩ に変更します．&#8221;<code class="docutils literal"><span class="pre">~</span></code>&#8220;記号を ⟨dir⟩ の先頭に付ければ
この記号は環境変数 <span class="target" id="index-18"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOME</span></code> の内容に置き換ります．
現在の作業ディレクトリを表示する <a class="reference internal" href="#ghci-cmd-:show paths"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">paths</span></code></a> コマンドを参照してください．</p>
<p>注意: 現在の作業ディレクトリを変更すると，現在ロードされているモジュールはすべてアンロードされます．
このようになっている理由は，検索パスは相対ディレクトリで表現されるのが普通で，
セッション途中での検索パス変更はサポートされていないからです．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:cmd">
<code class="descname">:cmd ⟨expr⟩</code><a class="headerlink" href="#ghci-cmd-:cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>⟨expr⟩ を <code class="docutils literal"><span class="pre">IO</span> <span class="pre">String</span></code> 型のコンピュテーションを実行し，
実行結果の文字列をGHCiのコマンドのリストとして実行します．
複数のコマンドは改行で区切られます．
<a class="reference internal" href="#ghci-cmd-:cmd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cmd</span></code></a> コマンドは <a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> や <a class="reference internal" href="#ghci-cmd-:set stop"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">stop</span></code></a> とともに使うのが便利です．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:complete">
<code class="descname">:complete ⟨type⟩ [⟨n⟩-][⟨m⟩] ⟨string-literal⟩</code><a class="headerlink" href="#ghci-cmd-:complete" title="Permalink to this definition">¶</a></dt>
<dd><p>このコマンドを使えば，端末からではなくパイプでGHCiと繋いているときでも，コマンド補完を要求できます．
この機能はGHCiの補完をテキストエディタやIDEに統合するために設計してあります．</p>
<p><a class="reference internal" href="#ghci-cmd-:complete"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:complete</span></code></a> は ⟨n⟩ 番目から ⟨m⟩ 番目までの補完候補を表示します．
補完の対象となるのは ⟨type⟩ で指定された補完ドメインの部分入力 ⟨string-literal⟩ です．
現時点では <code class="docutils literal"><span class="pre">repl</span></code> ドメインのみサポートしています．
このドメインはGHCiの入力プロンプトでのみ対話的に提供するものです．</p>
<p>⟨n⟩ および ⟨m⟩ は省略するとデフォルトでそれぞれ最初の補完候補および最後の補完候補を指します．
引数で指定した範囲よりも実際にその範囲にある候補数が小さい場合は，⟨n⟩ および ⟨m⟩ は暗黙に実際の候補数に丸められます．</p>
<p><a class="reference internal" href="#ghci-cmd-:complete"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:complete</span></code></a> の出力は，空白で区切られた以下の3つのフィールドを含むヘッダ行で始まります．</p>
<ul class="simple">
<li>表示される候補の数  <code class="docutils literal"><span class="pre">l</span></code> を表す整数</li>
<li>利用可能な全ての補完の数を表す整数</li>
<li>返される補完後方に付加される共通接頭辞を表す文字リテラル</li>
</ul>
<p>ヘッダ行のあとに ⟨l⟩ 行が続き，各行は1つの補完候補が引用符付きの文字列リテラルとしてエンコードされています．
いろいろな場合の起動例を以下に示しましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt;
:complete repl 0 &quot;&quot;
0 506 &quot;&quot;
Prelude&gt; :complete repl 5 &quot;import For&quot;
5 21 &quot;import &quot;
&quot;Foreign&quot;
&quot;Foreign.C&quot;
&quot;Foreign.C.Error&quot;
&quot;Foreign.C.String&quot;
&quot;Foreign.C.Types&quot;
Prelude&gt; :complete repl 5-10 &quot;import For&quot;
6 21 &quot;import &quot;
&quot;Foreign.C.Types&quot;
&quot;Foreign.Concurrent&quot;
&quot;Foreign.ForeignPtr&quot;
&quot;Foreign.ForeignPtr.Safe&quot;
&quot;Foreign.ForeignPtr.Unsafe&quot;
&quot;Foreign.Marshal&quot;
Prelude&gt; :complete repl 20- &quot;import For&quot;
2 21 &quot;import &quot;
&quot;Foreign.StablePtr&quot;
&quot;Foreign.Storable&quot;
Prelude&gt; :complete repl &quot;map&quot;
4 4 &quot;&quot;
&quot;map&quot;
&quot;mapM&quot;
&quot;mapM_&quot;
&quot;mappend&quot;
</pre></div>
</div>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:continue">
<code class="descname">:continue</code><a class="headerlink" href="#ghci-cmd-:continue" title="Permalink to this definition">¶</a></dt>
<dd><p>ブレイクポイントで停止しているとき，現在の評価を再開します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:ctags">
<code class="descname">:ctags [⟨filename⟩]</code><a class="headerlink" href="#ghci-cmd-:ctags" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghci-cmd-:ctags"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:ctags</span></code></a> はVi系エディタ用タグファイルを生成します．
<a class="reference internal" href="#ghci-cmd-:etags"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:etags</span></code></a> はEmacs系エディタ用です．
⟨filename⟩ を指定しなかった場合は，デフォルトでそれぞれ <code class="docutils literal"><span class="pre">tags</span></code> あるいは <code class="docutils literal"><span class="pre">TAGS</span></code> をファイル名として使います．
現在ロードしているモジュール内のすべての関数，構成子，型のタグを生成します．
これらのコマンドが有効に働くためにはすべてのモジュールが解釈実行されているものでなければなりません．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:def">
<code class="descname">:def[!] ⟨name⟩ ⟨expr⟩</code><a class="headerlink" href="#ghci-cmd-:def" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> はGHCi内で新しいコマンド(あるいはマクロ)を定義するのに使います．
<code class="docutils literal"><span class="pre">:def</span> <span class="pre">⟨name⟩</span> <span class="pre">⟨expr⟩</span></code> というコマンドはHaskellの式 ⟨expr⟩ で実装した新しいGHCiコマンド <code class="docutils literal"><span class="pre">:name</span></code> を定義します．
この式 ⟨expr⟩ の型は <code class="docutils literal"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">String</span></code> でなくてはなりません．
GHCiのプロンプトで <code class="docutils literal"><span class="pre">:name</span> <span class="pre">args</span></code> を入力すると，式 <code class="docutils literal"><span class="pre">(name</span> <span class="pre">args)</span></code> が実行されます．
その結果の <code class="docutils literal"><span class="pre">String</span></code> をとり，それを再度GHCiにコマンド列として戻します．
結果のコマンド文字列は &#8220;<code class="docutils literal"><span class="pre">\n</span></code>&#8221; で区切られていなければなりません．</p>
<p>これは少々ややこしいので，例をいくつか挙げましょう．
まず，次に示す新しいコマンドは引数をとらず，結果も生成せず，単に現在の日時を出力するだけのものです．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; import Data.Time
Prelude Data.Time&gt; let date _ = getCurrentTime &gt;&gt;= putStrLn . formatTime defaultTimeLocale rfc822DateFormat &gt;&gt; return &quot;&quot;
Prelude Data.Time&gt; :def date date
Prelude Data.Time&gt; :date
Thu, 23 Mar 2017 06:21:10 UTC
</pre></div>
</div>
<p>次は，引数を1つとるコマンドの例です．
これは <a class="reference internal" href="#ghci-cmd-:cd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cd</span></code></a>: コマンドの再実装です．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; import System.Directory
Prelude System.Directory&gt; let mycd d = setCurrentDirectory d &gt;&gt; return &quot;&quot;
Prelude System.Directory&gt; :def mycd mycd
Prelude System.Directory&gt; :mycd ..
</pre></div>
</div>
<p>あるいは，現在のディレクトリで「 <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-o</span> <span class="pre">foo</span> <span class="pre">Main</span></code> 」を起動する単純な方法を定義できます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :def make (\_ -&gt; return &quot;:! ghc -o foo Main&quot;)
</pre></div>
</div>
<p>GHCiへの入力をファイルから読み込むコマンドを定義することもできます．
これは，あらかじえ決った束縛を繰り返しGHCiセッションにロードしたいとうとき便利でしょう．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :def . readFile
Prelude&gt; :. cmds.ghci
</pre></div>
</div>
<p>このコマンドを <code class="docutils literal"><span class="pre">:.</span></code> としたのは同じことを Unix シェルの「 <code class="docutils literal"><span class="pre">.</span></code> 」とのアナロジーです．</p>
<p><code class="docutils literal"><span class="pre">:def</span></code> を単独で入力すると，現在定義されているマクロの一覧が表示されます．
既に存在するコマンド名を再定義しようとするとエラーになりますが，
<code class="docutils literal"><span class="pre">:def!</span></code> のように感嘆符をつけると古い方は黙って上書きされます．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:delete">
<code class="descname">:delete * | ⟨num⟩ ...</code><a class="headerlink" href="#ghci-cmd-:delete" title="Permalink to this definition">¶</a></dt>
<dd><p>1つ以上のブレイクポイントを番号で指定して削除します．
(それぞれのブレイクポイントの番号を知るには <a class="reference internal" href="#ghci-cmd-:show breaks"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">breaks</span></code></a> を使います．)
<code class="docutils literal"><span class="pre">*</span></code> を使えば，すべてのブレイクポイントが削除されます．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:edit">
<code class="descname">:edit ⟨file⟩</code><a class="headerlink" href="#ghci-cmd-:edit" title="Permalink to this definition">¶</a></dt>
<dd><p>エディタを開いてファイル ⟨file⟩ を編集します． ⟨file⟩ を省略した場合は直近にロードされたモジュールを編集します．
直近のロードでエラーが起きたときは，カーソルが最初のエラーが起きた箇所に置かれます．
エディタは，環境変数 <span class="target" id="index-19"></span><code class="xref std std-envvar docutils literal"><span class="pre">EDITOR</span></code> で指定されるものか，環境変数の設定がない場合はシステムのデフォルトエディタが起動します
使用するエディタは <a class="reference internal" href="#ghci-cmd-:set editor"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">editor</span></code></a> を使って変更できます．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:etags">
<code class="descname">:etags</code><a class="headerlink" href="#ghci-cmd-:etags" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghci-cmd-:ctags"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:ctags</span></code></a> を参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:force">
<code class="descname">:force ⟨identifier⟩ ...</code><a class="headerlink" href="#ghci-cmd-:force" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> と同じように ⟨identifier⟩ の値を表示します．
<a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> とは違い <a class="reference internal" href="#ghci-cmd-:force"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:force</span></code></a> は値をたどっていく過程で出会ったサンクを評価しますので，
例外あるいは無限ループが発生したり，次のブレイクポイントに当たる(これは無視しますが，その旨を表示する)ことがあります．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:forward">
<code class="descname">:forward ⟨n⟩</code><a class="headerlink" href="#ghci-cmd-:forward" title="Permalink to this definition">¶</a></dt>
<dd><p>履歴を ⟨n⟩ ステップ前進します． ⟨n⟩ の指定が省略されれば，1ステップ前進します．
GHCi のデバッグ機能に関してより詳しくは <a class="reference internal" href="#tracing"><span>トレースとヒストリ</span></a> ， <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:history"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:history</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:back"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:back</span></code></a> を参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:help">
<code class="descname">:help</code><a class="headerlink" href="#ghci-cmd-:help" title="Permalink to this definition">¶</a></dt>
<dt id="ghci-cmd-:?">
<code class="descname">:?</code><a class="headerlink" href="#ghci-cmd-:?" title="Permalink to this definition">¶</a></dt>
<dd><p>利用可能なコマンドの一覧を表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:">
<code class="descname">:</code><a class="headerlink" href="#ghci-cmd-:" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-20">直近のコマンドを反復します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:history">
<code class="descname">:history [num]</code><a class="headerlink" href="#ghci-cmd-:history" title="Permalink to this definition">¶</a></dt>
<dd><p>評価ステップの履歴を表示します．数を指定すると，その数ぶんのステップを表示します(デフォルトは20)．
<a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> (<a class="reference internal" href="#tracing"><span>トレースとヒストリ</span></a> 参照)と組み合わせて使います．
GHCi が保存する履歴のエントリー数を設定するには <a class="reference internal" href="#ghc-flag--fghci-hist-size"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fghci-hist-size</span></code></a> フラグを使います．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:info">
<code class="descname">:info[!] ⟨name⟩</code><a class="headerlink" href="#ghci-cmd-:info" title="Permalink to this definition">¶</a></dt>
<dd><p>与えられた名前についての情報を表示します．
たとえば， ⟨name⟩ がクラスなら，そのクラスのメソッドとその型が表示される．
⟨name⟩ が型構成子の場合はその定義が表示され，関数なら型が表示されます．
また ⟨name⟩ がソースファイルからロードさればものなら，GHCiはその定義のソースコードの位置も表示します．</p>
<p>型およびクラスについては、それに言及するインスタンスもまとめて表示します．
無関係な情報が表示されることがないよう，インスタンスは，(a)その頭部が ⟨name⟩ に言及しており，
(b)そのインスタンスで言及されているものが全て <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> あるいは <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a>
コマンドの結果として(修飾されているかいないかにかかわらず)スコープにある場合にのみ表示されます．</p>
<p><code class="docutils literal"><span class="pre">:info!</span></code> コマンドも同様に動作しますが，(b)の制限はなく ⟨name⟩ に言及するインスタンスでスコープにあるものを全て表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:issafe">
<code class="descname">:issafe [⟨module⟩]</code><a class="headerlink" href="#ghci-cmd-:issafe" title="Permalink to this definition">¶</a></dt>
<dd><p>与えられたモジュール(省略された場合は現在のモジュール)に間する Safe Haskell 情報を表示します．
モジュールとそれを含むパッケージの信頼のタイプの情報が表示されます．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:kind">
<code class="descname">:kind[!] ⟨type⟩</code><a class="headerlink" href="#ghci-cmd-:kind" title="Permalink to this definition">¶</a></dt>
<dd><p>⟨type⟩ のカインドを推論し表示します． ⟨type⟩ は任意の型式で <code class="docutils literal"><span class="pre">Either</span> <span class="pre">Int</span></code> のような型構成子の部分適用であってもかまいません．
実は <a class="reference internal" href="#ghci-cmd-:kind"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:kind</span></code></a> では通常はできない型シノニムの部分適用が書けるので以下のようなことができます．</p>
<div class="highlight-none"><div class="highlight"><pre>ghci&gt; type T a b = (a,b,a)
ghci&gt; :k T Int Bool
T Int Bool :: *
ghci&gt; :k T
T :: * -&gt; * -&gt; *
ghci&gt; :k T Int
T Int :: * -&gt; *
</pre></div>
</div>
<p>追加で「 <code class="docutils literal"><span class="pre">!</span></code> 」を指定すると GHCi は型関数適用を評価しその結果を表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:list">
<code class="descname">:list ⟨identifier⟩</code><a class="headerlink" href="#ghci-cmd-:list" title="Permalink to this definition">¶</a></dt>
<dd><p>⟨identifier⟩ が与えられればその定義周辺を表示し，与えられなければ現在のブレイクポイント周辺を表示します．
この識別子は解釈実行するモジュールで定義されている必要があります．
出力デバイスが対応していれば，GHCiは注目している部分式を太字で強調表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:list [⟨module⟩]">
<code class="descname">:list [⟨module⟩] ⟨line⟩</code><a class="headerlink" href="#ghci-cmd-:list [⟨module⟩]" title="Permalink to this definition">¶</a></dt>
<dd><p>⟨module⟩ の与えられた行番号周辺のソースコードを表示します．
このモジュールは解釈実行するものでなければなりません．
出力デバイスが対応していれば，GHCiは注目している部分式を太字で強調表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:load">
<code class="descname">:load[!] [*]⟨module⟩</code><a class="headerlink" href="#ghci-cmd-:load" title="Permalink to this definition">¶</a></dt>
<dd><p>指定した ⟨module⟩ および，それが依存するすべてのモジュールを再帰的にロードします．
個々の ⟨module⟩ はモジュール名またはファイル名でなければならない．
また，パッケージ内のモジュールの名前を指定することはできません．</p>
<p>以前にロードだれていたモジュールは，パッケージ中のものを除いて，忘れられてしまいます．
この新しいモジュールの集合をターゲット集合といいます．
<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> を引数なしで使うと，現在ロードされているモジュールおよび束縛を全て未ロード状態にできることに注意してください．</p>
<p>通常可能ならばコンパイル済みのコードをロードしますが，そうでなければ，そのモジュールはバイトコードにコンパイルします．
接頭辞 <code class="docutils literal"><span class="pre">*</span></code> を使えば，強制的にモジュールをバイトコードとしてロードします．</p>
<p>「 <code class="docutils literal"><span class="pre">!</span></code> 」を追加するとロード中の型エラーが警告になります．
こうすることで，型エラーになる定義を含むモジュールであっても，正しい部分だけを使うことができます．
実際には，ロード前に「-fdefer-type-errors」フラグを設定して，
ロード以前にそのフラグが設定されていなければ，ロード後このフラグを未設定にもどしています．
動機と詳細については <a class="reference internal" href="glasgow_exts.html#defer-type-errors"><span>Deferring type errors to runtime</span></a> を参照してください．</p>
<p><a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> コマンドを発行後，現在の文脈は以下のようになります．</p>
<ul class="simple">
<li>⟨module⟩ のロードが成功したらその ⟨module⟩．</li>
<li>そうでなければ，今回の <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> コマンドの結果ロードが成功した他のモジュールがあればそのモジュール．</li>
<li>そうでなければ <code class="docutils literal"><span class="pre">Prelude</span></code></li>
</ul>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:loc-at">
<code class="descname">:loc-at ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code><a class="headerlink" href="#ghci-cmd-:loc-at" title="Permalink to this definition">¶</a></dt>
<dd><p>与えられたソースコードの範囲にある ⟨name⟩ の定義場所を探します．
以下はその例です．</p>
<div class="highlight-none"><div class="highlight"><pre>X&gt; :loc-at X.hs 6 14 6 16 mu
X.hs:(8,7)-(8,9)
</pre></div>
</div>
<p>このコマンドはGHCiとテキストエディタやIDEを統合したときに，定義位置へ移動する機能を提供するのに使えます．</p>
<p><code class="docutils literal"><span class="pre">:loc-at</span></code> コマンドを使うためには <a class="reference internal" href="#ghci-cmd-:set +c"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+c</span></code></a> を設定しておく必要があります．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:main">
<code class="descname">:main ⟨arg1⟩ ... ⟨argn⟩</code><a class="headerlink" href="#ghci-cmd-:main" title="Permalink to this definition">¶</a></dt>
<dd><p>プログラムをコンパイルし実行するときに <code class="docutils literal"><span class="pre">getArgs</span></code> を使ってコマンドライン引数にアクセスできます．
しかし，GHCiでテストしているときには <code class="docutils literal"><span class="pre">main</span></code> にコマンドライン引数を簡単には渡せません．
それは <code class="docutils literal"><span class="pre">main</span></code> は直接引数を取らないからです．</p>
<p>そこで <a class="reference internal" href="#ghci-cmd-:main"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:main</span></code></a> コマンドを使います．
このコマンドは有効範囲にある <code class="docutils literal"><span class="pre">main</span></code> をとにかく実行し，任意の引数をコマンドライン引数とします．
以下がその実行例です．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; main = System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :main foo bar
[&quot;foo&quot;,&quot;bar&quot;]
</pre></div>
</div>
<p>2重引用符を使うことで，スペースを含む引数を扱えます．
引数はHaskellの文字列のリストになり，Haskell内でそのように処理できます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :main foo &quot;bar baz&quot;
[&quot;foo&quot;,&quot;bar baz&quot;]
Prelude&gt; :main [&quot;foo&quot;, &quot;bar baz&quot;]
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">-main-is</span></code> フラグを設定するか <a class="reference internal" href="#ghci-cmd-:run"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:run</span></code></a> コマンドを使えば <code class="docutils literal"><span class="pre">main</span></code> 以外も実行できます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; foo = putStrLn &quot;foo&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; bar = putStrLn &quot;bar&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :set -main-is foo
Prelude&gt; :main foo &quot;bar baz&quot;
foo
[&quot;foo&quot;,&quot;bar baz&quot;]
Prelude&gt; :run bar [&quot;foo&quot;, &quot;bar baz&quot;]
bar
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:module">
<code class="descname">:module +|- [*]⟨mod1⟩ ...</code><a class="headerlink" href="#ghci-cmd-:module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-import">
<code class="descname">import ⟨mod⟩</code><a class="headerlink" href="#ghci-cmd-import" title="Permalink to this definition">¶</a></dt>
<dd><p>プロンプトに入力する文(statement)用の文脈を設定または変更します．
<code class="docutils literal"><span class="pre">import</span> <span class="pre">mod</span></code> の形式は <code class="docutils literal"><span class="pre">:module</span> <span class="pre">+mod</span></code> と同等です．
詳しいことについては <a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a> を参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:print">
<code class="descname">:print ⟨names⟩</code><a class="headerlink" href="#ghci-cmd-:print" title="Permalink to this definition">¶</a></dt>
<dd><p>評価を強制することなく値を表示します．
<a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> は型が不明もしくは部分的にしか判明していない値についても使用できます．
ブレイクポイントにおける，多相型の局所変数がこれにあたります．
<a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> は実行時の値を調査しつつ，その値を型を再構成しようとします．
そして可能であれば型を精密にしようとします．
未評価の部分(すなわちサンク)に出会うと <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> は <code class="docutils literal"><span class="pre">_t</span></code> で始まる名前の新しい変数をそれぞれのサンクに束縛します．
詳しくは <a class="reference internal" href="#breakpoints"><span>ブレイクポイントと変数内容の表示</span></a> を参照してください．
<a class="reference internal" href="#ghci-cmd-:sprint"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:sprint</span></code></a> という新しい変数は束縛しませんが，それ以外は同じコマンドも参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:quit">
<code class="descname">:quit</code><a class="headerlink" href="#ghci-cmd-:quit" title="Permalink to this definition">¶</a></dt>
<dd><p>GHCiを終了します．プロンプトで <code class="kbd docutils literal"><span class="pre">Control-D</span></code> をタイプしても終了できます．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:reload">
<code class="descname">:reload[!]</code><a class="headerlink" href="#ghci-cmd-:reload" title="Permalink to this definition">¶</a></dt>
<dd><p>現在のターゲット集合(<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> 参照)とそれらが依存するモジュールのうち，
変更のあったものがあれば，ターゲット集合を再ロードしようと試みます．
結果として，新しいモジュールがロードされたり，ターゲットから間接的に必要とされなくなったモジュールが外れたりする可能性がある
ことに注意してください．</p>
<p>「 <code class="docutils literal"><span class="pre">!</span></code> 」を追加するとロード中の型エラーが警告になります．
こうすることで，型エラーになる定義を含むモジュールであっても，正しい部分だけを使うことができます．
実際には，ロード前に「-fdefer-type-errors」フラグを設定して，
ロード以前にそのフラグが設定されていなければ，ロード後このフラグを未設定にもどしています．
動機と詳細については <a class="reference internal" href="glasgow_exts.html#defer-type-errors"><span>Deferring type errors to runtime</span></a> を参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:run">
<code class="descname">:run</code><a class="headerlink" href="#ghci-cmd-:run" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghci-cmd-:main"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:main</span></code></a> を参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:script">
<code class="descname">:script [⟨n⟩] ⟨filename⟩</code><a class="headerlink" href="#ghci-cmd-:script" title="Permalink to this definition">¶</a></dt>
<dd><p>指定したファイルの行を一連のGHCiコマンドとて実行します．
<a class="reference internal" href="#ghci-cmd-:set +m"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+m</span></code></a> で設定される複数行コマンドと同時に使えます．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set">
<code class="descname">:set [⟨option⟩ ...]</code><a class="headerlink" href="#ghci-cmd-:set" title="Permalink to this definition">¶</a></dt>
<dd><p>さまざまなオプションを設定します．
利用可能なオプション一覧については <a class="reference internal" href="#ghci-set"><span>:set コマンドと :seti コマンド</span></a> を参照して下さい．
また，GHCi固有のフラグ一覧については <a class="reference internal" href="flags.html#interactive-mode-options"><span>Interactive-mode options</span></a> を参照してください．
<a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> コマンドを単独で使うと，現在設定されているオプションが表示されます．
また，それとは分けて，動的フラグの設定状況も一覧表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set args">
<code class="descname">:set args ⟨arg⟩</code><a class="headerlink" href="#ghci-cmd-:set args" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-21">プログラムが <code class="docutils literal"><span class="pre">System.getArgs</span></code> を呼んだときに返される引数のリストを設定します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set editor">
<code class="descname">:set editor ⟨cmd⟩</code><a class="headerlink" href="#ghci-cmd-:set editor" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghci-cmd-:edit"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:edit</span></code></a> コマンドで使うエディタ起動を ⟨cmd⟩ に設定する．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set prog">
<code class="descname">:set prog ⟨prog⟩</code><a class="headerlink" href="#ghci-cmd-:set prog" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-22">プログラムが <code class="docutils literal"><span class="pre">System.getProgName</span></code> を呼んだときに返される文字列を設定します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set prompt">
<code class="descname">:set prompt ⟨prompt⟩</code><a class="headerlink" href="#ghci-cmd-:set prompt" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-23">GHCiのプロンプトとして使う文字列を設定します．
⟨prompt⟩ の中では <code class="docutils literal"><span class="pre">%s</span></code> という並びは現在のスコープにあるモジュール名に置き換え，
<code class="docutils literal"><span class="pre">%l</span></code> は現在のプロンプトの行番号(コンパイラメッセージで参照されるもの)に置き換え，
<code class="docutils literal"><span class="pre">%%</span></code> は <code class="docutils literal"><span class="pre">%</span></code> に置き換えます．
⟨prompt⟩ が <code class="docutils literal"><span class="pre">&quot;</span></code> で始まる場合，Haskellの <code class="docutils literal"><span class="pre">String</span></code> としてパースします．
そうでない場合はそのまま文字列として扱います．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set prompt2">
<code class="descname">:set prompt2 ⟨prompt⟩</code><a class="headerlink" href="#ghci-cmd-:set prompt2" title="Permalink to this definition">¶</a></dt>
<dd><p>(<code class="xref std std-ghci-cmd docutils literal"><span class="pre">:{</span></code> コマンドを使うときに使う)GHCiの継続プロンプトとして使う文字列を設定します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set stop">
<code class="descname">:set stop ⟨num⟩ ⟨cmd⟩</code><a class="headerlink" href="#ghci-cmd-:set stop" title="Permalink to this definition">¶</a></dt>
<dd><p>ブレイクポイントに当たったとき，または履歴中で新しい項目が選択したときに実行するコマンドを設定します．
<a class="reference internal" href="#ghci-cmd-:set stop"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">stop</span></code></a> の最もよくある使い方は，現在の位置のソースコードを表示するこです．
たとえば <code class="docutils literal"><span class="pre">:set</span> <span class="pre">stop</span> <span class="pre">:list</span></code> のようにします．</p>
<p>コマンドの前に数値を指定すると，その番号のブレイクポイントにあたったときにだけそのコマンドを実行します．
これは便利な機能です．たとえば <code class="docutils literal"><span class="pre">:set</span> <span class="pre">stop</span> <span class="pre">1</span> <span class="pre">:continue</span></code> は1番のブレイクポイントを無効にするのと同じことです．
1番のブレイクポイントに当ったときはいつも <a class="reference internal" href="#ghci-cmd-:continue"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:continue</span></code></a> が実行されるからです
(ただし，ブレイクポイントに当ったとのメッセージは出力されます)．
さらに <a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> と <a class="reference internal" href="#ghci-cmd-:cmd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cmd</span></code></a> をうまく使って <a class="reference internal" href="#ghci-cmd-:set stop"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">stop</span></code></a> で条件付ブレイクポイントを実装することもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :def cond \expr -&gt; return (&quot;:cmd if (&quot; ++ expr ++ &quot;) then return \&quot;\&quot; else return \&quot;:continue\&quot;&quot;)
*Main&gt; :set stop 0 :cond (x &lt; 3)
</pre></div>
</div>
<p>同様の技法を使えば，指定した回数だけブレイクポイントを無視することもできます．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:seti">
<code class="descname">:seti [⟨option⟩ ...]</code><a class="headerlink" href="#ghci-cmd-:seti" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> と似ていますが <a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> で設定されたオプションはプロンプトに入力された式とコマンドのみに影響し，
<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> でロードされたモジュールには影響しません
(対照的に <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> で設定されたオプションはあらゆるところで適用されます)．
<a class="reference internal" href="#ghci-interactive-options"><span>対話式評価についてのみのオプションを設定する</span></a> を参照してください．</p>
<p>引数がなければ，プロンプトに入力される式とコマンドに適用されるオプションの集合を表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show bindings">
<code class="descname">:show bindings</code><a class="headerlink" href="#ghci-cmd-:show bindings" title="Permalink to this definition">¶</a></dt>
<dd><p>プロンプトで導入した束縛とその型を表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show breaks">
<code class="descname">:show breaks</code><a class="headerlink" href="#ghci-cmd-:show breaks" title="Permalink to this definition">¶</a></dt>
<dd><p>現在有効なブレイクポイントを一覧表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show context">
<code class="descname">:show context</code><a class="headerlink" href="#ghci-cmd-:show context" title="Permalink to this definition">¶</a></dt>
<dd><p>ブレイクポイントで停止している，有効な評価の一覧を表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show imports">
<code class="descname">:show imports</code><a class="headerlink" href="#ghci-cmd-:show imports" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="docutils literal"><span class="pre">import</span></code> 文や <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> コマンドによって作った現在な現在有効なインポートを表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show modules">
<code class="descname">:show modules</code><a class="headerlink" href="#ghci-cmd-:show modules" title="Permalink to this definition">¶</a></dt>
<dd><p>現在ロードされているモジュールの一覧を表示する．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show packages">
<code class="descname">:show packages</code><a class="headerlink" href="#ghci-cmd-:show packages" title="Permalink to this definition">¶</a></dt>
<dd><p>現在ロードされているパッケージの一覧と現在有効なパッケージフラグを表示します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show paths">
<code class="descname">:show paths</code><a class="headerlink" href="#ghci-cmd-:show paths" title="Permalink to this definition">¶</a></dt>
<dd><p>ソースファイルの検索パス一覧(<code class="docutils literal"><span class="pre">-i</span></code> オプションで指定)と現在の作業ディレクトリ(<a class="reference internal" href="#ghci-cmd-:cd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cd</span></code></a> コマンドで設定)を表示する．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show language">
<code class="descname">:show language</code><a class="headerlink" href="#ghci-cmd-:show language" title="Permalink to this definition">¶</a></dt>
<dd><p>ソースファイルに対して現在有効になっている言語フラグを表示する．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:showi language">
<code class="descname">:showi language</code><a class="headerlink" href="#ghci-cmd-:showi language" title="Permalink to this definition">¶</a></dt>
<dd><p>プロンプトで入力される式に対して現在有効になっている言語フラグを表示します
(<a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> も参照してください)．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show">
<code class="descname">:show [args|prog|prompt|editor|stop]</code><a class="headerlink" href="#ghci-cmd-:show" title="Permalink to this definition">¶</a></dt>
<dd><p>指定した設定を表示します(<a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> 参照)．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:sprint">
<code class="descname">:sprint ⟨expr⟩</code><a class="headerlink" href="#ghci-cmd-:sprint" title="Permalink to this definition">¶</a></dt>
<dd><p>評価を強制せずに値を表示します．
<a class="reference internal" href="#ghci-cmd-:sprint"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:sprint</span></code></a> は未評価の部分項が新しい変数に束縛せず，単に <code class="docutils literal"><span class="pre">_</span></code> と表す以外は，
<a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> と同じです．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:step">
<code class="descname">:step [⟨expr⟩]</code><a class="headerlink" href="#ghci-cmd-:step" title="Permalink to this definition">¶</a></dt>
<dd><p>すべてのブレイクポイントを有効にして，式を単一ステップモードでの評価を開始します．
このモードでは，簡約1ステップごとに評価が停止し局所変数を確認できます．
⟨expr⟩ が与えなかった場合は，最後のブレイクポイントから評価を開始します．
<a class="reference internal" href="#single-stepping"><span>ステップ実行</span></a> を参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:steplocal">
<code class="descname">:steplocal</code><a class="headerlink" href="#ghci-cmd-:steplocal" title="Permalink to this definition">¶</a></dt>
<dd><p>現在の最上位束縛の中にあるブレイクポイントのみを有効にした状態で最後のブレイクポイントから評価を再開します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:stepmodule">
<code class="descname">:stepmodule</code><a class="headerlink" href="#ghci-cmd-:stepmodule" title="Permalink to this definition">¶</a></dt>
<dd><p>現在のモジュール内にあるブレイクポイントのみを有効にした状態で，最後のブレイクポイントから評価を再開します．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:trace">
<code class="descname">:trace ⟨expr⟩</code><a class="headerlink" href="#ghci-cmd-:trace" title="Permalink to this definition">¶</a></dt>
<dd><p>与えられた式を評価(式を与えられなかった場合は直近のブレークポイントから再開)しますが，
後で <a class="reference internal" href="#ghci-cmd-:history"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:history</span></code></a> で観察できるように評価ステップのログを残します．
<a class="reference internal" href="#tracing"><span>トレースとヒストリ</span></a> を参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:type">
<code class="descname">:type ⟨expression⟩</code><a class="headerlink" href="#ghci-cmd-:type" title="Permalink to this definition">¶</a></dt>
<dd><p>⟨expression⟩ の型を推論し表示します．
多相型には明示的な全称量化が加えられます．
推論に際して，単相制限は <em>適用されません</em> ．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:type-at">
<code class="descname">:type-at ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code><a class="headerlink" href="#ghci-cmd-:type-at" title="Permalink to this definition">¶</a></dt>
<dd><p>当該モジュール内で与えられた範囲の型の推論結果を報告表示します．</p>
<div class="highlight-none"><div class="highlight"><pre>*X&gt; :type-at X.hs 6 6 6 7 f
Int -&gt; Int
</pre></div>
</div>
<p>このコマンドはGHCiとテキストエディタあるいはIDEを統合するさいに指定場所の型を示す機能として使えます．</p>
<p>最後の文字列パラメータはその範囲がすでに変更済みの場合，たとえば，ファイルが変更されコードが移動した場合に役に立ちます．
検索と同じように <a class="reference internal" href="#ghci-cmd-:type-at"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type-at</span></code></a> はより一般的な <a class="reference internal" href="#ghci-cmd-:type"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span></code></a> にフォールバックします．</p>
<p><a class="reference internal" href="#ghci-cmd-:type-at"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type-at</span></code></a> コマンドを使うためには <a class="reference internal" href="#ghci-cmd-:set +c"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+c</span></code></a> を設定しておく必要があります．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:undef">
<code class="descname">:undef ⟨name⟩</code><a class="headerlink" href="#ghci-cmd-:undef" title="Permalink to this definition">¶</a></dt>
<dd><p>ユーザ定義のコマンド ⟨name⟩ (上述 <a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> を参照)を未定義にします．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:unset">
<code class="descname">:unset ⟨option⟩</code><a class="headerlink" href="#ghci-cmd-:unset" title="Permalink to this definition">¶</a></dt>
<dd><p>ある種のオプションを未設定にします．利用可能なオプション一覧については <a class="reference internal" href="#ghci-set"><span>:set コマンドと :seti コマンド</span></a> を参照してください．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:uses">
<code class="descname">:uses ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code><a class="headerlink" href="#ghci-cmd-:uses" title="Permalink to this definition">¶</a></dt>
<dd><p>指定したモジュール中の与えられた位置にあるものの当該モジュール内での使われている位置を報告します．</p>
<div class="highlight-none"><div class="highlight"><pre>:uses GhciFind.hs 53 66 53 70 name
GhciFind.hs:(46,25)-(46,29)
GhciFind.hs:(47,37)-(47,41)
GhciFind.hs:(53,66)-(53,70)
GhciFind.hs:(57,62)-(57,66)
</pre></div>
</div>
<p>このコマンドは，エディタやIDEで指定した識別子をハイライト表示して使用場所を示すのに便利です．</p>
<p><a class="reference internal" href="#ghci-cmd-:uses"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:uses</span></code></a> コマンドを使うには <a class="reference internal" href="#ghci-cmd-:set +c"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+c</span></code></a> を設定しておく必要があります．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:! ⟨command⟩">
<code class="descname">:! ⟨command⟩</code><a class="headerlink" href="#ghci-cmd-:! ⟨command⟩" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-24">シェルコマンド ⟨command⟩ を実行します．</p>
</dd></dl>

</div>
<div class="section" id="set-seti">
<span id="ghci-set"></span><h2>5.8. <code class="docutils literal"><span class="pre">:set</span></code> コマンドと <code class="docutils literal"><span class="pre">:seti</span></code> コマンド<a class="headerlink" href="#set-seti" title="Permalink to this headline">¶</a></h2>
<p id="index-25"><a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> コマンドでは2種類のオプションを設定できます．
「 <code class="docutils literal"><span class="pre">+</span></code>」で始まるオプションと「 <code class="docutils literal"><span class="pre">-</span></code> 」で始まる「コマンドライン」オプションです．</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">現在のところ <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> コマンドは引数における引用符の使用を一切サポートしていません．
引用符は削除されませんし，複数の単語を一つにまとめるのに使うこともできません．
たとえば <code class="docutils literal"><span class="pre">:set</span> <span class="pre">-DFOO='BAR</span> <span class="pre">BAZ'</span></code> は期待した通りには動かないでしょう．</p>
</div>
<div class="section" id="id38">
<h3>5.8.1. GHCi のオプション<a class="headerlink" href="#id38" title="Permalink to this headline">¶</a></h3>
<p id="index-26">GHCi のオプションは <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> で有効 <a class="reference internal" href="#ghci-cmd-:unset"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:unset</span></code></a> で無効にできます．</p>
<p>利用可能な GHCi オプションは以下のとおりです．</p>
<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +c">
<code class="descname">:set +c</code><a class="headerlink" href="#ghci-cmd-:set +c" title="Permalink to this definition">¶</a></dt>
<dd><p>モジュールをロードした後に型と位置情報を収集します．
<a class="reference internal" href="#ghci-cmd-:all-types"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:all-types</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:loc-at"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:loc-at</span></code></a> ，
<a class="reference internal" href="#ghci-cmd-:type-at"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type-at</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:uses"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:uses</span></code></a> の各コマンドを使うには <code class="docutils literal"><span class="pre">+c</span></code> が有効になっていなければなりません．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +m">
<code class="descname">:set +m</code><a class="headerlink" href="#ghci-cmd-:set +m" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-27">複数行にわたるコマンドのパースを可能にします．
複数行コマンドは，現在の入力行が閉じていないレイアウト文脈を含んでいる場合に受け付けます
(<a class="reference internal" href="#ghci-multiline"><span>複数行入力</span></a> 参照)．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +r">
<code class="descname">:set +r</code><a class="headerlink" href="#ghci-cmd-:set +r" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-28">通常，ロードしたモジュールにあるトップレベルの式(CAFあるいは定数適用形式ともいう)
を評価した結果は，複数回の評価をまたがって保持されます．
<code class="docutils literal"><span class="pre">+r</span></code> を有効にすると，トップレベルの式の評価結果は評価が終了するごとに捨てるようになります
(それでも1回の評価の <em>間は</em> 保持されます)．</p>
<p>このオプションは，評価済みのトップレベル式が大量のメモリを消費するときや，再現性のある実行性能を計測したいときに便利です．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +s">
<code class="descname">:set +s</code><a class="headerlink" href="#ghci-cmd-:set +s" title="Permalink to this definition">¶</a></dt>
<dd><p>式を1つ評価するごとに，経過時間や確保されたバイト数の統計情報を表示します．
注意: 確保されたバイト数はGC毎に計算されるので，記憶領域管理器の確保領域の大きさ程度の精度しかありません．
そういうわけ，GCが起らなかったら，値として0が表示されることもあります．</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +t">
<code class="descname">:set +t</code><a class="headerlink" href="#ghci-cmd-:set +t" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-29">プロンプトに文を入力したとき，束縛された変数それぞれの型を表示します．
入力されたのが単一の式なら，束縛されるのは変数 <code class="docutils literal"><span class="pre">it</span></code> だけです．</p>
</dd></dl>

</div>
<div class="section" id="ghcighc">
<span id="ghci-cmd-line-options"></span><h3>5.8.2. GHCiからGHCのコマンドラインオプションを設定する<a class="headerlink" href="#ghcighc" title="Permalink to this headline">¶</a></h3>
<p>通常のGHCのコマンドラインオプションを <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> を使って設定することもできます．
たとえば <a class="reference internal" href="using-warnings.html#ghc-flag--Wmissing-signatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wmissing-signatures</span></code></a> を有効にするには以下のようにします．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :set -Wmissing-signatures
</pre></div>
</div>
<p>GHCのコマンドラインオプションのうち，動的なオプション(<a class="reference internal" href="flags.html#flag-reference"><span>Flag reference</span></a> にある一覧表を参照してください)
として設計されているものは <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> を使って有効にすることができます．
オプションを無効にするには，逆の効果を持つオプションを有効すればできます．</p>
<div class="highlight-none" id="index-30"><div class="highlight"><pre>Prelude&gt; :set -Wno-incomplete-patterns -XNoMultiParamTypeClasses
</pre></div>
</div>
<p><a class="reference internal" href="flags.html#flag-reference"><span>Flag reference</span></a> には，可能なオプション全てについて逆の効果を持つオプションが一覧してあります．</p>
<p>いくつかの静的なオプション(特に <a class="reference internal" href="phases.html#ghc-flag--package"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-package</span></code></a> ， <a class="reference internal" href="phases.html#ghc-flag--I"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-I</span></code></a> ， <a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a>
， <a class="reference internal" href="phases.html#ghc-flag--l"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-l</span></code></a> )も使えるが，次にリロードするまで効果を発揮しないものもある．</p>
<span class="target" id="index-31"></span></div>
<div class="section" id="ghci-interactive-options">
<span id="id39"></span><h3>5.8.3. 対話式評価についてのみのオプションを設定する<a class="headerlink" href="#ghci-interactive-options" title="Permalink to this headline">¶</a></h3>
<p>GHCiは実は <em>2つ</em> のオプション集合を保持しています．</p>
<ul class="simple">
<li>モジュールのロード時に適用する <em>ロード時オプション</em></li>
<li>GHCiのプロンプトに入力された式やコマンドを評価するときに適用する <em>対話時オプション</em></li>
</ul>
<p><a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> コマンドは両方を変更しますが
<a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> コマンドは(&#8220;set interactive&#8221;の略)は対話時オプションにのみ影響します．</p>
<p>このコマンドは，ロード済みモジュールには適用することなく，対話時オプションを変更するのに便利です．
たとえば，</p>
<div class="highlight-none"><div class="highlight"><pre>:seti -XMonoLocalBinds
</pre></div>
</div>
<p><a class="reference internal" href="glasgow_exts.html#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonoLocalBinds</span></code></a> がロード済みモジュールに適用されてしまうと
コンパイルエラーが起こるので望ましくありません．
もっとよくあるのは，フラグが変ったのでモジュールの再コンパイルが必要とGHCが発生するというものです．</p>
<p><code class="docutils literal"><span class="pre">.ghci</span></code> ファイルで言語オプション設定する場合は，本当にGHCiにロードするモジュール全てに適用したい
というわけでない限り <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> ではなく <a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> を使うのが良い習慣です．</p>
<p>この2つのオプションの集合は <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> と <a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> を引数なしで使うことでそれぞれ確認できます．
たとえば，まっさらなGHCiセッションでは次のような表示がでるでしょう．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :seti
base language is: Haskell2010
with the following modifiers:
  -XNoMonomorphismRestriction
  -XNoDatatypeContexts
  -XNondecreasingIndentation
  -XExtendedDefaultRules
GHCi-specific dynamic flag settings:
other dynamic, non-language, flag settings:
  -fimplicit-import-qualified
warning settings:
</pre></div>
</div>
<p>2つのオプション集合は以下のように初期化します．
まず <a class="reference internal" href="#ghci-dot-files"><span>.ghci ファイルと .haskeline ファイル</span></a> にあるように両方のオプション集合を初期化します．
その後，対話時オプションを以下のように変更します．</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">-XExtendedDefaultRules</span></code> を有効にし，これは特殊デフォルト化ルールをプロンプトに入力された式に適用するためです
(<a class="reference internal" href="#extended-default-rules"><span>GHCi でのデフォルト型設定</span></a> 参照)．</li>
<li>単相性制限を無効にする(<a class="reference internal" href="glasgow_exts.html#monomorphism"><span>Switching off the dreaded Monomorphism Restriction</span></a> 参照)．</li>
</ul>
</div>
</div>
<div class="section" id="ghci-haskeline">
<span id="ghci-dot-files"></span><h2>5.9. <code class="docutils literal"><span class="pre">.ghci</span></code> ファイルと <code class="docutils literal"><span class="pre">.haskeline</span></code> ファイル<a class="headerlink" href="#ghci-haskeline" title="Permalink to this headline">¶</a></h2>
<div class="section" id="dot-ghci-files">
<span id="id40"></span><h3>5.9.1. <code class="docutils literal"><span class="pre">.ghci</span></code> ファイル<a class="headerlink" href="#dot-ghci-files" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-32"></span><p>GHCiは起動するとき <a class="reference internal" href="#ghc-flag--ignore-dot-ghci"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ignore-dot-ghci</span></code></a> フラグが指定されていなければ，以下の各ファイルを順に探し，
存在すれば，そのファイルに書かれているコマンドを読み込み実行します．</p>
<ol class="arabic simple">
<li><code class="file docutils literal"><span class="pre">./.ghci</span></code></li>
<li><code class="file docutils literal"><em><span class="pre">appdata</span></em><span class="pre">/ghc/ghci.conf</span></code> ただし ⟨appdata⟩ はシステムに依存します．
通常は <code class="file docutils literal"><span class="pre">C:Documents</span> <span class="pre">and</span> <span class="pre">SettingsuserApplication</span> <span class="pre">Data</span></code> のようなところです．</li>
<li>Unixでは <code class="file docutils literal"><span class="pre">$HOME/.ghc/ghci.conf</span></code></li>
<li><code class="file docutils literal"><span class="pre">$HOME/.ghci</span></code></li>
</ol>
<p><code class="file docutils literal"><span class="pre">ghci.conf</span></code> ファイルは，お気に入りのオプション(たとえば <code class="docutils literal"><span class="pre">:set</span> <span class="pre">+s</span></code>)を有効にしたり便利なマクロを定義するのに向いています．</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">このファイルで言語オプションを設定する場合は，通常は <a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> のほうが
<a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> より適しています(<a class="reference internal" href="#ghci-interactive-options"><span>対話式評価についてのみのオプションを設定する</span></a> 参照)．</p>
</div>
<p><code class="file docutils literal"><span class="pre">.ghci</span></code> ファイルをHaskellプロジェクトのディレクトリに置いて，プロジェクトで使う共通オプションを設定するようにしておくと，
GHCiを立ち上げるたびにそれを打ち込まなくて済むので便利です．
たとえば，プロジェクトが多引数の型クラスとスコープのある型変数とCPPを使い，ソースファイルがA，B，Cという3つのサブディレクトリに置いているなら，
次のような行を <code class="file docutils literal"><span class="pre">.ghci</span></code>: に書くことになるでしょう．</p>
<div class="highlight-none"><div class="highlight"><pre>:set -XMultiParamTypeClasses -XScopedTypeVariables -cpp
:set -iA:B:C
</pre></div>
</div>
<p>(厳密には <a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a> フラグは静的オプションですが，このように <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> コマンドでも有効にできます．
ただし，この変更は，次に <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> 実行されてはじめて有効になります．)</p>
<p>GHCiのマクロライブラリを持つようになれば，別のファイルから読み込みたくなります．
あるいはデバッグに <code class="docutils literal"><span class="pre">.ghci</span></code> ファイルをGHCiセッションから読み込みたくなります．
そういうときは，</p>
<div class="highlight-none"><div class="highlight"><pre>:def source readFile
</pre></div>
</div>
<p>というマクロを <code class="docutils literal"><span class="pre">.ghci</span></code> ファイルに置いておけば
<code class="docutils literal"><span class="pre">:source</span> <span class="pre">file</span></code> とやるだけでGHCiコマンドを <code class="docutils literal"><span class="pre">file</span></code> から読み込めます．
Haskell wikiのページ <a class="reference external" href="http://haskell.org/haskellwiki/GHC/GHCi">GHC/GHCi</a>
では，他にも <cite>.ghci</cite> に関する助言が読めますし，貢献もできます．</p>
<p>さらに，標準ファイルが読み込まれた後に <a class="reference internal" href="#ghc-flag--ghci-script"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ghci-script</span></code></a> フラグで指定されたファイルが読み込まれます．
これによって，自分専用の .ghci ファイルが使えます．</p>
<p>どの開始時ファイルを読み込むかを制御するためのコマンドラインオプションが2つあります．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--ignore-dot-ghci">
<code class="descname">-ignore-dot-ghci</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--ignore-dot-ghci" title="Permalink to this definition">¶</a></dt>
<dd><p>開始時に <code class="file docutils literal"><span class="pre">./.ghci</span></code> および他の開始時ファイルを読み込みません．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ghci-script">
<code class="descname">-ghci-script</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--ghci-script" title="Permalink to this definition">¶</a></dt>
<dd><p>通常の開始時ファイルを読み込んだ後に，指定したファイルを読み込みます．
複数の入力は指定を繰り返せば可能です．</p>
</dd></dl>

<p>GHCiマクロを定義する場合，名前が組み込みのコマンドと衝突する可能性があります．
そのときの振る舞いについて，特にTAB補完に関して知っておくべきことがあります．</p>
<p>たとえば <code class="docutils literal"><span class="pre">:time</span></code> というマクロを定義したとして，プロンプトで <code class="docutils literal"><span class="pre">:t</span> <span class="pre">3</span></code> とタイプしたとき何が起るべきでしょう．
コマンド補完のアルゴリズムは現在のところ以下のようになっています．</p>
<ol class="arabic simple">
<li>定義済みマクロの中から完全一致のものを探索．</li>
<li>組み込みコマンド一覧の中から完全一致のものを探索．</li>
<li>組み込みコマンド一覧の中から前方一致のものを探索．
該当する組み込みコマンドがあり，さらにそれと同名のマクロも見つかれば，マクロのほうを選択．</li>
<li>組み込みコマンド一覧の中から前方一致のものを探索．</li>
<li>定義済みマクロの一覧の中から前方一致のものを探索．</li>
</ol>
<p>例をいくつか示します．</p>
<ol class="arabic">
<li><p class="first"><code class="docutils literal"><span class="pre">:time</span></code> というマクロがあり <code class="docutils literal"><span class="pre">:t</span> <span class="pre">3</span></code> と入力すると</p>
<p><code class="docutils literal"><span class="pre">:type</span> <span class="pre">3</span></code> となります．</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">:type</span></code> というマクロがあり <code class="docutils literal"><span class="pre">:t</span> <span class="pre">3</span></code> と入力すると</p>
<p>組み込みのものではなく，定義されたマクロを使って <code class="docutils literal"><span class="pre">:type</span> <span class="pre">3</span></code> となります．</p>
</li>
<li><p class="first"><code class="docutils literal"><span class="pre">:time</span></code> マクロと <code class="docutils literal"><span class="pre">:type</span></code> マクロの両方があり <code class="docutils literal"><span class="pre">:t</span> <span class="pre">3</span></code> と入力すると</p>
<p>定義されたマクロを使って <code class="docutils literal"><span class="pre">:type</span> <span class="pre">3</span></code> となります．</p>
</li>
</ol>
</div>
<div class="section" id="haskeline">
<span id="dot-haskeline-file"></span><h3>5.9.2. <code class="docutils literal"><span class="pre">.haskeline</span></code> ファイル<a class="headerlink" href="#haskeline" title="Permalink to this headline">¶</a></h3>
<p id="index-33">GHCi は内部で <a class="reference external" href="https://hackage.haskell.org/package/haskeline">Haskeline</a> を使っています．
他のものと同じように，これを設定することで，GHCiの履歴中の重複を取り除けます．
<a class="reference external" href="http://trac.haskell.org/haskeline/wiki/UserPrefs">Haskeline user preferences</a>
を参照してください．</p>
</div>
</div>
<div class="section" id="ghci-obj">
<span id="id41"></span><h2>5.10. GHCi内でオブジェクトコードにコンパイルする<a class="headerlink" href="#ghci-obj" title="Permalink to this headline">¶</a></h2>
<p>デフォルトでは，GHCiはHaskellのソースをバイトコードにコンパイルして，ランタイムシステムがそれを解釈実行します．
GHCiはHaskellのコードをオブジェクトコードにコンパイルすることもできます．それには <a class="reference internal" href="phases.html#ghc-flag--fobject-code"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fobject-code</span></code></a> フラグを，
コマンドラインで使うか <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> で設定します
(<a class="reference internal" href="phases.html#ghc-flag--fbyte-code"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbyte-code</span></code></a> を設定すると元のバイトコードコンパイルが復帰します)．
オブジェクトコードへのコンパイルには時間が余分にかかりますが，通常オブジェクトコードの実行は，バイトコードの実行の10〜20倍速くなります．</p>
<p>GHCi内でオブジェクトコードにコンパイルする機能はコンパイル形式のアプリケーションを開発する場合に特に便利です．
通常 <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> を使うほうが，コマンドラインでGHCを <a class="reference internal" href="using.html#ghc-flag---make"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--make</span></code></a> オプション付きで再起動するよりずっと速いからです．
これはインターフェイスファイルがすべてメモリにキャッシュされているからです．</p>
<p>オブジェクトコードにコンパイルしてしまうことには欠点もあります．
たとえば，オブジェクトコードモジュールにはブレイクポイントを設定することはできません．
オブジェクトコードモジュールではエクスポートされたものしか見えませんが，
解釈実行されているモジュールでは，トップレベルの束縛はすべてGHCiでは可視になります．</p>
</div>
<div class="section" id="external-interpreter">
<span id="id42"></span><h2>5.11. インタプリタを別プロセスで走らせる<a class="headerlink" href="#external-interpreter" title="Permalink to this headline">¶</a></h2>
<p>通常GHCiは解釈実行されるコードをGHCそれ自身と同じプロセスで走らせます．
すなわち，GHCと同じRTS上で走らせ，同じヒープ領域を共有します．
しかし <a class="reference internal" href="#ghc-flag--fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fexternal-interpreter</span></code></a> フラグを与えると，GHCは別プロセスを起こしてそちらで解釈実行コードを走らせます．
そのプロセスとの通信にはパイプ上のメッセージを使います．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fexternal-interpreter">
<code class="descname">-fexternal-interpreter</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fexternal-interpreter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>別プロセスで(GHCi，Template Haskell，準クォートあるいはアノテーション)の解釈実行コードを走らせます．
インタプリタは <a class="reference internal" href="profiling.html#ghc-flag--prof"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-prof</span></code></a> フラグが有効になっていれば，プロファイルモードで動作し，
<a class="reference internal" href="phases.html#ghc-flag--dynamic"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dynamic</span></code></a> フラグが有効になっていれば，動的リンクモードで動作します．</p>
<p>このオプションには欠陥がいくつか残っています(将来，除去されるでしょう)．
現時点ではこのオプションはWindowsでは実現していません(指定しても何も起こりません)．
また，別プロセスできどうしたインタプリタはGHCiデバッガをサポートしていませんので，
<a class="reference internal" href="#ghc-flag--fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fexternal-interpreter</span></code></a> を指定してもブレイクポイントを設定したり，ステップ実行を行うことはできません．</p>
<p><a class="reference internal" href="phases.html#ghc-flag--pgmi"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-pgmi</span></code></a> (<a class="reference internal" href="phases.html#replacing-phases"><span>Replacing the program for one or more phases</span></a>) および <a class="reference internal" href="phases.html#ghc-flag--opti"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-opti</span></code></a>
(<a class="reference internal" href="phases.html#forcing-options-through"><span>Forcing options to a particular phase</span></a>) フラグも参照してください．</p>
</dd></dl>

<p>なぜこの機能が必要なのでしょうか．
主な理由は，解釈実行するコードを走らせる RTS と GHC そのものとでは(プロファイリングや動的リンクかどうかなど)異なる性質のものだからです．
たとえば，</p>
<ul class="simple">
<li>GHCi使用時にはプロファイラを使ってスタックトレースを収集できます(<a class="reference internal" href="#ghci-stack-traces"><span>GHCiのスタックトレース</span></a> 参照)．</li>
<li>Template Haskell のコードを <a class="reference internal" href="profiling.html#ghc-flag--prof"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-prof</span></code></a> でコンパイルする場合，先にモジュールを <a class="reference internal" href="profiling.html#ghc-flag--prof"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-prof</span></code></a> なしで
コンパイルする必要はありません(<a class="reference internal" href="glasgow_exts.html#th-profiling"><span>Using Template Haskell with Profiling</span></a> 参照)．
インタプリタでプロファイル設定されたオブジェクトコードを走らせることが可能だからです．</li>
</ul>
<p>GHC 8.0.x ではこの機能は実験的なものですが，将来のリリースではデフォルト機能になる予定です．</p>
</div>
<div class="section" id="faq">
<span id="ghci-faq"></span><h2>5.12. FAQ と注意事項<a class="headerlink" href="#faq" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>インタプリタはforeign export宣言のあるモジュールをロードできません！</dt>
<dd>残念ながらその通りです．まだその機能は実装していません．その問題のあるモジュールは手でコンパイルしてからGHCiにロードしてください．</dd>
</dl>
<p>GHCiで <a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> が効きません！</p>
<blockquote>
<div><p id="index-34">技術的な理由から，バイトコードコンパイラは最適化過程と上手くやりとりできないので，
インタプリタを使う場合には最適化を無効にしてあります．
だからといって大した問題にはなりません．
高速実行が必要になるようなコードはコンパイルしておけば，最適化を有効にして解釈実行するよりずっと速いからです．</p>
</div></blockquote>
<dl class="docutils">
<dt>GHCiで非ボックス化タプルが使えません．</dt>
<dd>その通りです．ただし，非ボックス化タプルを使うモジュールをコンパイルしてからGHCiにロードすることはできます．
(ちなみに，上記の <a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> がGHCiで使えなにのは，バイトコードコンパイラが非ボックス化タプルを扱えないからです．)</dd>
</dl>
<dl class="docutils">
<dt>GHCiが入力待ちのとき，裏で並行スレッドが走っててくれない．</dt>
<dd>GHCiが <a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a> スイッチを有効(デフォルト)にしてコンパイルされたものであれば，ちゃんと機能するはずです．
GHCiをインストールしてくれた人に相談してください．</dd>
</dl>
<dl class="docutils">
<dt><code class="docutils literal"><span class="pre">getContents</span></code> を使うと，その後 <code class="docutils literal"><span class="pre">:load</span></code> あるいは <code class="docutils literal"><span class="pre">:reload</span></code> しないと <code class="docutils literal"><span class="pre">stdin</span></code> が使えません．</dt>
<dd><p class="first">これは <code class="docutils literal"><span class="pre">getContents</span></code> 定義どおりの振る舞いです．
<code class="docutils literal"><span class="pre">getContents</span></code> は <code class="docutils literal"><span class="pre">stdin</span></code> ハンドルをセミクローズドという状態にします．
この状態のハンドル上ではいかなるＩ／Ｏ操作もできません．
計算と計算の間ではＩ／Ｏの状態は保持されるので，次に <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> コマンド，あるいは，
<a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> コマンドを実行するまではセミクローズド状態が続きます．</p>
<p class="last">GHCiの <code class="docutils literal"><span class="pre">:set</span> <span class="pre">+r</span></code> というコマンドを使えば <code class="docutils literal"><span class="pre">stdin</span></code> が毎回元の状態に復元するようにできます．
これがうまく行くのは <code class="docutils literal"><span class="pre">stdin</span></code> が単なるトップレベルの式で，他のトップレベルの式(CAF)と同様の方法で未評価状態に戻せるからです．</p>
</dd>
</dl>
<dl class="docutils">
<dt>Windows で <code class="kbd docutils literal"><span class="pre">Control-C</span></code> を使って計算を中断できません．</dt>
<dd><a class="reference internal" href="win32-dlls.html#ghci-windows"><span>Running GHCi on Windows</span></a> を参照してください．</dd>
</dl>
<dl class="docutils">
<dt>GHCi と GHC とで，デフォルトのバッファリングモードが異なります．</dt>
<dd><p class="first">GHC では <code class="docutils literal"><span class="pre">stdout</span></code> ハンドルは行バッファモードになっています．
他方，GHCi では <code class="docutils literal"><span class="pre">stdout</span></code> のバッファリングはオフになっています．
出力がすぐに見えるというのが，インタプリタに期待する動作だからです．</p>
<p>GHCiで行バッファモードが必要ときは，プログラムを以下のように始めるとよいでしょう．</p>
<div class="last highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">hSetBuffering</span> <span class="n">stdout</span> <span class="kt">LineBuffering</span><span class="p">;</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
<table class="docutils footnote" frame="void" id="id43" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[5]</a></td><td>パッケージはコンパイル済みのコードだけを含んでいるので，パッケージのデバッグにはソースコードを探してそれを直接ロードしなければならないことに注意してください．</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id44" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[6]</a></td><td>もともと，当該式の自由変数だけではなく，スコープ内にあるすべての変数の束縛を提供していました．
しかし，実行性能に大いに影響することが判明したので，それ以来，自由変数のみに制限しています．</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="runghc.html" title="6. Using runghc"
             >next</a> |</li>
        <li class="right" >
          <a href="8.0.2-notes.html" title="4. バージョン 8.0.2 のリリースノート"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.0.2 Users Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, GHC Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>