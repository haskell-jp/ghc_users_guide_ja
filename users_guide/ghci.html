
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5. GHCiを使う &mdash; Glasgow Haskell Compiler &lt;release&gt; Users Guide</title>
    
    <link rel="stylesheet" href="_static/ghc-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Glasgow Haskell Compiler &lt;release&gt; Users Guide" href="index.html" />
    <link rel="next" title="6. Using runghc" href="runghc.html" />
    <link rel="prev" title="4. バージョン 8.0.2 のリリースノート" href="8.0.2-notes.html" /> 
  </head>
  <body role="document">
<div class="logo">
    <h1><a href="index.html">Glasgow Haskell Compiler Users Guide</a></h1>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="runghc.html" title="6. Using runghc"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="8.0.2-notes.html" title="4. バージョン 8.0.2 のリリースノート"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.0.2 Users Guide</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">5. GHCiを使う</a><ul>
<li><a class="reference internal" href="#ghci-introduction">5.1. GHCi入門</a></li>
<li><a class="reference internal" href="#loading-source-files">5.2. ソースファイルをロードする</a><ul>
<li><a class="reference internal" href="#ghci-modules-filenames">5.2.1. モジュールとファイル名</a></li>
<li><a class="reference internal" href="#id12">5.2.2. ソースコードの変更と再コンパイル</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghci-compiled">5.3. コンパイル済みコードをロードする</a></li>
<li><a class="reference internal" href="#interactive-evaluation">5.4. プロンプトで対話的に評価する</a><ul>
<li><a class="reference internal" href="#i-o">5.4.1. プロンプトでのI/Oアクション</a></li>
<li><a class="reference internal" href="#do">5.4.2. プロンプトで <code class="docutils literal"><span class="pre">do</span></code> 記法を使う</a></li>
<li><a class="reference internal" href="#ghci-multiline">5.4.3. 複数行入力</a></li>
<li><a class="reference internal" href="#ghci-decls">5.4.4. 型，クラス，その他の宣言</a></li>
<li><a class="reference internal" href="#ghci-scope">5.4.5. プロンプトのスコープにあるもの</a><ul>
<li><a class="reference internal" href="#load">5.4.5.1. スコープ内容に対する <code class="docutils literal"><span class="pre">:load</span></code> の影響</a></li>
<li><a class="reference internal" href="#import">5.4.5.2. <code class="docutils literal"><span class="pre">import</span></code> によるスコープ制御</a></li>
<li><a class="reference internal" href="#module">5.4.5.3. <code class="docutils literal"><span class="pre">:module</span></code> コマンドによるスコープ制御</a></li>
<li><a class="reference internal" href="#ghci-import-qualified">5.4.5.4. 修飾名</a></li>
<li><a class="reference internal" href="#module-load">5.4.5.5. <code class="docutils literal"><span class="pre">:module</span></code> と <code class="docutils literal"><span class="pre">:load</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#main-run">5.4.6. <code class="docutils literal"><span class="pre">:main</span></code> コマンドと <code class="docutils literal"><span class="pre">:run</span></code> コマンド</a></li>
<li><a class="reference internal" href="#it">5.4.7. <code class="docutils literal"><span class="pre">it</span></code> 変数</a></li>
<li><a class="reference internal" href="#extended-default-rules">5.4.8. GHCi でのデフォルト型設定</a></li>
<li><a class="reference internal" href="#ghci-interactive-print">5.4.9. 独自の対話表示関数を使う</a></li>
<li><a class="reference internal" href="#ghci-stack-traces">5.4.10. GHCiのスタックトレース</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghci-debugger">5.5. GHCiのデバッガ</a><ul>
<li><a class="reference internal" href="#breakpoints">5.5.1. ブレイクポイントと変数内容の表示</a><ul>
<li><a class="reference internal" href="#setting-breakpoints">5.5.1.1. ブレイクポイントの設定</a></li>
<li><a class="reference internal" href="#id27">5.5.1.2. ブレイクポイントの一覧と削除</a></li>
</ul>
</li>
<li><a class="reference internal" href="#single-stepping">5.5.2. ステップ実行</a></li>
<li><a class="reference internal" href="#nested-breakpoints">5.5.3. ブレイクポイントのネスト</a></li>
<li><a class="reference internal" href="#the-result-variable">5.5.4. The <code class="docutils literal"><span class="pre">_result</span></code> variable</a></li>
<li><a class="reference internal" href="#tracing-and-history">5.5.5. Tracing and history</a></li>
<li><a class="reference internal" href="#debugging-exceptions">5.5.6. Debugging exceptions</a></li>
<li><a class="reference internal" href="#example-inspecting-functions">5.5.7. Example: inspecting functions</a></li>
<li><a class="reference internal" href="#limitations">5.5.8. Limitations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#invoking-ghci">5.6. Invoking GHCi</a><ul>
<li><a class="reference internal" href="#packages">5.6.1. Packages</a></li>
<li><a class="reference internal" href="#extra-libraries">5.6.2. Extra libraries</a></li>
</ul>
</li>
<li><a class="reference internal" href="#ghci-commands">5.7. GHCi commands</a></li>
<li><a class="reference internal" href="#the-set-and-seti-commands">5.8. The <code class="docutils literal"><span class="pre">:set</span></code> and <code class="docutils literal"><span class="pre">:seti</span></code> commands</a><ul>
<li><a class="reference internal" href="#ghci-options">5.8.1. GHCi options</a></li>
<li><a class="reference internal" href="#setting-ghc-command-line-options-in-ghci">5.8.2. Setting GHC command-line options in GHCi</a></li>
<li><a class="reference internal" href="#setting-options-for-interactive-evaluation-only">5.8.3. Setting options for interactive evaluation only</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-ghci-and-haskeline-files">5.9. The <code class="docutils literal"><span class="pre">.ghci</span></code> and <code class="docutils literal"><span class="pre">.haskeline</span></code> files</a><ul>
<li><a class="reference internal" href="#the-ghci-files">5.9.1. The <code class="docutils literal"><span class="pre">.ghci</span></code> files</a></li>
<li><a class="reference internal" href="#the-haskeline-file">5.9.2. The <code class="docutils literal"><span class="pre">.haskeline</span></code> file</a></li>
</ul>
</li>
<li><a class="reference internal" href="#compiling-to-object-code-inside-ghci">5.10. Compiling to object code inside GHCi</a></li>
<li><a class="reference internal" href="#running-the-interpreter-in-a-separate-process">5.11. Running the interpreter in a separate process</a></li>
<li><a class="reference internal" href="#faq-and-things-to-watch-out-for">5.12. FAQ and Things To Watch Out For</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="8.0.2-notes.html"
                        title="previous chapter">4. バージョン 8.0.2 のリリースノート</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="runghc.html"
                        title="next chapter">6. Using runghc</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/ghci.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="ghci">
<span id="id1"></span><h1>5. GHCiを使う<a class="headerlink" href="#ghci" title="Permalink to this headline">¶</a></h1>
<span class="target" id="index-0"></span><p>GHCi <a class="footnote-reference" href="#id3" id="id2">[1]</a> はGHCの対話環境であり，Haskellの式を対話方式で評価したり
プログラムを解釈実行したりできます．
<a class="reference external" href="http://www.haskell.org/hugs/">Hugs</a> の経験があるなら，
すぐにでもGHCiに慣れることでしょう．
しかしながら， GHCiはコンパイル済みのコードを対話的にロードすることができます．
また，GHCが提供する言語拡張のすべて[2]_ をサポートしています．
GHCi は対話方式のデバッガも備えています(<a class="reference internal" href="#ghci-debugger"><span>GHCiのデバッガ</span></a> 参照)．</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>&#8220;i&#8221;は“Interactive”の i です．</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td>ただし今のところ <code class="docutils literal"><span class="pre">foreign</span> <span class="pre">export</span></code> は除きます．</td></tr>
</tbody>
</table>
<div class="section" id="ghci-introduction">
<span id="id5"></span><h2>5.1. GHCi入門<a class="headerlink" href="#ghci-introduction" title="Permalink to this headline">¶</a></h2>
<p>GHCiセッションの例を見ていくことから始めましょう．
GHCiは <code class="docutils literal"><span class="pre">ghci</span></code> コマンドで起動します．</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghci
GHCi, version 8.0.2: http://www.haskell.org/ghc/  :? for help
Prelude&gt;
</pre></div>
</div>
<p>GHCiがプレリュードと標準ライブラリをロードするのにすこしかかるかもしれませんが，
それが完了するとプロンプトが現れます．
バナーにあるとおり，<a class="reference internal" href="#ghci-cmd-:?"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:?</span></code></a> をタイプすれば，利用可能なコマンド一覧と
それぞれの短い説明が表示されます．
これ以降ほとんどのコマンドを説明します．
すべてのコマンドの完全な説明は <a class="reference internal" href="#ghci-commands"><span>GHCi commands</span></a> にあります．</p>
<p>プロンプトにはHaskellの式をタイプします．</p>
<div class="highlight-none" id="index-1"><div class="highlight"><pre>Prelude&gt; 1+2
3
Prelude&gt; let x = 42
Preldue&gt; x / 9
4.666666666666667
Prelude&gt;
</pre></div>
</div>
<p>GHCiは行全体を1つの式だと解釈し，これを評価します．
式は複数行にまたがることはできません．
エンターキーを押したとたん，GHCiはそこまでにタイプされたものを評価しようとします．</p>
<p>Haskellでは <code class="docutils literal"><span class="pre">let</span></code> 式は <code class="docutils literal"><span class="pre">in</span></code> をともないます．
しかし，GHCiでは，式は <code class="docutils literal"><span class="pre">IO</span></code> モナドの中でも解釈されますので，上の例は
<code class="docutils literal"><span class="pre">in</span></code> を伴わない <code class="docutils literal"><span class="pre">let</span></code> 束縛文であることは，行が表示されないことで示されています．</p>
</div>
<div class="section" id="loading-source-files">
<span id="id6"></span><h2>5.2. ソースファイルをロードする<a class="headerlink" href="#loading-source-files" title="Permalink to this headline">¶</a></h2>
<p>次のようなHaskellのソースコードが <code class="docutils literal"><span class="pre">Main.hs</span></code> というファイルに書かれているとしましょう．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">fac</span> <span class="mi">20</span><span class="p">)</span>

<span class="nf">fac</span> <span class="mi">0</span> <span class="ow">=</span> <span class="mi">1</span>
<span class="nf">fac</span> <span class="n">n</span> <span class="ow">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">fac</span> <span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Main.hs</span></code> は好きな場所に置けますが，GHCiを起動したファイルがあるカレントディレクトリ
<a class="footnote-reference" href="#id8" id="id7">[3]</a> 以外の場所に置いたときには，GHCiでディレクトリを正しく変更する必要があります．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :cd dir
</pre></div>
</div>
<p>ここで ⟨dir⟩ は <code class="docutils literal"><span class="pre">Main.hs</span></code> を保存したディレクトリ(あるいはフォルダ）です．</p>
<p>HaskellのソースファイルをGHCiにロードするには <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> コマンドを使います．</p>
<div class="highlight-none" id="index-2"><div class="highlight"><pre>Prelude&gt; :load Main
Compiling Main             ( Main.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt;
</pre></div>
</div>
<p>GHCiは <code class="docutils literal"><span class="pre">Main</span></code> モジュールをロードし，プロンプトが <code class="docutils literal"><span class="pre">*Main&gt;</span></code> に変りました．
このプロンプトは，ここにユーザが入力する式を評価するときの文脈が，たったいまロードした
<code class="docutils literal"><span class="pre">Main</span></code> モジュールであることを示しています
(<code class="docutils literal"><span class="pre">*</span></code> の意味については <a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a> で説明します)．
これで <code class="docutils literal"><span class="pre">Main.hs</span></code> で定義した関数を含む式が評価できるようになりました．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; fac 17
355687428096000
</pre></div>
</div>
<p>複数のモジュールからなるプログラムをロードするのも同様に簡単です．
「最上位の」モジュールの名前を <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> コマンドに指定すればいいだけです
(ヒント: <code class="xref std std-ghci-cmd docutils literal"><span class="pre">load</span></code> は <code class="docutils literal"><span class="pre">:l</span></code> に短縮できます)．
最上位のモジュールはふつうは <code class="docutils literal"><span class="pre">Main</span></code> ですが，必ずしもそうである必要はありません．
GHCiは最上位のモジュールから直接・間接に必要とされているモジュールを見つけ，
それらを依存関係の順にロードします．</p>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[3]</a></td><td>コマンドラインから GHCi を起動した場合は GHCi のカレントディレクトリは
シェルから起動したときのカレントディレクトリと同じです．
Windowsの「スタート」メニューから GHCi を起動した場合は，
カレントディレクトリはおそく <code class="docutils literal"><span class="pre">C:\Documents</span> <span class="pre">and</span> <span class="pre">Settings\user</span> <span class="pre">name</span></code> あたりでしょう．</td></tr>
</tbody>
</table>
<div class="section" id="ghci-modules-filenames">
<span id="id9"></span><h3>5.2.1. モジュールとファイル名<a class="headerlink" href="#ghci-modules-filenames" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-3"></span><p>問: GHCi はモジュール ⟨M⟩ がどのファイルにあるかをどうやって知るのですか．
答: <code class="docutils literal"><span class="pre">M.hs</span></code> あるいは <code class="docutils literal"><span class="pre">M.lhs</span></code> というファイルを探します．
したがって，大部分のモジュールでは，モジュール名とファイル名は一致している必要があります．
一致しなかった場合，GHCiはモジュールを見つけ出すことができません．</p>
<p>この規則には一つの例外があります．
<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> を使ってプログラムをロードするとき，
あるいは <code class="docutils literal"><span class="pre">ghci</span></code> を起動するときには，モジュール名ではなくファイル名を指定することができます．
その名前のファイルがあれば，それをロードします．
このときそのファイルにはどのような名前のモジュールを含んでいてもかまいません．
これは，複数の <code class="docutils literal"><span class="pre">Main</span></code> モジュールが1つのディレクトリにある場合，
全てを <code class="docutils literal"><span class="pre">Main.hs</span></code> と呼ぶことはできませんので，特に便利です．</p>
<p>ソースファイルを探すときの探索パスは，次に示すように，
GHCiを起動するコマンドラインで <a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a> オプションで指定できます．</p>
<div class="highlight-none"><div class="highlight"><pre>ghci -idir1:...:dirn
</pre></div>
</div>
<p>あるいは，GHCiの中で <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> コマンドで指定できます
(<a class="reference internal" href="#ghci-cmd-line-options"><span>Setting GHC command-line options in GHCi</span></a> 参照) <a class="footnote-reference" href="#id11" id="id10">[4]</a></p>
<p>GHCiは，このように依存関係を追ってロードすべきモジュールを見つけようとするので，
モジュールごとに，1つのソースファイルがなければなりません．
この規則の唯一の例外はパッケージ由来のモジュールで，それには <code class="docutils literal"><span class="pre">Prelude</span></code> のほか
<code class="docutils literal"><span class="pre">IO</span></code> や <code class="docutils literal"><span class="pre">Complex</span></code> といった標準ライブラリも含まれます．
モジュールをロードしようとしたとき，GHCiがソースファイルを見つけられなければ，
たとえ，そのモジュールのオブジェクトファイルやインターフェイスファイルがあったとしても，
エラーメッセージが表示されます．</p>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[4]</a></td><td>GHCiや <a class="reference internal" href="using.html#ghc-flag---make"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--make</span></code></a> モードでは <a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a> オプションは，
<em>ソースファイル</em> の探索パスを指定するのに対し，標準の一括コンパイルモードでは
<a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a> オプションはインターフェイスファイルの探索パスを指定することに注意してください．
詳しくは <a class="reference internal" href="separate_compilation.html#search-path"><span>The search path</span></a> を参照してください．</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id12">
<h3>5.2.2. ソースコードの変更と再コンパイル<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h3>
<p id="index-4">ソースコードに変更を加えて，GHCiに再コンパイルさせたいときは <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a>
コマンドを使います．
プログラムは必要に応じて再コンパイルされます．
このとき，GHCiは依存関係の変化がないモジュールを実際に再コンパイルするのを避けようと最善をつくします．
これは一括コンパイル時に再コンパイルを避ける機構と同じです
(<a class="reference internal" href="separate_compilation.html#recomp"><span>The recompilation checker</span></a> 参照)．</p>
</div>
</div>
<div class="section" id="ghci-compiled">
<span id="id13"></span><h2>5.3. コンパイル済みコードをロードする<a class="headerlink" href="#ghci-compiled" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-5"></span><p>HaskellのソースモジュールをGHCiにロードすると，通常はバイトコードに変換され，解釈実行器で実行されます．
しかし，GHCiでは解釈実行されるコードはコンパイル済みコードと一緒に実行することもできます．
実際，GHCiは起動すると通常は <code class="docutils literal"><span class="pre">base</span></code> パッケージのコンパイル済みのものをロードします．
その中には <code class="docutils literal"><span class="pre">Prelude</span></code> モジュールが含まれています．</p>
<p>なぜコンパイル済みのコードを使う必要があるのでしょうか．
コンパイル済みコードは解釈実行されるコードに比べて大体10倍速いですが，生成するのに2倍の時間がかります
(最適化が有効ならもっと長くなるでしょう)．
そのため、プログラムのあまり変更されない部分をコンパイルしておき，
活発に開発されている部分には解釈実行器を使ことにすればいいわけです．</p>
<p><a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> でソースモジュールをロードするとき，GHCiは通常対応する
コンパイル済みのオブジェクトファイルを探します．
可能ならソースコードの解釈実行よりも優先してそれを使います．
たとえば，A，B，C，Dという4つのモジュールからなるプログラムがあるとしましょう．
モジュールBとCはどちらもDのみをインポートしていて，AはBとCをインポートしているとしましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>  A
 / \
B   C
 \ /
  D
</pre></div>
</div>
<p>以下のように <code class="docutils literal"><span class="pre">D</span></code> をコンパイルしてから，プログラム全体をロードすることができます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :! ghc -c -dynamic D.hs
Prelude&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D (D.o).
*Main&gt;
</pre></div>
</div>
<p>コンパイラのメッセージ中に <code class="docutils literal"><span class="pre">D</span></code> についての行がありません．
これは，<code class="docutils literal"><span class="pre">D</span></code> のソースファイルとその依存関係が，最後にコンパイルされたときから変更されていないので，
<code class="docutils literal"><span class="pre">D</span></code> をコンパイルする必要ないからです．</p>
<p><a class="reference internal" href="phases.html#ghc-flag--dynamic"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dynamic</span></code></a> フラグはGHCに渡すものです．
これによって，GHCiはダイナミックリンクオブジェクトコードを使うようになります
(もちろんそれをサポートしているプラットフォームでの話です)．
したがって，GHCiでコンパイル済みのコードを利用するためには，そのコードは
ダイナミックリンク可能なようにコンパイルされていなければなりません．</p>
<p><a class="reference internal" href="#ghci-cmd-:show modules"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">modules</span></code></a> を使えば，いつでも，その時点でGHCiにロードされている
モジュールの一覧を表示できます．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :show modules
D                ( D.hs, D.o )
C                ( C.hs, interpreted )
B                ( B.hs, interpreted )
A                ( A.hs, interpreted )
*Main&gt;
</pre></div>
</div>
<p>ここで <code class="docutils literal"><span class="pre">D</span></code> を変更する(あるいは変更したふりをする: <code class="docutils literal"><span class="pre">touch</span></code> というUnixのコマンドを
使うのが簡単)と，コンパイラはオブジェクトファイルを使えなくなります．
その理由は，オブジェクトファイルがすでに古くなっているに違いないからです．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :! touch D.hs
*Main&gt; :reload
Compiling D                ( D.hs, interpreted )
Ok, modules loaded: A, B, C, D.
*Main&gt;
</pre></div>
</div>
<p>モジュール <code class="docutils literal"><span class="pre">D</span></code> がコンパイルされました．
しかし，この例では実際にはソースは変更されていないので，インターフェイスは同じままで，
再コンパイル検査器が <code class="docutils literal"><span class="pre">A</span></code> ， <code class="docutils literal"><span class="pre">B</span></code> ， <code class="docutils literal"><span class="pre">C</span></code> は再コンパイルする必要なしと判断したことに注意してください．</p>
<p>では，別のモジュールを1つコンパイルしてみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :! ghc -c C.hs
*Main&gt; :load A
Compiling D                ( D.hs, interpreted )
Compiling B                ( B.hs, interpreted )
Compiling C                ( C.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C, D.
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">C</span></code> のコンパイル済みのバージョンが使われていません．
何が起きたのでしょうか．
GHCi ではコンパイル済みのモジュールは別のコンパイル済みのモジュールにしか依存できません．
この場合は <code class="docutils literal"><span class="pre">C</span></code> が <code class="docutils literal"><span class="pre">D</span></code> に依存していますが <code class="docutils literal"><span class="pre">D</span></code> にはオブジェクトファイルがないので
GHCiは <code class="docutils literal"><span class="pre">C</span></code> のオブジェクトファイルを利用しなかったのです．
では <code class="docutils literal"><span class="pre">D</span></code> もコンパイルしてみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :! ghc -c D.hs
*Main&gt; :reload
Ok, modules loaded: A, B, C, D.
</pre></div>
</div>
<p>何も起こりません．
もう1つ賢くなりました．
新しくコンパイルされたモジュールは <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> では拾えません．
<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> を使う必要があります．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :load A
Compiling B                ( B.hs, interpreted )
Compiling A                ( A.hs, interpreted )
Ok, modules loaded: A, B, C (C.o), D (D.o).
</pre></div>
</div>
<p>このようなオブジェクトファイルの自動ロードは混乱の原因になることがあります．
モジュールのエクスポートされていないトップレベルの定義をプロンプトの式で使えるのは，
そのモジュールが解釈実行されているときだけだからです
(<a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a> 参照)．
このため，GHCiにインタプリタを使ってモジュールのロードを強制したいことがあるかもしれません．
そうするには <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> を使うときにモジュール名またはファイル名の前に*を置きます．
たとえば，以下のようにします．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :load *A
Compiling A                ( A.hs, interpreted )
*A&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">*</span></code> を使うと，GHCiはコンパイル済みオブジェクトコードがあっても無視し，モジュールを解釈実行します．
既にモジュールをいくつかオブジェクトコードとしてロードしていて，そのうち1つを解釈実行したいときには，
全部を再ロードせず <code class="docutils literal"><span class="pre">:add</span> <span class="pre">*M</span></code> を使えば， <code class="docutils literal"><span class="pre">M</span></code> だけを解釈実行することを指定できます．
(これによって別のモジュールも解釈実行されるかもしれないことに注意してください．
これは，コンパイル済みモジュールは解釈実行モジュールに依存できないためです．)</p>
<p>いつでも，すべてコンパイル済みのオブジェクトコードにしたければ，
インタプリタを使ってはいけません．
<a class="reference internal" href="phases.html#ghc-flag--fobject-code"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fobject-code</span></code></a> オプションを使ってください(<a class="reference internal" href="#ghci-obj"><span>Compiling to object code inside GHCi</span></a> 参照)．</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">GHCi はコンパイル済みの版が最新であることが確かな場合にしか，
コンパイル済みオブジェクトファイルを使わないので，
大きいプロジェクトでは，ときどき <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--make</span></code> を実行してプロジェクト全体をコンパイルし
(たとえば，昼食を食べに行く前にね)，解釈実行器を使って作業を続けるというのが良い方法です．
コードを変更したときは，そのモジュールは解釈実行されますが，プロジェクト中の他の部分は
変わらずコンパイル済みのものが使われます．</p>
</div>
</div>
<div class="section" id="interactive-evaluation">
<span id="id14"></span><h2>5.4. プロンプトで対話的に評価する<a class="headerlink" href="#interactive-evaluation" title="Permalink to this headline">¶</a></h2>
<p>プロンプトに式を入力すると，GHCi はただちに評価して結果を表示します．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; reverse &quot;hello&quot;
&quot;olleh&quot;
Prelude&gt; 5+5
10
</pre></div>
</div>
<div class="section" id="i-o">
<span id="actions-at-prompt"></span><h3>5.4.1. プロンプトでのI/Oアクション<a class="headerlink" href="#i-o" title="Permalink to this headline">¶</a></h3>
<p>GHCi がプロンプトで行うのは単なる式の評価だけではありません．
ある型 <code class="docutils literal"><span class="pre">a</span></code> に関して <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> 型の式を入力すると，GHCiはそれをIOコンピュテーションとして
<em>実行</em> します．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; &quot;hello&quot;
&quot;hello&quot;
Prelude&gt; putStrLn &quot;hello&quot;
hello
</pre></div>
</div>
<p>式の型がより一般的なものであっても <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> に <em>具体化</em> することができる限り動作します．
それ例が以下です．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; return True
True
</pre></div>
</div>
<p>さらに，GHCiは以下の条件を満す場合(かつその限りにおいて)，I/Oアクションの結果を表示します．</p>
<ul class="simple">
<li>結果の型が <code class="docutils literal"><span class="pre">Show</span></code> のインスタンスの場合．</li>
<li>結果の型が <code class="docutils literal"><span class="pre">()</span></code> ではない場合．</li>
</ul>
<p>以下はその例です．ただし， <code class="docutils literal"><span class="pre">putStrLn</span> <span class="pre">::</span> <span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code> です．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; putStrLn &quot;hello&quot;
hello
Prelude&gt; do { putStrLn &quot;hello&quot;; return &quot;yes&quot; }
hello
&quot;yes&quot;
</pre></div>
</div>
</div>
<div class="section" id="do">
<span id="ghci-stmts"></span><h3>5.4.2. プロンプトで <code class="docutils literal"><span class="pre">do</span></code> 記法を使う<a class="headerlink" href="#do" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-6"></span><p>実際には，GHCiはプロンプトで受け付けているのは単なる式ではなく文です．
そのため，値や関数を名前に束縛して，後で式や文の中で使うことができます．</p>
<p>The syntax of a statement accepted at the GHCi prompt is exactly the
GHCiがプロンプトで受け付ける文の構文は，Haskellのdo式における文の構文と全く同じです．
ただし，こちらにはモナドの多重定義はありません．
プロンプトに入力される文はIOモナドの中になければなりません．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; x &lt;- return 42
Prelude&gt; print x
42
Prelude&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">x</span> <span class="pre">&lt;-</span> <span class="pre">return</span> <span class="pre">42</span></code> という文は「<code class="docutils literal"><span class="pre">return</span> <span class="pre">42</span></code> を <code class="docutils literal"><span class="pre">IO</span></code> モナド内で実行し，
その結果で <code class="docutils literal"><span class="pre">x</span></code> を束縛する」という意味です．
以降 <code class="docutils literal"><span class="pre">x</span></code> は文の中で使用できます．
たとえば，上でしたように値を印字できます．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fprint-bind-result">
<code class="descname">-fprint-bind-result</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fprint-bind-result" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghc-flag--fprint-bind-result"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fprint-bind-result</span></code></a> が設定されていれば，GHCiは次の場合(かつ，その場合に限り)
文の結果を表示します．</p>
<ul class="simple">
<li>当該の文が束縛ではないか，1つの変数だけを束縛するモナド束縛(<code class="docutils literal"><span class="pre">p</span> <span class="pre">&lt;-</span> <span class="pre">e</span></code>)の場合．</li>
<li>変数の型が多相的でなく， <code class="docutils literal"><span class="pre">()</span></code> でもなく， <code class="docutils literal"><span class="pre">Show</span></code> のインスタンスである場合．</li>
</ul>
</dd></dl>

<p>もちろん，<code class="docutils literal"><span class="pre">let</span></code> 文を使って，ふつうの非IO式で束縛することもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; let x = 42
Prelude&gt; x
42
Prelude&gt;
</pre></div>
</div>
<p>この2種類の束縛のもうひとつ重要な違いは，
モナド束縛(<code class="docutils literal"><span class="pre">p</span> <span class="pre">&lt;-</span> <span class="pre">e</span></code>)は <em>正格</em> (<code class="docutils literal"><span class="pre">e</span></code> を評価)ですが，
<code class="docutils literal"><span class="pre">let</span></code> 形式では式はすぐには評価されないということです．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; let x = error &quot;help!&quot;
Prelude&gt; print x
*** Exception: help!
Prelude&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">let</span></code> 束縛では，モナド束縛とは違い，束縛値が自動的に表示されることはありません．</p>
<p>プロンプトで関数を定義することもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; add a b = a + b
Prelude&gt; add 1 2
3
Prelude&gt;
</pre></div>
</div>
<p>しかし，複数の節からなる関数を定義したり，相互再帰的な関数を定義したりしようとすると，
このやりかたはすぐ面倒になります．
レイアウト規則が使えず，定義全体を明示的なブレースとセミコロンを使って一行で与えないといけないからです．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; f op n [] = n ; f op n (h:t) = h `op` f op n t
Prelude&gt; f (+) 0 [1..3]
6
Prelude&gt;
</pre></div>
</div>
<p>この問題を軽減するために，GHCi コマンドは複数行に渡って書くことができるようになっています．
<code class="docutils literal"><span class="pre">:{</span></code> および <code class="docutils literal"><span class="pre">:}</span></code> で，それぞれ1行を使います．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :{
Prelude| g op n [] = n
Prelude| g op n (h:t) = h `op` g op n t
Prelude| :}
Prelude&gt; g (*) 1 [1..3]
6
</pre></div>
</div>
<p>Such multiline commands can be used with any GHCi command, and note that
このような複数行コマンドは任意のGHCiコマンドについて用いることができます．
このときレイアウト規則が有効であることに注意してください．
複数行コマンドの主な目的は，モジュールのロードの代替にすることではなく，
.ghciファイル(<a class="reference internal" href="#ghci-dot-files"><span>The .ghci and .haskeline files</span></a> 参照)での定義を読みやすく保守しやするするためです．</p>
<p>Any exceptions raised during the evaluation or execution of the
文を評価または実行している間に発生した例外は，GHCiのコマンド行インターフェイスによって捕捉され，
表示されます(例外について詳しくはライブラリドキュメント <code class="docutils literal"><span class="pre">Control.Exception</span></code>
モジュールのライブラリ <a class="reference external" href="../libraries/base-4.9.1.0/Control-Exception.html">文書</a> を参照してください)．</p>
<p>新しい束縛は，同じ名前の既存の束縛をシャドウし(覆い隠し)ます．
これは現在のモジュールの文脈でスコープにある実体もシャドウします．</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">プロンプトで導入さた束縛あ一時的なもので，
次に <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> あるいは <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> コマンドが実行されるまでの間のことです．
これらのコマンドが実行されると，一時的な束縛は消えてしまいます．
ただし，<a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a>: で文脈を変更しても一時的は束縛は新しい場所へ移動し，
消えることはありません．</p>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p><a class="reference internal" href="#ghci-cmd-:show bindings"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">bindings</span></code></a> コマンドを使えば，その時点でスコープにある束縛の一覧がえられます．</p>
<div class="last highlight-none"><div class="highlight"><pre>Prelude&gt; :show bindings
x :: Int
Prelude&gt;
</pre></div>
</div>
</div>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p><code class="docutils literal"><span class="pre">+t</span></code> オプションを指定すると，GHCi は文が束縛したそれぞれの変数の型を表示するようになります．
以下はその例です．</p>
<div class="last highlight-none"><div class="highlight"><pre>Prelude&gt; :set +t
Prelude&gt; let (x:xs) = [1..]
x :: Integer
xs :: [Integer]
</pre></div>
</div>
<span class="target" id="index-7"></span></div>
</div>
<div class="section" id="ghci-multiline">
<span id="id15"></span><h3>5.4.3. 複数行入力<a class="headerlink" href="#ghci-multiline" title="Permalink to this headline">¶</a></h3>
<p>上で説明しあた <code class="docutils literal"><span class="pre">:{</span> <span class="pre">...</span> <span class="pre">:}</span></code> 構文による複数行入力のほかに，GHCiでは <code class="docutils literal"><span class="pre">:set</span> <span class="pre">+m</span></code>
とすると有効になる複数行モードがあります．
このモードでは，現在の文が入力途中であることをGHCiが自動的に検出します．
その先の入力ができるようになります．
複数行入力は空行で終端します．
実際の入力例は以下のとおりです．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :set +m
Prelude&gt; let x = 42
Prelude|
</pre></div>
</div>
<p>この <code class="docutils literal"><span class="pre">let</span></code> 文にはさらに束縛を追加できます．
GHCiのプロンプトが変り，直前の行の続きを入力できることが判ります．
レイアウト規則は有効ですので，この <code class="docutils literal"><span class="pre">let</span></code> にさらに束縛を加えるには
束縛の先頭位置をそろえる必要があることに注意してください．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :set +m
Prelude&gt; let x = 42
Prelude|     y = 3
Prelude|
Prelude&gt;
</pre></div>
</div>
<p>レイアウトではなく明示的にブレースをセミコロンを使うこともできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; do {
Prelude| putStrLn &quot;hello&quot;
Prelude| ;putStrLn &quot;world&quot;
Prelude| }
hello
world
Prelude&gt;
</pre></div>
</div>
<p>閉じブレースの後は，現在の文がおわっていることが判るので，空行は必要ありません．</p>
<p>複数行モードはモナドの <code class="docutils literal"><span class="pre">do</span></code> 文を入力するのに便利です．</p>
<div class="highlight-none"><div class="highlight"><pre>Control.Monad.State&gt; flip evalStateT 0 $ do
Control.Monad.State| i &lt;- get
Control.Monad.State| lift $ do
Control.Monad.State|   putStrLn &quot;Hello World!&quot;
Control.Monad.State|   print i
Control.Monad.State|
&quot;Hello World!&quot;
0
Control.Monad.State&gt;
</pre></div>
</div>
<p>複数行モードで入力中に中断してトップレベルのプロンプトに戻ることもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; do
Prelude| putStrLn &quot;Hello, World!&quot;
Prelude| ^C
Prelude&gt;
</pre></div>
</div>
</div>
<div class="section" id="ghci-decls">
<span id="id16"></span><h3>5.4.4. 型，クラス，その他の宣言<a class="headerlink" href="#ghci-decls" title="Permalink to this headline">¶</a></h3>
<p>GHCi のプロンプトには，Haskellの任意のトップレベル宣言を入力できます．
これには <code class="docutils literal"><span class="pre">data</span></code> ， <code class="docutils literal"><span class="pre">type</span></code> ， <code class="docutils literal"><span class="pre">newtype</span></code> ， <code class="docutils literal"><span class="pre">class</span></code> ， <code class="docutils literal"><span class="pre">instance</span></code> ，
<code class="docutils literal"><span class="pre">deriving</span></code> ， <code class="docutils literal"><span class="pre">foreign</span></code> 宣言が含まれています．
例は以下のとおり．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; data T = A | B | C deriving (Eq, Ord, Show, Enum)
Prelude&gt; [A ..]
[A,B,C]
Prelude&gt; :i T
data T = A | B | C      -- Defined at &lt;interactive&gt;:2:6
instance Enum T -- Defined at &lt;interactive&gt;:2:45
instance Eq T -- Defined at &lt;interactive&gt;:2:30
instance Ord T -- Defined at &lt;interactive&gt;:2:34
instance Show T -- Defined at &lt;interactive&gt;:2:39
</pre></div>
</div>
<p>As with ordinary variable bindings, later definitions shadow earlier
通常の変数束縛と同様に，後で定義されたものは古い定義をシャドウしてしまうので，
定義を再入力すれば，問題を修正したり拡張したりできます．
ただし，落とし穴があります．
新しい型宣言が古い型宣言をシャドウするとき，古い型の定義を参照している別の宣言があるかもしれません．
この古い型はまだ存在し，この別の宣言はまだ古い型を参照しているということを覚えておいてください．
古い型と新しい型は同じ名前ですが，GHCiはこれらを区別するということです．
たとえば，</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; data T = A | B
Prelude&gt; let f A = True; f B = False
Prelude&gt; data T = A | B | C
Prelude&gt; f A

&lt;interactive&gt;:4:3: error:
    • Couldn&#39;t match expected type ‘Ghci1.T’
                  with actual type ‘T’
      NB: ‘T’ is defined at &lt;interactive&gt;:3:1-18
          ‘Ghci1.T’ is defined at &lt;interactive&gt;:1:1-14
    • In the first argument of ‘f’, namely ‘A’
      In the expression: f A
      In an equation for ‘it’: it = f A
Prelude&gt;
</pre></div>
</div>
<p>シャドウされた古いほうの <code class="docutils literal"><span class="pre">T</span></code> は <code class="docutils literal"><span class="pre">Ghci1.T</span></code> と表示されています．
これは，単に <code class="docutils literal"><span class="pre">T</span></code> と表示されている新しい方と区別するためです．</p>
<p>クラスや型族のインスタンス宣言は，単に利用可能なインスタンスの一覧に追加されるだけです．
ただし例外が一つあります．
クラスや型族インスタンスは再定義したいこともあるので，
頭部あるいは左辺が同一であるインスタンスはそれぞれ新しいもので <em>置き換える</em> ことになります
(<a class="reference internal" href="glasgow_exts.html#type-families"><span>Type families</span></a> 参照)．</p>
</div>
<div class="section" id="ghci-scope">
<span id="id17"></span><h3>5.4.5. プロンプトのスコープにあるもの<a class="headerlink" href="#ghci-scope" title="Permalink to this headline">¶</a></h3>
<p>プロンプトに式を入力するとき，どの識別子や型がスコープにあるのでしょうか．
以下のように，GHCiでは，式を評価する際の環境を構成する方法を正確に指定できます．</p>
<ul class="simple">
<li><a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> コマンド
(<a class="reference internal" href="#ghci-load-scope"><span>スコープ内容に対する :load の影響</span></a>)．</li>
<li><code class="docutils literal"><span class="pre">import</span></code> 宣言(<a class="reference internal" href="#ghci-import-decl"><span>import によるスコープ制御</span></a>)．</li>
<li><a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> コマンド(<a class="reference internal" href="#ghci-module-cmd"><span>:module コマンドによるスコープ制御</span></a>)．</li>
</ul>
<p><a class="reference internal" href="#ghci-cmd-:show imports"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">imports</span></code></a> を使えば，トップレベルのスコープにどのモジュールがあるか要約を表示できます．</p>
<div class="admonition hint">
<p class="first admonition-title">Hint</p>
<p class="last">GHCi ではスコープ内にある名前をタブ補完できます．
たとえば，GHCiを起動して <code class="docutils literal"><span class="pre">J&lt;tab&gt;</span></code> と入力すると <code class="docutils literal"><span class="pre">Just</span></code> と展開されます．</p>
</div>
<div class="section" id="load">
<span id="ghci-load-scope"></span><h4>5.4.5.1. スコープ内容に対する <code class="docutils literal"><span class="pre">:load</span></code> の影響<a class="headerlink" href="#load" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> コマンド
(<a class="reference internal" href="#loading-source-files"><span>ソースファイルをロードする</span></a> と <a class="reference internal" href="#ghci-compiled"><span>コンパイル済みコードをロードする</span></a> を参照) はトップレベルのスコープに影響します．
単純な場合から始めましょう．
GHCi を起動すると最初のプロンプトは以下のようになります．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt;
</pre></div>
</div>
<p>これは現在のスコープにあるものはすべて <code class="docutils literal"><span class="pre">Prelude</span></code> モジュール由来であるということを示しています．
ここで見える識別子は <code class="docutils literal"><span class="pre">import</span></code> 宣言のないHaskellのソースファイルから見える識別子と一致しています．</p>
<p>ここで，GHCiにファイルをロードすると，プロンプトは変化します．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :load Main.hs
Compiling Main             ( Main.hs, interpreted )
*Main&gt;
</pre></div>
</div>
<p>新しいプロンプトは <code class="docutils literal"><span class="pre">*Main&gt;</span> <span class="pre">``</span> <span class="pre">です．</span>
<span class="pre">これはプロンプトに入力した式の文脈が</span> <span class="pre">``Main</span></code> モジュールのトップレベルの文脈であることを示しています．
ロードした <code class="docutils literal"><span class="pre">Main</span></code> モジュールのトップレベルのスコープにあるものはすべて，
このプロンプトのスコープにあります
(<code class="docutils literal"><span class="pre">Main</span></code> が明示的に隠蔽していなければ <code class="docutils literal"><span class="pre">Prelude</span></code> も含まれます）．</p>
<p>プロンプトの <code class="docutils literal"><span class="pre">*module</span></code> という構文は，このプロンプトに入力した式のスコープは
⟨module⟩ のトップレベルのスコープであることを示しています．
<code class="docutils literal"><span class="pre">*</span></code> が付かない場合は当該モジュールからエクスポートされたものだけが見えるということです．</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">技術的理由により，GHCi が <code class="docutils literal"><span class="pre">*</span></code> 形式で表示できるのは解釈実行するモジュールに限られます．
コンパイル済みのモジュールおよびパッケージモジュールの場合は，それらから，エクスポート
されたものだけが現在のスコープに入ります．
GHCi が解釈実行版のモジュールをロードするようにするには，モジュールをロードするときに
<code class="docutils literal"><span class="pre">*</span></code> を付けます．たとえば <code class="docutils literal"><span class="pre">:load</span> <span class="pre">*M</span></code> のようにロードします．</p>
</div>
<p>一般に <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> コマンドが発行された後，直近にロードされた「ターゲット」モジュールに対する
インポートが自動的にスコープに追加されます．
このとき，可能なら <code class="docutils literal"><span class="pre">*</span></code> 形式が使われます．
たとえば <code class="docutils literal"><span class="pre">:load</span> <span class="pre">foo.hs</span> <span class="pre">bar.hs</span></code> と入力したとき <code class="docutils literal"><span class="pre">bar.hs</span></code> に <code class="docutils literal"><span class="pre">Bar</span></code> というモジュールがあるとすると，
<code class="docutils literal"><span class="pre">Bar</span></code> が解釈実行されているなら，スコープは <code class="docutils literal"><span class="pre">*Bar</span></code> に設定され， <code class="docutils literal"><span class="pre">Bar</span></code> がコンパイル済みなら，
スコープは <code class="docutils literal"><span class="pre">Prelude</span> <span class="pre">Bar</span></code> になります
(GHCiは <code class="docutils literal"><span class="pre">Prelude</span></code> が指定されておらず，しかも <code class="docutils literal"><span class="pre">*</span></code> 形式のモジュールが一つもなければ <code class="docutils literal"><span class="pre">Prelude</span></code>
を自動的に付け加えます)．
これらの自動に追加されたインポートについては <a class="reference internal" href="#ghci-cmd-:show imports"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">imports</span></code></a> で表示できます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :load hello.hs
[1 of 1] Compiling Main             ( hello.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; :show imports
:module +*Main -- added automatically
*Main&gt;
</pre></div>
</div>
<p>この自動的に追加されたインポートは，次に <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ，
<a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> あるいは <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> を発行すると別のものに置き換えられます．
通常のインポートと同様に <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> で削除することもできます．</p>
</div>
<div class="section" id="import">
<span id="ghci-import-decl"></span><h4>5.4.5.2. <code class="docutils literal"><span class="pre">import</span></code> によるスコープ制御<a class="headerlink" href="#import" title="Permalink to this headline">¶</a></h4>
<p>GHCi が扱えるのは単一のモジュールだけではありません．
複数のモジュールからのスコープを組み合わせることもできます．
このとき <code class="docutils literal"><span class="pre">*</span></code> 形式とそうでない形式を混ぜて使えます．
GHCi はこのようなモジュールのスコープのを全て組み合わせて，プロンプトのスコープします．</p>
<p>モジュールをスコープに加えるには，通常はHaskellの <code class="docutils literal"><span class="pre">import</span></code> 構文を使います．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; import System.IO
Prelude System.IO&gt; hPutStrLn stdout &quot;hello&quot;
hello
Prelude System.IO&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">hiding</span></code> 節および <code class="docutils literal"><span class="pre">as</span></code> 節を含む完全なHaskellのインポート構文がサポートされています．
プロンプトには現在インポートされているモジュールが表示されていますが，
<code class="docutils literal"><span class="pre">hiding</span></code> や <code class="docutils literal"><span class="pre">as</span></code> やその他の詳細は省略されています．
その部分を知りたければ <a class="reference internal" href="#ghci-cmd-:show imports"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">imports</span></code></a> を使って下さい．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; import System.IO
Prelude System.IO&gt; import Data.Map as Map
Prelude System.IO Map&gt; :show imports
import Prelude -- implicit
import System.IO
import Data.Map as Map
Prelude System.IO Map&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">Prelude</span></code> のインポートについては implicit (暗黙) と表示されることに注意してください．
明示的に <code class="docutils literal"><span class="pre">Prelude</span></code> をインポートすれば，他のモジュールと同じように表示されます．</p>
<p>複数のモジュールがスコープにあるとき，特に複数の <code class="docutils literal"><span class="pre">*</span></code> 形式のモジュールがあるときは，
名前の衝突が起こりやすくなります．
Haskell では名前の衝突が起こったことが報告されるのは，実際に曖昧な名前が使われたときに限ると規定されています．
GHCi もプロンプトで入力される式についてはこれにならった振る舞いをします．</p>
</div>
<div class="section" id="module">
<span id="ghci-module-cmd"></span><h4>5.4.5.3. <code class="docutils literal"><span class="pre">:module</span></code> コマンドによるスコープ制御<a class="headerlink" href="#module" title="Permalink to this headline">¶</a></h4>
<p>スコープを操作するもう1つの方法は <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> コマンドです．
構文は以下のとおりになります．</p>
<div class="highlight-none"><div class="highlight"><pre>:module +|- *mod1 ... *modn
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">+</span></code> 形式の <code class="docutils literal"><span class="pre">module</span></code> コマンドでモジュールを現在のスコープに追加し，
<code class="docutils literal"><span class="pre">-</span></code> 形式でモジュールを現在のスコープから削除します．
<code class="docutils literal"><span class="pre">+</span></code> 形式でも <code class="docutils literal"><span class="pre">-</span></code> 形式でもない場合には，指定されたモジュール群が現在のスコープに置き換わります．
<code class="docutils literal"><span class="pre">+</span></code> 形式でも <code class="docutils literal"><span class="pre">-</span></code> 形式でもなく，<code class="docutils literal"><span class="pre">Prelude</span></code> も指定に含まれていない場合は，
自動的に，暗黙に <code class="docutils literal"><span class="pre">Prelude</span></code> をインポートします．</p>
<p><a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> コマンドでは通常の <code class="docutils literal"><span class="pre">import</span></code> 宣言ではできないことが2つ可能になります．</p>
<ul class="simple">
<li><a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> コマンドでは，モジュールを <code class="docutils literal"><span class="pre">*</span></code> で修飾できます．そうすると，単にモジュールがエクスポートしているものだけではなく，モジュールのトップレベルのスコープが完全にオープンになります．</li>
<li><code class="docutils literal"><span class="pre">:module</span> <span class="pre">-M</span></code> 構文を使うと，文脈からモジュールを削除できます．<code class="docutils literal"><span class="pre">import</span></code> 構文は累積的(Haskellのモジュール内と同様)なので，これがスコープからモジュールを取り除く唯一の方法です．</li>
</ul>
</div>
<div class="section" id="ghci-import-qualified">
<span id="id18"></span><h4>5.4.5.4. 修飾名<a class="headerlink" href="#ghci-import-qualified" title="Permalink to this headline">¶</a></h4>
<p>To make life slightly easier, the GHCi prompt also behaves as if there
手間をすこし省くことができるように，GHCiのプロンプトは全てのパッケージの全てのモジュールと，現在GHCiにロードされている全てのモジュールについて，暗黙の <code class="docutils literal"><span class="pre">import</span> <span class="pre">qualified</span></code> 宣言があるかのように振る舞います．
これは <code class="docutils literal"><span class="pre">-fno-implicit-import-qualified</span></code> というフラグで無効にできます．</p>
<span class="target" id="index-8"></span></div>
<div class="section" id="module-load">
<h4>5.4.5.5. <code class="docutils literal"><span class="pre">:module</span></code> と <code class="docutils literal"><span class="pre">:load</span></code><a class="headerlink" href="#module-load" title="Permalink to this headline">¶</a></h4>
<p><a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a>/<code class="docutils literal"><span class="pre">import</span></code> と <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a>/<a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a>/<a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> とは同じものという気がするかもしれません．
どちらも，モジュールをスコープに入れるために使うものです．
しかし，この2つには大きな違いがあります．
GHCi は2種類のモジュール集合にかかわっています．</p>
<ul class="simple">
<li>現在 <em>ロード済み</em> のモジュール集合．
このモジュール集合は <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> で変更し，
<a class="reference internal" href="#ghci-cmd-:show modules"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">modules</span></code></a> で表示できます．</li>
<li>現在，プロンプトの <em>スコープ内</em> にあるモジュール集合．
このモジュール集合は <code class="docutils literal"><span class="pre">import</span></code> および <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> で変更します．
<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> コマンドを発行すると
このモジュール集合は，上述のように自動的に変更されます．
表示するためには <a class="reference internal" href="#ghci-cmd-:show imports"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">imports</span></code></a> を使います．</li>
</ul>
<p>(<a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> あるいは <code class="docutils literal"><span class="pre">import</span></code> 経由)モジュールをスコープに追加できるのは，
(a) ロード済みのモジュール，(b) GHCiが知っているパッケージ由来のモジュール，のどちらかだけです．
<a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> あるいは <code class="docutils literal"><span class="pre">import</span></code> を使って，ロードされていないモジュールをスコープに
追加しようとすると <code class="docutils literal"><span class="pre">module</span> <span class="pre">M</span> <span class="pre">is</span> <span class="pre">not</span> <span class="pre">loaded</span></code> というメッセージが表示されることでしょう．</p>
</div>
</div>
<div class="section" id="main-run">
<h3>5.4.6. <code class="docutils literal"><span class="pre">:main</span></code> コマンドと <code class="docutils literal"><span class="pre">:run</span></code> コマンド<a class="headerlink" href="#main-run" title="Permalink to this headline">¶</a></h3>
<p>プログラムをコンパイルして実行するとき <code class="docutils literal"><span class="pre">getArgs</span></code> 関数を使っていれば，コマンドライン引数にアクセスできます．
しかし <code class="docutils literal"><span class="pre">main</span></code> は直接引数を取りませんので，ghci でテストしているときは単純にコマンドライン引数を渡すことができません．</p>
<p>その代りとして <a class="reference internal" href="#ghci-cmd-:main"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:main</span></code></a> コマンドを使います．
このコマンドはスコープ内にある <code class="docutils literal"><span class="pre">main</span></code> を以下のようにコマンドライン引数を渡した状態にして起動します．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; main = System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :main foo bar
[&quot;foo&quot;,&quot;bar&quot;]
</pre></div>
</div>
<p>スペースのような文字を含む文字列は引用符でかこって渡せます．
引数はそれぞれHaskellの文字列として扱われます．
また，Haskellのリスト構文をそのまま使うこともできます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :main foo &quot;bar baz&quot;
[&quot;foo&quot;,&quot;bar baz&quot;]
Prelude&gt; :main [&quot;foo&quot;, &quot;bar baz&quot;]
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
<p>また <code class="docutils literal"><span class="pre">-main-is</span></code> フラグや <a class="reference internal" href="#ghci-cmd-:run"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:run</span></code></a> コマンドを使えば，その他の関数を呼べます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; foo = putStrLn &quot;foo&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; bar = putStrLn &quot;bar&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :set -main-is foo
Prelude&gt; :main foo &quot;bar baz&quot;
foo
[&quot;foo&quot;,&quot;bar baz&quot;]
Prelude&gt; :run bar [&quot;foo&quot;, &quot;bar baz&quot;]
bar
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
</div>
<div class="section" id="it">
<h3>5.4.7. <code class="docutils literal"><span class="pre">it</span></code> 変数<a class="headerlink" href="#it" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-9"></span><p>プロンプトに式(正確には非束縛文)を入力すると，
GHCi は暗黙のうちにその値で <code class="docutils literal"><span class="pre">it</span></code> を束縛します．
以下はその一例です．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; 1+2
3
Prelude&gt; it * 2
6
</pre></div>
</div>
<p>実際はなにが起こっているかというと，GHCi は型検査を行い，その式の型が <code class="docutils literal"><span class="pre">IO</span></code> 型でなければ，
次のように変形します．
すなわち，ここで当該の式を <code class="docutils literal"><span class="pre">e</span></code> とすると,</p>
<div class="highlight-none"><div class="highlight"><pre>let it = e;
print it
</pre></div>
</div>
<p>のように変形したのち，これをIOアクションとして実行します．</p>
<p>そういう訳で，元の式の型は <code class="docutils literal"><span class="pre">Show</span></code> クラスのインスタンスでなければなりません．
<code class="docutils literal"><span class="pre">Show</span></code> クラスのインスタンスでなかったら，GHCiは文句をいいます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; id

&lt;interactive&gt;:1:0:
    No instance for (Show (a -&gt; a))
      arising from use of `print&#39; at &lt;interactive&gt;:1:0-1
    Possible fix: add an instance declaration for (Show (a -&gt; a))
    In the expression: print it
    In a &#39;do&#39; expression: print it
</pre></div>
</div>
<p>このエラーメッセージから，内部の変形で何が起こったのか少しだけうかがい知ることができます．</p>
<p>式の型がなにがしかの型 <code class="docutils literal"><span class="pre">a</span></code> について <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> 型である場合には，
<code class="docutils literal"><span class="pre">it</span></code> はその <code class="docutils literal"><span class="pre">IO</span></code> コンピュテーションの結果，つまり <code class="docutils literal"><span class="pre">a</span></code> 型の値で束縛されます．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; Time.getClockTime
Wed Mar 14 12:23:13 GMT 2001
Prelude&gt; print it
Wed Mar 14 12:23:13 GMT 2001
</pre></div>
</div>
<p>IO型の式 <code class="docutils literal"><span class="pre">e</span></code> に対する変形は，</p>
<div class="highlight-none"><div class="highlight"><pre>it &lt;- e
</pre></div>
</div>
<p>となります．</p>
<p>新しい式を評価するたびに <code class="docutils literal"><span class="pre">it</span></code> の値は新しい値でシャドウされ，古い <code class="docutils literal"><span class="pre">it</span></code> の値は失われることに注意してください．</p>
</div>
<div class="section" id="extended-default-rules">
<span id="id19"></span><h3>5.4.8. GHCi でのデフォルト型設定<a class="headerlink" href="#extended-default-rules" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-10"></span><p>次のGHCiセッションを考えていみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>ghci&gt; reverse []
</pre></div>
</div>
<p>GHCi は何をすべきでしょうか．
厳密にいえば，このプログラムは曖昧です．
<code class="docutils literal"><span class="pre">show</span> <span class="pre">(reverse</span> <span class="pre">[])</span></code> (ここでGHCiが計算するのはこれです)の型は，
<code class="docutils literal"><span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">String</span></code> であり，これをどのように表示するかは <code class="docutils literal"><span class="pre">a</span></code> の型に依存します．
たとえば，</p>
<div class="highlight-none"><div class="highlight"><pre>ghci&gt; reverse ([] :: String)
&quot;&quot;
ghci&gt; reverse ([] :: [Int])
[]
</pre></div>
</div>
<p>のようになります．
しかし，ユーザがこの型を指定しなければならないというのは面倒なので，
GHCiはHaskellのデフォルト型設定規則(Haskell 2010 Report の 4.3.4 節)
を以下のように拡張しています．
標準の規則では，個々の型変数 <code class="docutils literal"><span class="pre">a</span></code> についてのそれぞれ制約グループ <code class="docutils literal"><span class="pre">(C1</span> <span class="pre">a,</span> <span class="pre">C2</span> <span class="pre">a,</span> <span class="pre">...,</span> <span class="pre">Cn</span> <span class="pre">a)</span></code> を考え，
次の条件が満たされたとき，この型変数のデフォルトの型を設定します．</p>
<ol class="arabic simple">
<li>型変数 <code class="docutils literal"><span class="pre">a</span></code> が他のどの制約にも現れない．</li>
<li>クラス <code class="docutils literal"><span class="pre">Ci</span></code> はすべて標準のクラスである．</li>
<li>クラス <code class="docutils literal"><span class="pre">Ci</span></code> の少くとも1つは数値である．</li>
</ol>
<p>GHCiプロンプトあるいはGHCでは <code class="xref std std-ghc-flag docutils literal"><span class="pre">-XExtendedDefaultRules</span></code> フラグが設定されていると，
以下のような規則変更がおこなわれます．</p>
<ul class="simple">
<li>規則2の緩和: クラス <code class="docutils literal"><span class="pre">Ci</span></code> は <em>すべて</em> 単一パラメータの型クラスである．</li>
<li>規則3の緩和: クラス <code class="docutils literal"><span class="pre">Ci</span></code> のうち少くとも1つは数値であるか <code class="docutils literal"><span class="pre">Show</span></code> ， <code class="docutils literal"><span class="pre">Eq</span></code> ， <code class="docutils literal"><span class="pre">Ord</span></code> ， <code class="docutils literal"><span class="pre">Foldable</span></code> ， <code class="docutils literal"><span class="pre">Traversable</span></code>
のどれかである．</li>
<li>ユニット型 <code class="docutils literal"><span class="pre">()</span></code> およびリスト型 <code class="docutils literal"><span class="pre">[]</span></code> がデフォルトの型として試されるリストの先頭に追加される．</li>
</ul>
<p>最後の点は，たとえば，以下のプログラムに影響します．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="n">def</span>

<span class="kr">instance</span> <span class="kt">Num</span> <span class="nb">()</span>

<span class="nf">def</span> <span class="ow">::</span> <span class="p">(</span><span class="kt">Num</span> <span class="n">a</span><span class="p">,</span> <span class="kt">Enum</span> <span class="n">a</span><span class="p">)</span> <span class="ow">=&gt;</span> <span class="n">a</span>
<span class="nf">def</span> <span class="ow">=</span> <span class="n">toEnum</span> <span class="mi">0</span>
</pre></div>
</div>
<p>このプログラムは <code class="docutils literal"><span class="pre">0</span></code> ではなく <code class="docutils literal"><span class="pre">()</span></code> を表示します．
それは <code class="docutils literal"><span class="pre">a</span></code> のデフォルトの型が <code class="docutils literal"><span class="pre">Integer</span></code> ではなく <code class="docutils literal"><span class="pre">()</span></code> に設定されるからです．</p>
<p>このような変更を行う動機は <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> アクションのデフォルトの型は <code class="docutils literal"><span class="pre">IO</span> <span class="pre">()</span></code> になるので，
これを実行したときghciは結果を表示する面倒がないというものです．
とくに <code class="docutils literal"><span class="pre">printf</span></code> にとってはこれが重要で <code class="docutils literal"><span class="pre">printf</span></code> のインスタンスで <code class="docutils literal"><span class="pre">IO</span> <span class="pre">a</span></code> を返すものがありますが，
それができることといえば <code class="docutils literal"><span class="pre">undefined</span></code> を返すこと以外ありません
(printf が型クラスシステムの拡張を必要としないようにというのがその理由)．
したがって，もしここでデフォルトの型が <code class="docutils literal"><span class="pre">Integer</span></code> だと，printfを走らせると，ghciがエラーになってしまいます．</p>
<p>計算を扱うモナドは，可能であるなら <code class="docutils literal"><span class="pre">IO</span></code> がデフォルトであることについては <a class="reference internal" href="#actions-at-prompt"><span>プロンプトでのI/Oアクション</span></a> を参照してください．</p>
</div>
<div class="section" id="ghci-interactive-print">
<span id="id20"></span><h3>5.4.9. 独自の対話表示関数を使う<a class="headerlink" href="#ghci-interactive-print" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-11"></span><p>GHC 7.6.1 以降，GHCiはプロンプトに入力された式の結果を <code class="docutils literal"><span class="pre">System.IO.print</span></code> を使って表示します．
この関数の型シグネチャは <code class="docutils literal"><span class="pre">Show</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code> で，値を <code class="docutils literal"><span class="pre">show</span></code> を使って <code class="docutils literal"><span class="pre">String</span></code> に変換しています．</p>
<p>このやり方が理想的ではない場合があります．
出力が長い場合や非アスキー文字が含まれるというような場合です．</p>
<p><a class="reference internal" href="#ghc-flag--interactive-print"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-interactive-print</span></code></a> フラグを使えば，何らかの制約を <code class="docutils literal"><span class="pre">C</span></code> として，
<code class="docutils literal"><span class="pre">C</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code> という型の関数を評価済みの式の値を表示する関数として指定できるようになります．
この関数はロード済みのモジュールまたは登録済みのパッケージに置いてあればよいのですが，
登録済みのパッケージに置いてある場合のみ <a class="reference internal" href="#ghci-cmd-:cd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cd</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:add"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:add</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> ， <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> あるいは <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> というコマンドをくぐり抜けられます．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--interactive-print">
<code class="descname">-interactive-print</code><code class="descclassname"> ⟨expr⟩</code><a class="headerlink" href="#ghc-flag--interactive-print" title="Permalink to this definition">¶</a></dt>
<dd><p>GHCiが評価結果を表示するのに使う関数を設定します．
このとき〈expr〉の型は <code class="docutils literal"><span class="pre">C</span> <span class="pre">a</span> <span class="pre">=&gt;</span> <span class="pre">a</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">()</span></code> でなければなりません．</p>
</dd></dl>

<p>例として，以下の特別な表示モジュールがあるとしましょう．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">module</span> <span class="nn">SpecPrinter</span> <span class="kr">where</span>
<span class="kr">import</span> <span class="nn">System.IO</span>

<span class="nf">sprint</span> <span class="n">a</span> <span class="ow">=</span> <span class="n">putStrLn</span> <span class="o">$</span> <span class="n">show</span> <span class="n">a</span> <span class="o">++</span> <span class="s">&quot;!&quot;</span>
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">sprint</span></code> 関数は表示された値の最後に感嘆符を追加します．
以下のコマンド</p>
<div class="highlight-none"><div class="highlight"><pre>ghci -interactive-print=SpecPrinter.sprinter SpecPrinter
</pre></div>
</div>
<p>でGHCiを起動すると，対話セッションが始まり，そこでは値は <code class="docutils literal"><span class="pre">sprint</span></code> で表示されます．</p>
<div class="highlight-none"><div class="highlight"><pre>*SpecPrinter&gt; [1,2,3]
[1,2,3]!
*SpecPrinter&gt; 42
42!
</pre></div>
</div>
<p>これには独自の整形表示関数が使えます．
たとえばツリー構造や入れ子構造をよりよみやすい形式で表示できます．</p>
<p><a class="reference internal" href="#ghc-flag--interactive-print"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-interactive-print</span></code></a> フラグはGHCを <code class="docutils literal"><span class="pre">-e</span> <span class="pre">mode</span></code> で起動したときにも使えます．</p>
<div class="highlight-none"><div class="highlight"><pre>% ghc -e &quot;[1,2,3]&quot; -interactive-print=SpecPrinter.sprint SpecPrinter
[1,2,3]!
</pre></div>
</div>
</div>
<div class="section" id="ghci-stack-traces">
<span id="id21"></span><h3>5.4.10. GHCiのスタックトレース<a class="headerlink" href="#ghci-stack-traces" title="Permalink to this headline">¶</a></h3>
<span class="target" id="index-12"></span><p>[ この機能は GHC 8.0.1 で導入された実験的機能で，
<code class="docutils literal"><span class="pre">-fexternal-interpreter</span></code> フラグで有効になります．
現時点ではWindowsでは利用できません．]</p>
<p>GHCi では解釈実行コードを走らせるときに，プロファイリングシステムを使って，
スタックトレース情報を収集できます．
スタックトレースにアクセスするには，GHCiを次のように起動します．</p>
<div class="highlight-none"><div class="highlight"><pre>ghci -fexternal-interpreter -prof
</pre></div>
</div>
<p>こうすると，解釈実行コードは別プロセスで(<a class="reference internal" href="#external-interpreter"><span>Running the interpreter in a separate process</span></a> 参照)，
プロファイリングモードで走らせてコールスタック情報を収集します．
解釈実行コードをプロファイリングモードで走らせることになりますので，
使用するすべてのパッケージはプロファイリング用にコンパイルされている必要があります．
GHCi に対する <code class="docutils literal"><span class="pre">-prof</span></code> フラグは <code class="docutils literal"><span class="pre">-fexternal-interpreter</span></code> と同時に使うときだけ有効です．</p>
<p>現在のコールスタックにアクセスする方法は3つあります．</p>
<ul class="simple">
<li><code class="docutils literal"><span class="pre">error</span></code> と <code class="docutils literal"><span class="pre">undefined</span></code> は自動的にエラーメッセージにカレントスタックをアタッチします．
これは通常 <code class="docutils literal"><span class="pre">HasCallStack</span></code> スタック(<a class="reference internal" href="glasgow_exts.html#hascallstack"><span>HasCallStack</span></a> 参照)を補足するもので，
その時には両方のスタックが表示されます．</li>
<li><code class="docutils literal"><span class="pre">Debug.Trace.traceStack</span></code> は <code class="docutils literal"><span class="pre">Debug.Trace.trace</span></code> の変形版で現在のコールスタックも表示します．</li>
<li><code class="docutils literal"><span class="pre">GHC.Stack</span></code> にある関数を使って現在のスタックを取得し，表示できます．</li>
</ul>
<p>解釈実行するモジュールについては <code class="docutils literal"><span class="pre">-fprof-auto</span></code> を使う必要はありません．
注釈は自動的に細かく追加されますので，個別のコールサイトを区別できます．
しかしながら，コンパイル済みコードのコールスタック情報は，そのコードを
<code class="docutils literal"><span class="pre">-fprof-auto</span></code> 付きでコンパイルしているか，明示的に <code class="docutils literal"><span class="pre">SCC</span></code> 注釈
(<a class="reference internal" href="profiling.html#scc-pragma"><span>Inserting cost centres by hand</span></a> 参照)を付けていないかぎり見ることはできません．</p>
</div>
</div>
<div class="section" id="ghci-debugger">
<span id="id22"></span><h2>5.5. GHCiのデバッガ<a class="headerlink" href="#ghci-debugger" title="Permalink to this headline">¶</a></h2>
<span class="target" id="index-13"></span><p>GHCi は単純な命令スタイルのデバッガを備えています．
これを使うと，変数の値を確認するために進行中の計算を止められます．
このデバッガはGHCiに統合されていて，デフォルトで有効になっています．
デバッグ機能を有効にするのにフラグは必要ありません．
1つ重要な制限があります．それは，ブレイクポイントとステップ実行は解釈実行されているモジュールでしか使えないということです．
コンパイル済みのコードはデバッガからは見えません <a class="footnote-reference" href="#id31" id="id23">[5]</a> ．</p>
<p>このデバッガが提供する機能は以下のとおりです．</p>
<ul class="simple">
<li>プログラム中の関数定義や式にブレイクポイントを設定する機能．
関数が呼ばれたとき，式が評価されたとき，GHCiは実行を中断しプロンプトに戻ります．
このプロンプトで局所変数の値を調べたあと，実行を再開継続できます．</li>
<li>ステップ実行機能．
評価器はほぼ簡約ごとに実行を中断し，局所変数の値を調べられるようにします．
これはプログラムのあらゆるポイントにブレイクポイントを設定するのと同じことです．</li>
<li>トレースモードでの実行機能．
トレースモードで実行すると，評価器は発生した評価ステップをすべて記憶します．
ただし，実際のブレイクポイントに到達するまでは，実行を中断することはありません．
実行が中断されたら，評価ステップの履歴を調べることができるようになります．</li>
<li>例外(たとえば，パターン照合の失敗あるいは <code class="docutils literal"><span class="pre">error</span></code> など)をブレイクポイントとして扱えます．
これにより，プログラム中の例外発生源を特定しやすくなります．</li>
</ul>
<p>現時点では「スタックトレース」を得る手段は提供されていませんが，
トレース機能と履歴機能が次善の策として提供されており，
エラー発生時の状況を知るには十分であることも多いのです．
たとえコンパイル済みのコードから例外が投げられたときでも，自動的にブレイクするようにできます
(<a class="reference internal" href="#ghci-debugger-exceptions"><span>Debugging exceptions</span></a> 参照)．</p>
<div class="section" id="breakpoints">
<span id="id24"></span><h3>5.5.1. ブレイクポイントと変数内容の表示<a class="headerlink" href="#breakpoints" title="Permalink to this headline">¶</a></h3>
<p>実際に動く例としてクイックソートを使いましょう．以下がそのコードです．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">qsort</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">qsort</span> <span class="p">(</span><span class="n">a</span><span class="kt">:</span><span class="n">as</span><span class="p">)</span> <span class="ow">=</span> <span class="n">qsort</span> <span class="n">left</span> <span class="o">++</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">++</span> <span class="n">qsort</span> <span class="n">right</span>
  <span class="kr">where</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">)</span> <span class="ow">=</span> <span class="p">(</span><span class="n">filter</span> <span class="p">(</span><span class="o">&lt;=</span><span class="n">a</span><span class="p">)</span> <span class="n">as</span><span class="p">,</span> <span class="n">filter</span> <span class="p">(</span><span class="o">&gt;</span><span class="n">a</span><span class="p">)</span> <span class="n">as</span><span class="p">)</span>

<span class="nf">main</span> <span class="ow">=</span> <span class="n">print</span> <span class="p">(</span><span class="n">qsort</span> <span class="p">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">18</span><span class="p">])</span>
</pre></div>
</div>
<p>ます，このモジュールをGHCiにロードしましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :l qsort.hs
[1 of 1] Compiling Main             ( qsort.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt;
</pre></div>
</div>
<p>次に，qsort の定義2つめの等式の右辺にブレイクポイントを設定します．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :break 2
Breakpoint 0 activated at qsort.hs:2:16-47
*Main&gt;
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">:break</span> <span class="pre">2</span></code> というコマンドは直近にロードしたモジュールの2行目にブレイクポイントを設定するものです．
この場合は <code class="docutils literal"><span class="pre">qsort.hs</span></code> の2行目です．
詳しくいえば，ブレイクポイントを設定した行にある完全な部分式のうちもっとも左側にあるものが選ばれます．
この場合は <code class="docutils literal"><span class="pre">(qsort</span> <span class="pre">left</span> <span class="pre">++</span> <span class="pre">[a]</span> <span class="pre">++</span> <span class="pre">qsort</span> <span class="pre">right)</span></code> です．</p>
<p>[&#8211;ここから&#8211; GHC Users Manual 原文の記述とghciの実際の挙動が異なるので，実際の挙動に沿って非公式に説明します．]</p>
<p>さて，このプログラムを走らせてみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; main
Stopped in Main.qsort, qsort.hs:2:16-47
_result :: [Integer] = _
a :: Integer = 8
left :: [Integer] = _
right :: [Integer] = _
[qsort.hs:2:16-47] *Main&gt;
</pre></div>
</div>
<p>[&#8211;ここまで&#8211; 実際の挙動に沿った非公式な記述]</p>
<p>ブレイクポイントのところで実行が中断されました．
プロンプトが変化して，ブレイクポイントで止っていること，
その場所が <code class="docutils literal"><span class="pre">[qsort.hs:2:16-47]</span></code> であることが判ります．
その場所をさらに明確にするには <a class="reference internal" href="#ghci-cmd-:list"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:list</span></code></a> コマンドを使います．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :list
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
</pre></div>
</div>
<p><a class="reference internal" href="#ghci-cmd-:list"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:list</span></code></a> コマンドは，現在のブレイクポイントの周囲のコードを表示します．
出力デバイスがサポートしている場合は，注目している部分式がボールド体で表示されます．</p>
<p>GHCiは，ブレイクポイントを置いた式の自由変数 <a class="footnote-reference" href="#id32" id="id25">[6]</a> (<code class="docutils literal"><span class="pre">a</span></code> ， <code class="docutils literal"><span class="pre">left</span></code> ， <code class="docutils literal"><span class="pre">right</span></code>)
に対する束縛および当該式の結果(<code class="docutils literal"><span class="pre">_result</span></code>)に対する束縛も提供しています．
これらの変数は，GHCi上で普通に定義する他の変数と同じです．
プロンプトで入力する式の中で使ったり， <a class="reference internal" href="#ghci-cmd-:type"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span></code></a> コマンドで型を確認するなどが可能です．</p>
<p>[&#8211;ここから&#8211; GHC Users Manual 原文の記述とghciの実際の挙動が異なるので，実際の挙動に沿って非公式に説明します．]</p>
<p>例を見ましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :type left
left :: [Integer]
</pre></div>
</div>
<p>[&#8211;ここまで&#8211; 実際の挙動に沿って非公式説明]</p>
<p>デバッガにはジェネリックな表示コマンド
<a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> があり，これを使えば，変数の実行時の値と型を調べられます．
<code class="docutils literal"><span class="pre">left</span></code> に対して使ってみましょう．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :print left
left = (_t1::[Integer])
</pre></div>
</div>
<p>あまり細かいことは判りません．
<code class="docutils literal"><span class="pre">left</span></code> は未評価の計算(サスペンションあるいはサンク)に束縛されています．
これは <code class="docutils literal"><span class="pre">left</span></code> は未評価ですが <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> が評価を強制しないからです．</p>
<p><a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> はブレイクポイントで値を検査する際に副作用を起こさないようにしてあるのです．
評価を強制しないので，通常の評価と違う結果になったり，例外が投げられたり，無限ループや別のブレイクポイントに遭遇することもありません
(<a class="reference internal" href="#nested-breakpoints"><span>ブレイクポイントのネスト</span></a> 参照)．
<a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> は各サンクにアンダースコアで始まるフレッシュ(まだ使われていない)変数，ここでは <code class="docutils literal"><span class="pre">_t1</span></code> を束縛します．</p>
<p>[&#8211;ここでは&#8211; GHC Users Manual 原文の記述とghciの実際の挙動が異なる部分に関連する説明を省いています．]</p>
<p>変数の評価状態を変えてしまってかまわないのなら <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> ではなく <a class="reference internal" href="#ghci-cmd-:force"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:force</span></code></a> を使うこともできます．
<a class="reference internal" href="#ghci-cmd-:force"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:force</span></code></a> コマンドはサンクのときは評価を強制する以外は <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> と同じ振る舞いになります．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :force left
left = [4,0,3,1]
</pre></div>
</div>
<p>[&#8211;ここから&#8211; GHC Users Manual 原文の記述とghciの実際の挙動が異なるので，実際の挙動に沿って非公式に説明します．]</p>
<p>ここで <a class="reference internal" href="#ghci-cmd-:show bindings"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">bindings</span></code></a> を使うと，関連する束縛を表示できます．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :show bindings
right :: [Integer] = _
left :: [Integer] = [4,0,3,1]
a :: Integer = 8
_result :: [Integer] = _
_t1 :: [Integer] = [4,0,3,1]
</pre></div>
</div>
<p>式全体を:forceで評価してしまうのではなく，個々のサンクを評価したい場合には，Haskellの
<code class="docutils literal"><span class="pre">seq</span></code> 関数が便利でしょう．以下のように使います．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :print right
right = (_t2::[Integer])
[qsort.hs:2:16-47] *Main&gt; seq _t2 ()
()
[qsort.hs:2:16-47] *Main&gt; :print right
right = 23 : (_t3::[Integer])
</pre></div>
</div>
<p>We evaluated only the <code class="docutils literal"><span class="pre">_t1</span></code> thunk, revealing the head of the list, and
ここでは，サンク <code class="docutils literal"><span class="pre">_t2</span></code> だけを評価して，リストの先頭が判明しました．
<code class="docutils literal"><span class="pre">seq</span></code> 関数はすこし使いにくいので <a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> を使ってもっとよいインターフェイスを作るといいでしょう
(どうするかは練習問題にしておきます！)．</p>
<p>そして，実行を再開することもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :continue
Stopped in Main.qsort, qsort.hs:2:16-47
_result :: [Integer] = _
a :: Integer = 4
left :: [Integer] = _
right :: [Integer] = _
[qsort.hs:2:16-47] *Main&gt;
</pre></div>
</div>
<p>実行が前に停止した点から再開し，同じブレイクで再び停止しました．</p>
<p>[&#8211;ここまで&#8211; 実際の挙動に沿った非公式説明．]</p>
<div class="section" id="setting-breakpoints">
<span id="id26"></span><h4>5.5.1.1. ブレイクポイントの設定<a class="headerlink" href="#setting-breakpoints" title="Permalink to this headline">¶</a></h4>
<p>ブレークポイントを設定する方法はいくつかあります．
おそらくもっとも簡単な方法は最上位の関数の名前を使うことです．</p>
<div class="highlight-none"><div class="highlight"><pre>:break identifier
</pre></div>
</div>
<p>ここで ⟨identifier⟩ はGHCiにロードされて解釈実行されるモジュールのトップレベルにある関数の名前です
(これには修飾名も使えます)．
ブレイクポイントは関数の本体部分に設定されます．
関数が完全に適用されパターン照合が行われる直前に設定されます．</p>
<p>行番号(および列番号)でブレイクポイントを設定することもできます．</p>
<div class="highlight-none"><div class="highlight"><pre>:break line
:break line column
:break module line
:break module line column
</pre></div>
</div>
<p>ブレークポイントを特定の行に設定する場合，GHCiはその行で始まりその行で終わる部分式の中で
もっとも左側にあるものに設定します．
2つの完全な部分式が同じカラムから始まっているなら長い方が選ばれます．
その行に完全な部分式が無い場合，その行で始まっている部分式の中でもっとも左側にあるものが選ばれます．
それも失敗したら，その行を一部あるいは全部覆う式の中でもっとも右側にあるものが選ばれます．</p>
<p>ブレークポイントを特定の行の特定のカラムに設定する場合，GHCiはその位置を含む式の中で最小のものを選びます．
注意: GHCはTAB文字を現れた位置に関わらず幅1とみなします．
言い換えれば，カラム数を数えるのではなく文字を数えます．
振る舞いと合うエディタもあり，合わないエディタもあります．
最善はそもそもソースコード中でタブ文字を使わないことです
(<a class="reference internal" href="using-warnings.html#options-sanity"><span>Warnings and sanity-checking</span></a> にある <a class="reference internal" href="using-warnings.html#ghc-flag--Wtabs"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wtabs</span></code></a> を参照してください)．</p>
<p>モジュールが省略された場合，直近にロードされたモジュールが使われます．</p>
<p>ブレークポイントを設定できない部分式もあります．
単一の変数は通常ブレークポイント位置とはみなされません(ただし，その変数が関数定義かλかcaseの選択肢の右辺である場合は除きます)．
大まかにいうと，ブレークポイントになるのは，全ての簡約基，関数やλ抽象の本体，caseの選択肢，束縛文です．
通常let式はブレークポイントになりませんが，その本体は常にブレークポイントになります．
そのletで束縛された変数の値を調べたいと思うのが普通だからです．</p>
</div>
<div class="section" id="id27">
<h4>5.5.1.2. ブレイクポイントの一覧と削除<a class="headerlink" href="#id27" title="Permalink to this headline">¶</a></h4>
<p>現在有効になっているブレイクポイントを一覧するには
<a class="reference internal" href="#ghci-cmd-:show breaks"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">breaks</span></code></a> を使います．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :show breaks
[0] Main qsort.hs:1:12-13
[1] Main qsort.hs:2:16-47
</pre></div>
</div>
<p>To delete a breakpoint, use the command with the number
ブレイクポイントを削除するには <a class="reference internal" href="#ghci-cmd-:delete"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:delete</span></code></a> コマンドを使い <a class="reference internal" href="#ghci-cmd-:show breaks"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">breaks</span></code></a> で出力されるブレイクポイント番号を指定します．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :delete 0
*Main&gt; :show breaks
[1] Main qsort.hs:2:16-47
</pre></div>
</div>
<p>全てのブレイクポイントを一度に削除するには <code class="docutils literal"><span class="pre">:delete</span> <span class="pre">*</span></code> とします．</p>
</div>
</div>
<div class="section" id="single-stepping">
<span id="id28"></span><h3>5.5.2. ステップ実行<a class="headerlink" href="#single-stepping" title="Permalink to this headline">¶</a></h3>
<p>ステップ実行は，プログラムの実行を可視化する素晴しい方法であり，バグの原因を同定する手段としても有用である．
<a class="reference internal" href="#ghci-cmd-:step"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:step</span></code></a> コマンドを使うと，プログラム中の全てのブレークポイントが有効にされ、次のブレークポイントに達するまで実行される．
<a class="reference internal" href="#ghci-cmd-:steplocal"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:steplocal</span></code></a> とすれば，現在のトップレベル関数の中にあるブレークポイントのみ有効になります．
同様に <a class="reference internal" href="#ghci-cmd-:stepmodule"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:stepmodule</span></code></a> とすると現在のモジュール中にあるブレークポイントのみ有効にします．
たとえば以下のようになる．</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :step main
Stopped in Main.main, qsort.hs:5:8-48
_result :: IO () = _
</pre></div>
</div>
<p><a class="reference internal" href="#ghci-cmd-:step"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:step</span> <span class="pre">expr</span></code></a> コマンドは⟨expr⟩のステップ実行を開始します．
⟨expr⟩ が省略されたときは，現在のブレイクポイントからステップ実行します．
<a class="reference internal" href="#ghci-cmd-:steplocal"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:steplocal</span></code></a> および <a class="reference internal" href="#ghci-cmd-:stepmodule"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:stepmodule</span></code></a> も同様に動作します．</p>
<p>ステップ実行中は <a class="reference internal" href="#ghci-cmd-:list"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:list</span></code></a> コマンドが特に便利で，いまどこを実行しているかが判ります．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:5:8-48] *Main&gt; :list
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:8-48] *Main&gt;
</pre></div>
</div>
<p>実は，GHCiにはブレイクポイントにきたときにコマンドを実行するという機能があり，
自動的に <a class="reference internal" href="#ghci-cmd-:list"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:list</span></code></a> するようにできます．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:5:8-48] *Main&gt; :set stop :list
[qsort.hs:5:8-48] *Main&gt; :step
Stopped in Main.main, qsort.hs:5:15-47
_result :: [Integer] = _
4
5  main = print (qsort [8, 4, 0, 3, 1, 23, 11, 18])
6
[qsort.hs:5:15-47] *Main&gt;
</pre></div>
</div>
</div>
<div class="section" id="nested-breakpoints">
<span id="id29"></span><h3>5.5.3. ブレイクポイントのネスト<a class="headerlink" href="#nested-breakpoints" title="Permalink to this headline">¶</a></h3>
<p>GHCi がブレイクポイントで停止したとき，プロンプトに式を入力すると，次のブレイクポイントまで進みます．
この新しいブレイクポイントが現在のブレイクポイントとなり，古いブレイクポイントはスタックに保存されます．
任意の数のブレイクポイント文脈はこうして作られます．
以下はその例です．</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:2:16-47] *Main&gt; :step qsort [1,3]
Stopped in Main.qsort, qsort.hs:2:16-47
_result :: [t] = _
a :: t = _
left :: [t] = _
right :: [t] = _
... [qsort.hs:2:16-47] *Main&gt;
</pre></div>
</div>
<p>前に設定した2行目のブレークポイントで停止したところで <code class="docutils literal"><span class="pre">:step</span> <span class="pre">qsort</span> <span class="pre">[1,3]</span></code> として新しい評価を開始したしました．
この新しい評価は1ステップの後に(<code class="docutils literal"><span class="pre">qsort</span></code> の定義で)停止しました．
ここで，プロンプトが変わって先頭に <code class="docutils literal"><span class="pre">...</span></code> が付きます．
これが現在のブレークポイントの他に保存されたブレークポイントがあることを示しています．
この文脈スタックを見るには <a class="reference internal" href="#ghci-cmd-:show context"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">context</span></code></a> を使えばいいでしょう．</p>
<div class="highlight-none"><div class="highlight"><pre>... [qsort.hs:2:16-47] *Main&gt; :show context
--&gt; main
Stopped in Main.qsort, qsort.hs:2:16-47
--&gt; qsort [1,3]
Stopped in Main.qsort, qsort.hs:2:16-47
... [qsort.hs:2:16-47] *Main&gt;
</pre></div>
</div>
<p>現在の評価の結果を捨てるには <a class="reference internal" href="#ghci-cmd-:abandon"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:abandon</span></code></a>: を使います．</p>
<div class="highlight-none"><div class="highlight"><pre>... [qsort.hs:2:16-47] *Main&gt; :abandon
[qsort.hs:2:16-47] *Main&gt; :abandon
*Main&gt;
</pre></div>
</div>
</div>
<div class="section" id="the-result-variable">
<span id="ghci-debugger-result"></span><h3>5.5.4. The <code class="docutils literal"><span class="pre">_result</span></code> variable<a class="headerlink" href="#the-result-variable" title="Permalink to this headline">¶</a></h3>
<p>When stopped at a breakpoint or single-step, GHCi binds the variable
<code class="docutils literal"><span class="pre">_result</span></code> to the value of the currently active expression. The value
of <code class="docutils literal"><span class="pre">_result</span></code> is presumably not available yet, because we stopped its
evaluation, but it can be forced: if the type is known and showable,
then just entering <code class="docutils literal"><span class="pre">_result</span></code> at the prompt will show it. However,
there&#8217;s one caveat to doing this: evaluating <code class="docutils literal"><span class="pre">_result</span></code> will be likely
to trigger further breakpoints, starting with the breakpoint we are
currently stopped at (if we stopped at a real breakpoint, rather than
due to <a class="reference internal" href="#ghci-cmd-:step"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:step</span></code></a>). So it will probably be necessary to issue a
<a class="reference internal" href="#ghci-cmd-:continue"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:continue</span></code></a> immediately when evaluating <code class="docutils literal"><span class="pre">_result</span></code>. Alternatively,
you can use <a class="reference internal" href="#ghci-cmd-:force"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:force</span></code></a> which ignores breakpoints.</p>
</div>
<div class="section" id="tracing-and-history">
<span id="tracing"></span><h3>5.5.5. Tracing and history<a class="headerlink" href="#tracing-and-history" title="Permalink to this headline">¶</a></h3>
<p>A question that we often want to ask when debugging a program is “how
did I get here?”. Traditional imperative debuggers usually provide some
kind of stack-tracing feature that lets you see the stack of active
function calls (sometimes called the “lexical call stack”), describing a
path through the code to the current location. Unfortunately this is
hard to provide in Haskell, because execution proceeds on a
demand-driven basis, rather than a depth-first basis as in strict
languages. The “stack“ in GHC&#8217;s execution engine bears little
resemblance to the lexical call stack. Ideally GHCi would maintain a
separate lexical call stack in addition to the dynamic call stack, and
in fact this is exactly what our profiling system does
(<a class="reference internal" href="profiling.html#profiling"><span>Profiling</span></a>), and what some other Haskell debuggers do. For the
time being, however, GHCi doesn&#8217;t maintain a lexical call stack (there
are some technical challenges to be overcome). Instead, we provide a way
to backtrack from a breakpoint to previous evaluation steps: essentially
this is like single-stepping backwards, and should in many cases provide
enough information to answer the &#8220;how did I get here?&#8221; question.</p>
<p>To use tracing, evaluate an expression with the <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> command. For
example, if we set a breakpoint on the base case of <code class="docutils literal"><span class="pre">qsort</span></code>:</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :list qsort
1  qsort [] = []
2  qsort (a:as) = qsort left ++ [a] ++ qsort right
3    where (left,right) = (filter (&lt;=a) as, filter (&gt;a) as)
4
*Main&gt; :b 1
Breakpoint 1 activated at qsort.hs:1:11-12
*Main&gt;
</pre></div>
</div>
<p>and then run a small <code class="docutils literal"><span class="pre">qsort</span></code> with tracing:</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :trace qsort [3,2,1]
Stopped at qsort.hs:1:11-12
_result :: [a]
[qsort.hs:1:11-12] *Main&gt;
</pre></div>
</div>
<p>We can now inspect the history of evaluation steps:</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:1:11-12] *Main&gt; :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:16-47
-6  : qsort.hs:3:24-38
-7  : qsort.hs:3:23-55
-8  : qsort.hs:(1,0)-(3,55)
-9  : qsort.hs:2:15-24
-10 : qsort.hs:2:16-47
-11 : qsort.hs:3:24-38
-12 : qsort.hs:3:23-55
-13 : qsort.hs:(1,0)-(3,55)
-14 : qsort.hs:2:15-24
-15 : qsort.hs:2:16-47
-16 : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
</pre></div>
</div>
<p>To examine one of the steps in the history, use <a class="reference internal" href="#ghci-cmd-:back"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:back</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre>[qsort.hs:1:11-12] *Main&gt; :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *Main&gt;
</pre></div>
</div>
<p>Note that the local variables at each step in the history have been
preserved, and can be examined as usual. Also note that the prompt has
changed to indicate that we&#8217;re currently examining the first step in the
history: <code class="docutils literal"><span class="pre">-1</span></code>. The command <a class="reference internal" href="#ghci-cmd-:forward"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:forward</span></code></a> can be used to traverse
forward in the history.</p>
<p>The <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> command can be used with or without an expression. When
used without an expression, tracing begins from the current breakpoint,
just like <a class="reference internal" href="#ghci-cmd-:step"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:step</span></code></a>.</p>
<p>The history is only available when using <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a>; the reason for this
is we found that logging each breakpoint in the history cuts performance
by a factor of 2 or more.</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fghci-hist-size">
<code class="descname">-fghci-hist-size</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fghci-hist-size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">50</td>
</tr>
</tbody>
</table>
<p>Modify the depth of the evaluation history tracked by GHCi.</p>
</dd></dl>

</div>
<div class="section" id="debugging-exceptions">
<span id="ghci-debugger-exceptions"></span><h3>5.5.6. Debugging exceptions<a class="headerlink" href="#debugging-exceptions" title="Permalink to this headline">¶</a></h3>
<p>Another common question that comes up when debugging is &#8220;where did this
exception come from?&#8221;. Exceptions such as those raised by <code class="docutils literal"><span class="pre">error</span></code> or
<code class="docutils literal"><span class="pre">head</span> <span class="pre">[]</span></code> have no context information attached to them. Finding which
particular call to <code class="docutils literal"><span class="pre">head</span></code> in your program resulted in the error can be
a painstaking process, usually involving <code class="docutils literal"><span class="pre">Debug.Trace.trace</span></code>, or
compiling with profiling and using <code class="docutils literal"><span class="pre">Debug.Trace.traceStack</span></code> or
<code class="docutils literal"><span class="pre">+RTS</span> <span class="pre">-xc</span></code> (see <a class="reference internal" href="runtime_control.html#rts-flag--xc"><code class="xref std std-rts-flag docutils literal"><span class="pre">-xc</span></code></a>).</p>
<p>The GHCi debugger offers a way to hopefully shed some light on these
errors quickly and without modifying or recompiling the source code. One
way would be to set a breakpoint on the location in the source code that
throws the exception, and then use <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a> and <a class="reference internal" href="#ghci-cmd-:history"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:history</span></code></a> to
establish the context. However, <code class="docutils literal"><span class="pre">head</span></code> is in a library and we can&#8217;t
set a breakpoint on it directly. For this reason, GHCi provides the
flags <a class="reference internal" href="#ghc-flag--fbreak-on-exception"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbreak-on-exception</span></code></a> which causes the evaluator to stop when
an exception is thrown, and <a class="reference internal" href="#ghc-flag--fbreak-on-error"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbreak-on-error</span></code></a>, which works similarly
but stops only on uncaught exceptions. When stopping at an exception,
GHCi will act just as it does when a breakpoint is hit, with the
deviation that it will not show you any source code location. Due to
this, these commands are only really useful in conjunction with
<a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a>, in order to log the steps leading up to the exception. For
example:</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :set -fbreak-on-exception
*Main&gt; :trace qsort (&quot;abc&quot; ++ undefined)
“Stopped at &lt;exception thrown&gt;
_exception :: e
[&lt;exception thrown&gt;] *Main&gt; :hist
-1  : qsort.hs:3:24-38
-2  : qsort.hs:3:23-55
-3  : qsort.hs:(1,0)-(3,55)
-4  : qsort.hs:2:15-24
-5  : qsort.hs:2:16-47
-6  : qsort.hs:(1,0)-(3,55)
&lt;end of history&gt;
[&lt;exception thrown&gt;] *Main&gt; :back
Logged breakpoint at qsort.hs:3:24-38
_result :: [a]
as :: [a]
a :: a
[-1: qsort.hs:3:24-38] *Main&gt; :force as
*** Exception: Prelude.undefined
[-1: qsort.hs:3:24-38] *Main&gt; :print as
as = &#39;b&#39; : &#39;c&#39; : (_t1::[Char])
</pre></div>
</div>
<p>The exception itself is bound to a new variable, <code class="docutils literal"><span class="pre">_exception</span></code>.</p>
<p>Breaking on exceptions is particularly useful for finding out what your
program was doing when it was in an infinite loop. Just hit Control-C,
and examine the history to find out what was going on.</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fbreak-on-exception">
<code class="descname">-fbreak-on-exception</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fbreak-on-exception" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--fbreak-on-error">
<code class="descname">-fbreak-on-error</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fbreak-on-error" title="Permalink to this definition">¶</a></dt>
<dd><p>Causes GHCi to halt evaluation and return to the interactive prompt
in the event of an exception. While <a class="reference internal" href="#ghc-flag--fbreak-on-exception"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbreak-on-exception</span></code></a> breaks
on all exceptions, <a class="reference internal" href="#ghc-flag--fbreak-on-error"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbreak-on-error</span></code></a> breaks on only those which
would otherwise be uncaught.</p>
</dd></dl>

</div>
<div class="section" id="example-inspecting-functions">
<h3>5.5.7. Example: inspecting functions<a class="headerlink" href="#example-inspecting-functions" title="Permalink to this headline">¶</a></h3>
<p>It is possible to use the debugger to examine function values. When we
are at a breakpoint and a function is in scope, the debugger cannot show
you the source code for it; however, it is possible to get some
information by applying it to some arguments and observing the result.</p>
<p>The process is slightly complicated when the binding is polymorphic. We
show the process by means of an example. To keep things simple, we will
use the well known <code class="docutils literal"><span class="pre">map</span></code> function:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">map</span><span class="p">)</span>

<span class="nf">map</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span><span class="ow">-&gt;</span><span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="nf">map</span> <span class="n">f</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="kt">[]</span>
<span class="nf">map</span> <span class="n">f</span> <span class="p">(</span><span class="n">x</span><span class="kt">:</span><span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">f</span> <span class="n">x</span> <span class="kt">:</span> <span class="n">map</span> <span class="n">f</span> <span class="n">xs</span>
</pre></div>
</div>
<p>We set a breakpoint on <code class="docutils literal"><span class="pre">map</span></code>, and call it.</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :break 5
Breakpoint 0 activated at  map.hs:5:15-28
*Main&gt; map Just [1..5]
Stopped at map.hs:(4,0)-(5,12)
_result :: [b]
x :: a
f :: a -&gt; b
xs :: [a]
</pre></div>
</div>
<p>GHCi tells us that, among other bindings, <code class="docutils literal"><span class="pre">f</span></code> is in scope. However,
its type is not fully known yet, and thus it is not possible to apply it
to any arguments. Nevertheless, observe that the type of its first
argument is the same as the type of <code class="docutils literal"><span class="pre">x</span></code>, and its result type is shared
with <code class="docutils literal"><span class="pre">_result</span></code>.</p>
<p>As we demonstrated earlier (<a class="reference internal" href="#breakpoints"><span>ブレイクポイントと変数内容の表示</span></a>), the debugger has some
intelligence built-in to update the type of <code class="docutils literal"><span class="pre">f</span></code> whenever the types of
<code class="docutils literal"><span class="pre">x</span></code> or <code class="docutils literal"><span class="pre">_result</span></code> are discovered. So what we do in this scenario is
force <code class="docutils literal"><span class="pre">x</span></code> a bit, in order to recover both its type and the argument
part of <code class="docutils literal"><span class="pre">f</span></code>.</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; seq x ()
*Main&gt; :print x
x = 1
</pre></div>
</div>
<p>We can check now that as expected, the type of <code class="docutils literal"><span class="pre">x</span></code> has been
reconstructed, and with it the type of <code class="docutils literal"><span class="pre">f</span></code> has been too:</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :t x
x :: Integer
*Main&gt; :t f
f :: Integer -&gt; b
</pre></div>
</div>
<p>From here, we can apply f to any argument of type Integer and observe
the results.</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; let b = f 10
*Main&gt; :t b
b :: b
*Main&gt; b
&lt;interactive&gt;:1:0:
    Ambiguous type variable `b&#39; in the constraint:
      `Show b&#39; arising from a use of `print&#39; at &lt;interactive&gt;:1:0
*Main&gt; :p b
b = (_t2::a)
*Main&gt; seq b ()
()
*Main&gt; :t b
b :: a
*Main&gt; :p b
b = Just 10
*Main&gt; :t b
b :: Maybe Integer
*Main&gt; :t f
f :: Integer -&gt; Maybe Integer
*Main&gt; f 20
Just 20
*Main&gt; map f [1..5]
[Just 1, Just 2, Just 3, Just 4, Just 5]
</pre></div>
</div>
<p>In the first application of <code class="docutils literal"><span class="pre">f</span></code>, we had to do some more type
reconstruction in order to recover the result type of <code class="docutils literal"><span class="pre">f</span></code>. But after
that, we are free to use <code class="docutils literal"><span class="pre">f</span></code> normally.</p>
</div>
<div class="section" id="limitations">
<h3>5.5.8. Limitations<a class="headerlink" href="#limitations" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">When stopped at a breakpoint, if you try to evaluate a variable that
is already under evaluation, the second evaluation will hang. The
reason is that GHC knows the variable is under evaluation, so the new
evaluation just waits for the result before continuing, but of course
this isn&#8217;t going to happen because the first evaluation is stopped at
a breakpoint. Control-C can interrupt the hung evaluation and return
to the prompt.</p>
<p>The most common way this can happen is when you&#8217;re evaluating a CAF
(e.g. main), stop at a breakpoint, and ask for the value of the CAF
at the prompt again.</p>
</li>
<li><p class="first">Implicit parameters (see <a class="reference internal" href="glasgow_exts.html#implicit-parameters"><span>Implicit parameters</span></a>) are only
available at the scope of a breakpoint if there is an explicit type
signature.</p>
</li>
</ul>
</div>
</div>
<div class="section" id="invoking-ghci">
<span id="ghci-invocation"></span><h2>5.6. Invoking GHCi<a class="headerlink" href="#invoking-ghci" title="Permalink to this headline">¶</a></h2>
<p id="index-14">GHCi is invoked with the command <code class="docutils literal"><span class="pre">ghci</span></code> or <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--interactive</span></code>. One
or more modules or filenames can also be specified on the command line;
this instructs GHCi to load the specified modules or filenames (and all
the modules they depend on), just as if you had said <code class="docutils literal"><span class="pre">:load</span> <span class="pre">modules</span></code>
at the GHCi prompt (see <a class="reference internal" href="#ghci-commands"><span>GHCi commands</span></a>). For example, to start
GHCi and load the program whose topmost module is in the file
<code class="docutils literal"><span class="pre">Main.hs</span></code>, we could say:</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghci Main.hs
</pre></div>
</div>
<p>Most of the command-line options accepted by GHC (see <a class="reference internal" href="using.html#using-ghc"><span>Using GHC</span></a>)
also make sense in interactive mode. The ones that don&#8217;t make sense are
mostly obvious.</p>
<div class="section" id="packages">
<h3>5.6.1. Packages<a class="headerlink" href="#packages" title="Permalink to this headline">¶</a></h3>
<p id="index-15">Most packages (see <a class="reference internal" href="packages.html#using-packages"><span>Using Packages</span></a>) are available without needing
to specify any extra flags at all: they will be automatically loaded the
first time they are needed.</p>
<p>For hidden packages, however, you need to request the package be loaded
by using the <a class="reference internal" href="phases.html#ghc-flag--package"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-package</span></code></a> flag:</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghci -package readline
GHCi, version 6.8.1: http://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Loading package readline-1.0 ... linking ... done.
Prelude&gt;
</pre></div>
</div>
<p>The following command works to load new packages into a running GHCi:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :set -package name
</pre></div>
</div>
<p>But note that doing this will cause all currently loaded modules to be
unloaded, and you&#8217;ll be dumped back into the <code class="docutils literal"><span class="pre">Prelude</span></code>.</p>
</div>
<div class="section" id="extra-libraries">
<h3>5.6.2. Extra libraries<a class="headerlink" href="#extra-libraries" title="Permalink to this headline">¶</a></h3>
<p id="index-16">Extra libraries may be specified on the command line using the normal
<code class="docutils literal"><span class="pre">-llib</span></code> option. (The term <em>library</em> here refers to libraries of
foreign object code; for using libraries of Haskell source code, see
<a class="reference internal" href="#ghci-modules-filenames"><span>モジュールとファイル名</span></a>.) For example, to load the “m” library:</p>
<div class="highlight-none"><div class="highlight"><pre>$ ghci -lm
</pre></div>
</div>
<p>On systems with <code class="docutils literal"><span class="pre">.so</span></code>-style shared libraries, the actual library
loaded will the <code class="docutils literal"><span class="pre">liblib.so</span></code>. GHCi searches the following places for
libraries, in this order:</p>
<ul class="simple">
<li>Paths specified using the <a class="reference internal" href="phases.html#ghc-flag--L"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-L</span></code></a> command-line option,</li>
<li>the standard library search path for your system, which on some
systems may be overridden by setting the <span class="target" id="index-17"></span><code class="xref std std-envvar docutils literal"><span class="pre">LD_LIBRARY_PATH</span></code>
environment variable.</li>
</ul>
<p>On systems with <code class="docutils literal"><span class="pre">.dll</span></code>-style shared libraries, the actual library
loaded will be <code class="docutils literal"><span class="pre">lib.dll</span></code>. Again, GHCi will signal an error if it can&#8217;t
find the library.</p>
<p>GHCi can also load plain object files (<code class="docutils literal"><span class="pre">.o</span></code> or <code class="docutils literal"><span class="pre">.obj</span></code> depending on
your platform) from the command-line. Just add the name the object file
to the command line.</p>
<p>Ordering of <code class="docutils literal"><span class="pre">-l</span></code> options matters: a library should be mentioned
<em>before</em> the libraries it depends on (see <a class="reference internal" href="phases.html#options-linker"><span>Options affecting linking</span></a>).</p>
</div>
</div>
<div class="section" id="ghci-commands">
<span id="id30"></span><h2>5.7. GHCi commands<a class="headerlink" href="#ghci-commands" title="Permalink to this headline">¶</a></h2>
<p>GHCi commands all begin with &#8220;<code class="docutils literal"><span class="pre">:</span></code>&#8221; and consist of a single command
name followed by zero or more parameters. The command name may be
abbreviated, with ambiguities being resolved in favour of the more
commonly used commands.</p>
<dl class="ghci-cmd">
<dt id="ghci-cmd-:abandon">
<code class="descname">:abandon</code><a class="headerlink" href="#ghci-cmd-:abandon" title="Permalink to this definition">¶</a></dt>
<dd><p>Abandons the current evaluation (only available when stopped at a
breakpoint).</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:add">
<code class="descname">:add[*] ⟨module⟩</code><a class="headerlink" href="#ghci-cmd-:add" title="Permalink to this definition">¶</a></dt>
<dd><p>Add ⟨module⟩(s) to the current target set, and perform a reload.
Normally pre-compiled code for the module will be loaded if
available, or otherwise the module will be compiled to byte-code.
Using the <code class="docutils literal"><span class="pre">*</span></code> prefix forces the module to be loaded as byte-code.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:all-types">
<code class="descname">:all-types</code><a class="headerlink" href="#ghci-cmd-:all-types" title="Permalink to this definition">¶</a></dt>
<dd><p>List all types collected for expressions and (local) bindings
currently loaded (while <a class="reference internal" href="#ghci-cmd-:set +c"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+c</span></code></a> was active) with their respective
source-code span, e.g.</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">GhciTypes</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">all</span><span class="o">-</span><span class="n">types</span>
<span class="kt">GhciTypes</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">38</span><span class="p">,</span><span class="mi">13</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">38</span><span class="p">,</span><span class="mi">24</span><span class="p">)</span><span class="kt">:</span> <span class="kt">Maybe</span> <span class="kt">Id</span>
<span class="kt">GhciTypes</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">29</span><span class="p">)</span><span class="kt">:</span> <span class="kt">Outputable</span> <span class="kt">SpanInfo</span>
<span class="kt">GhciTypes</span><span class="o">.</span><span class="n">hs</span><span class="kt">:</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">10</span><span class="p">)</span><span class="o">-</span><span class="p">(</span><span class="mi">45</span><span class="p">,</span><span class="mi">29</span><span class="p">)</span><span class="kt">:</span> <span class="p">(</span><span class="kt">Rational</span> <span class="ow">-&gt;</span> <span class="kt">SpanInfo</span> <span class="ow">-&gt;</span> <span class="kt">SDoc</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Outputable</span> <span class="kt">SpanInfo</span>
</pre></div>
</div>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:back">
<code class="descname">:back ⟨n⟩</code><a class="headerlink" href="#ghci-cmd-:back" title="Permalink to this definition">¶</a></dt>
<dd><p>Travel back ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See
<a class="reference internal" href="#tracing"><span>Tracing and history</span></a> for more about GHCi&#8217;s debugging facilities. See also:
<a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a>, <a class="reference internal" href="#ghci-cmd-:history"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:history</span></code></a>, <a class="reference internal" href="#ghci-cmd-:forward"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:forward</span></code></a>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:break">
<code class="descname">:break [⟨identifier⟩ | [⟨module⟩] ⟨line⟩ [⟨column⟩]]</code><a class="headerlink" href="#ghci-cmd-:break" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a breakpoint on the specified function or line and column. See
<a class="reference internal" href="#setting-breakpoints"><span>ブレイクポイントの設定</span></a>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:browse">
<code class="descname">:browse[!] [[*] ⟨module⟩]</code><a class="headerlink" href="#ghci-cmd-:browse" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays the identifiers exported by the module ⟨module⟩, which must
be either loaded into GHCi or be a member of a package. If ⟨module⟩
is omitted, the most recently-loaded module is used.</p>
<p>Like all other GHCi commands, the output is always displayed in the
current GHCi scope (<a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a>).</p>
<p>There are two variants of the browse command:</p>
<ul>
<li><p class="first">If the <code class="docutils literal"><span class="pre">*</span></code> symbol is placed before the module name, then <em>all</em>
the identifiers in scope in ⟨module⟩ (rather that just its
exports) are shown.</p>
<p>The <code class="docutils literal"><span class="pre">*</span></code>-form is only available for modules which are
interpreted; for compiled modules (including modules from
packages) only the non-<code class="docutils literal"><span class="pre">*</span></code> form of <a class="reference internal" href="#ghci-cmd-:browse"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:browse</span></code></a> is available.</p>
</li>
<li><p class="first">Data constructors and class methods are usually displayed in the
context of their data type or class declaration. However, if the
<code class="docutils literal"><span class="pre">!</span></code> symbol is appended to the command, thus <code class="docutils literal"><span class="pre">:browse!</span></code>, they
are listed individually. The <code class="docutils literal"><span class="pre">!</span></code>-form also annotates the
listing with comments giving possible imports for each group of
entries. Here is an example:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kt">Prelude</span><span class="o">&gt;</span> <span class="kt">:</span><span class="n">browse</span><span class="o">!</span> <span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span>
<span class="c1">-- not currently imported</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">catMaybes</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Maybe</span> <span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">fromJust</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">fromMaybe</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">isJust</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">isNothing</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">listToMaybe</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">mapMaybe</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="kt">Data</span><span class="o">.</span><span class="kt">Maybe</span><span class="o">.</span><span class="n">maybeToList</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="c1">-- imported via Prelude</span>
<span class="kt">Just</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="kr">data</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">Nothing</span> <span class="o">|</span> <span class="kt">Just</span> <span class="n">a</span>
<span class="kt">Nothing</span> <span class="ow">::</span> <span class="kt">Maybe</span> <span class="n">a</span>
<span class="nf">maybe</span> <span class="ow">::</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="kt">Maybe</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span>
</pre></div>
</div>
<p>This output shows that, in the context of the current session (ie
in the scope of <code class="docutils literal"><span class="pre">Prelude</span></code>), the first group of items from
<code class="docutils literal"><span class="pre">Data.Maybe</span></code> are not in scope (althought they are available in
fully qualified form in the GHCi session - see
<a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a>), whereas the second group of items are in
scope (via <code class="docutils literal"><span class="pre">Prelude</span></code>) and are therefore available either
unqualified, or with a <code class="docutils literal"><span class="pre">Prelude.</span></code> qualifier.</p>
</li>
</ul>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:cd">
<code class="descname">:cd ⟨dir⟩</code><a class="headerlink" href="#ghci-cmd-:cd" title="Permalink to this definition">¶</a></dt>
<dd><p>Changes the current working directory to ⟨dir⟩. A &#8220;<code class="docutils literal"><span class="pre">~</span></code>&#8221; symbol
at the beginning of ⟨dir⟩ will be replaced by the contents of the
environment variable <span class="target" id="index-18"></span><code class="xref std std-envvar docutils literal"><span class="pre">HOME</span></code>. See also the <a class="reference internal" href="#ghci-cmd-:show paths"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">paths</span></code></a>
command for showing the current working directory.</p>
<p>Note: changing directories causes all currently loaded modules to be
unloaded. This is because the search path is usually expressed using
relative directories, and changing the search path in the middle of
a session is not supported.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:cmd">
<code class="descname">:cmd ⟨expr⟩</code><a class="headerlink" href="#ghci-cmd-:cmd" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes ⟨expr⟩ as a computation of type <code class="docutils literal"><span class="pre">IO</span> <span class="pre">String</span></code>, and then
executes the resulting string as a list of GHCi commands. Multiple
commands are separated by newlines. The <a class="reference internal" href="#ghci-cmd-:cmd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cmd</span></code></a> command is useful
with <a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> and <a class="reference internal" href="#ghci-cmd-:set stop"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">stop</span></code></a>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:complete">
<code class="descname">:complete ⟨type⟩ [⟨n⟩-][⟨m⟩] ⟨string-literal⟩</code><a class="headerlink" href="#ghci-cmd-:complete" title="Permalink to this definition">¶</a></dt>
<dd><p>This command allows to request command completions from GHCi even
when interacting over a pipe instead of a proper terminal and is
designed for integrating GHCi&#8217;s completion with text editors and
IDEs.</p>
<p>When called, <a class="reference internal" href="#ghci-cmd-:complete"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:complete</span></code></a> prints the ⟨n⟩<sup>th</sup> to
⟨m⟩<sup>th</sup> completion candidates for the partial input
⟨string-literal⟩ for the completion domain denoted by ⟨type⟩.
Currently, only the <code class="docutils literal"><span class="pre">repl</span></code> domain is supported which denotes the
kind of completion that would be provided interactively by GHCi at
the input prompt.</p>
<p>If omitted, ⟨n⟩ and ⟨m⟩ default to the first or last available
completion candidate respectively. If there are less candidates than
requested via the range argument, ⟨n⟩ and ⟨m⟩ are implicitly capped
to the number of available completition candidates.</p>
<p>The output of <a class="reference internal" href="#ghci-cmd-:complete"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:complete</span></code></a> begins with a header line containing
three space-delimited fields:</p>
<ul class="simple">
<li>An integer denoting the number <code class="docutils literal"><span class="pre">l</span></code> of printed completions,</li>
<li>an integer denoting the total number of completions available,
and finally</li>
<li>a string literal denoting a common prefix to be added to the
returned completion candidates.</li>
</ul>
<p>The header line is followed by ⟨l⟩ lines each containing one
completion candidate encoded as (quoted) string literal. Here are
some example invocations showing the various cases:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :complete repl 0 &quot;&quot;
0 470 &quot;&quot;
Prelude&gt; :complete repl 5 &quot;import For&quot;
5 21 &quot;import &quot;
&quot;Foreign&quot;
&quot;Foreign.C&quot;
&quot;Foreign.C.Error&quot;
&quot;Foreign.C.String&quot;
&quot;Foreign.C.Types&quot;
Prelude&gt; :complete repl 5-10 &quot;import For&quot;
6 21 &quot;import &quot;
&quot;Foreign.C.Types&quot;
&quot;Foreign.Concurrent&quot;
&quot;Foreign.ForeignPtr&quot;
&quot;Foreign.ForeignPtr.Safe&quot;
&quot;Foreign.ForeignPtr.Unsafe&quot;
&quot;Foreign.Marshal&quot;
Prelude&gt; :complete repl 20- &quot;import For&quot;
2 21 &quot;import &quot;
&quot;Foreign.StablePtr&quot;
&quot;Foreign.Storable&quot;
Prelude&gt; :complete repl &quot;map&quot;
3 3 &quot;&quot;
&quot;map&quot;
&quot;mapM&quot;
&quot;mapM_&quot;
Prelude&gt; :complete repl 5-10 &quot;map&quot;
0 3 &quot;&quot;
</pre></div>
</div>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:continue">
<code class="descname">:continue</code><a class="headerlink" href="#ghci-cmd-:continue" title="Permalink to this definition">¶</a></dt>
<dd><p>Continue the current evaluation, when stopped at a breakpoint.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:ctags">
<code class="descname">:ctags [⟨filename⟩]</code><a class="headerlink" href="#ghci-cmd-:ctags" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a &#8220;tags&#8221; file for Vi-style editors (<a class="reference internal" href="#ghci-cmd-:ctags"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:ctags</span></code></a>) or
Emacs-style editors (<a class="reference internal" href="#ghci-cmd-:etags"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:etags</span></code></a>). If no filename is specified, the
default <code class="docutils literal"><span class="pre">tags</span></code> or <code class="docutils literal"><span class="pre">TAGS</span></code> is used, respectively. Tags for all the
functions, constructors and types in the currently loaded modules
are created. All modules must be interpreted for these commands to
work.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:def">
<code class="descname">:def[!] ⟨name⟩ ⟨expr⟩</code><a class="headerlink" href="#ghci-cmd-:def" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> is used to define new commands, or macros, in GHCi. The
command <code class="docutils literal"><span class="pre">:def</span> <span class="pre">⟨name⟩</span> <span class="pre">⟨expr⟩</span></code> defines a new GHCi command <code class="docutils literal"><span class="pre">:name</span></code>,
implemented by the Haskell expression ⟨expr⟩, which must have type
<code class="docutils literal"><span class="pre">String</span> <span class="pre">-&gt;</span> <span class="pre">IO</span> <span class="pre">String</span></code>. When <code class="docutils literal"><span class="pre">:name</span> <span class="pre">args</span></code> is typed at the prompt,
GHCi will run the expression <code class="docutils literal"><span class="pre">(name</span> <span class="pre">args)</span></code>, take the resulting
<code class="docutils literal"><span class="pre">String</span></code>, and feed it back into GHCi as a new sequence of
commands. Separate commands in the result must be separated by
&#8220;<code class="docutils literal"><span class="pre">\n</span></code>&#8221;.</p>
<p>That&#8217;s all a little confusing, so here&#8217;s a few examples. To start
with, here&#8217;s a new GHCi command which doesn&#8217;t take any arguments or
produce any results, it just outputs the current date and time:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; let date _ = Time.getClockTime &gt;&gt;= print &gt;&gt; return &quot;&quot;
Prelude&gt; :def date date
Prelude&gt; :date
Fri Mar 23 15:16:40 GMT 2001
</pre></div>
</div>
<p>Here&#8217;s an example of a command that takes an argument. It&#8217;s a
re-implementation of <a class="reference internal" href="#ghci-cmd-:cd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cd</span></code></a>:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; let mycd d = Directory.setCurrentDirectory d &gt;&gt; return &quot;&quot;
Prelude&gt; :def mycd mycd
Prelude&gt; :mycd ..
</pre></div>
</div>
<p>Or I could define a simple way to invoke &#8220;<code class="docutils literal"><span class="pre">ghc</span> <span class="pre">--make</span> <span class="pre">Main</span></code>&#8221;
in the current directory:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :def make (\_ -&gt; return &quot;:! ghc --make Main&quot;)
</pre></div>
</div>
<p>We can define a command that reads GHCi input from a file. This
might be useful for creating a set of bindings that we want to
repeatedly load into the GHCi session:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :def . readFile
Prelude&gt; :. cmds.ghci
</pre></div>
</div>
<p>Notice that we named the command <code class="docutils literal"><span class="pre">:.</span></code>, by analogy with the
&#8220;<code class="docutils literal"><span class="pre">.</span></code>&#8221; Unix shell command that does the same thing.</p>
<p>Typing <code class="docutils literal"><span class="pre">:def</span></code> on its own lists the currently-defined macros.
Attempting to redefine an existing command name results in an error
unless the <code class="docutils literal"><span class="pre">:def!</span></code> form is used, in which case the old command
with that name is silently overwritten.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:delete">
<code class="descname">:delete * | ⟨num⟩ ...</code><a class="headerlink" href="#ghci-cmd-:delete" title="Permalink to this definition">¶</a></dt>
<dd><p>Delete one or more breakpoints by number (use <a class="reference internal" href="#ghci-cmd-:show breaks"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:show</span> <span class="pre">breaks</span></code></a> to
see the number of each breakpoint). The <code class="docutils literal"><span class="pre">*</span></code> form deletes all the
breakpoints.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:edit">
<code class="descname">:edit ⟨file⟩</code><a class="headerlink" href="#ghci-cmd-:edit" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens an editor to edit the file ⟨file⟩, or the most recently loaded
module if ⟨file⟩ is omitted. If there were errors during the last
loading, the cursor will be positioned at the line of the first
error. The editor to invoke is taken from the <span class="target" id="index-19"></span><code class="xref std std-envvar docutils literal"><span class="pre">EDITOR</span></code> environment
variable, or a default editor on your system if <span class="target" id="index-20"></span><code class="xref std std-envvar docutils literal"><span class="pre">EDITOR</span></code> is not
set. You can change the editor using <a class="reference internal" href="#ghci-cmd-:set editor"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">editor</span></code></a>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:etags">
<code class="descname">:etags</code><a class="headerlink" href="#ghci-cmd-:etags" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#ghci-cmd-:ctags"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:ctags</span></code></a>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:force">
<code class="descname">:force ⟨identifier⟩ ...</code><a class="headerlink" href="#ghci-cmd-:force" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints the value of ⟨identifier⟩ in the same way as <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a>.
Unlike <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a>, <a class="reference internal" href="#ghci-cmd-:force"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:force</span></code></a> evaluates each thunk that it
encounters while traversing the value. This may cause exceptions or
infinite loops, or further breakpoints (which are ignored, but
displayed).</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:forward">
<code class="descname">:forward ⟨n⟩</code><a class="headerlink" href="#ghci-cmd-:forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Move forward ⟨n⟩ steps in the history. ⟨n⟩ is one if omitted. See
<a class="reference internal" href="#tracing"><span>Tracing and history</span></a> for more about GHCi&#8217;s debugging facilities. See also:
<a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a>, <a class="reference internal" href="#ghci-cmd-:history"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:history</span></code></a>, <a class="reference internal" href="#ghci-cmd-:back"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:back</span></code></a>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:help">
<code class="descname">:help</code><a class="headerlink" href="#ghci-cmd-:help" title="Permalink to this definition">¶</a></dt>
<dt id="ghci-cmd-:?">
<code class="descname">:?</code><a class="headerlink" href="#ghci-cmd-:?" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays a list of the available commands.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:">
<code class="descname">:</code><a class="headerlink" href="#ghci-cmd-:" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-21">Repeat the previous command.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:history">
<code class="descname">:history [num]</code><a class="headerlink" href="#ghci-cmd-:history" title="Permalink to this definition">¶</a></dt>
<dd><p>Display the history of evaluation steps. With a number, displays
that many steps (default: 20). For use with <a class="reference internal" href="#ghci-cmd-:trace"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:trace</span></code></a>; see
<a class="reference internal" href="#tracing"><span>Tracing and history</span></a>. To set the number of history entries stored by GHCi,
use the <a class="reference internal" href="#ghc-flag--fghci-hist-size"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fghci-hist-size</span></code></a> flag.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:info">
<code class="descname">:info[!] ⟨name⟩</code><a class="headerlink" href="#ghci-cmd-:info" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays information about the given name(s). For example, if ⟨name⟩
is a class, then the class methods and their types will be printed;
if ⟨name⟩ is a type constructor, then its definition will be
printed; if ⟨name⟩ is a function, then its type will be printed. If
⟨name⟩ has been loaded from a source file, then GHCi will also
display the location of its definition in the source.</p>
<p>For types and classes, GHCi also summarises instances that mention
them. To avoid showing irrelevant information, an instance is shown
only if (a) its head mentions ⟨name⟩, and (b) all the other things
mentioned in the instance are in scope (either qualified or
otherwise) as a result of a <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> or <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a>
commands.</p>
<p>The command <code class="docutils literal"><span class="pre">:info!</span></code> works in a similar fashion but it removes
restriction (b), showing all instances that are in scope and mention
⟨name⟩ in their head.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:issafe">
<code class="descname">:issafe [⟨module⟩]</code><a class="headerlink" href="#ghci-cmd-:issafe" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays Safe Haskell information about the given module (or the
current module if omitted). This includes the trust type of the
module and its containing package.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:kind">
<code class="descname">:kind[!] ⟨type⟩</code><a class="headerlink" href="#ghci-cmd-:kind" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers and prints the kind of ⟨type⟩. The latter can be an arbitrary
type expression, including a partial application of a type
constructor, such as <code class="docutils literal"><span class="pre">Either</span> <span class="pre">Int</span></code>. In fact, <a class="reference internal" href="#ghci-cmd-:kind"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:kind</span></code></a> even allows
you to write a partial application of a type synonym (usually
disallowed), so that this works:</p>
<div class="highlight-none"><div class="highlight"><pre>ghci&gt; type T a b = (a,b,a)
ghci&gt; :k T Int Bool
T Int Bool :: *
ghci&gt; :k T
T :: * -&gt; * -&gt; *
ghci&gt; :k T Int
T Int :: * -&gt; *
</pre></div>
</div>
<p>If you specify the optional &#8220;<code class="docutils literal"><span class="pre">!</span></code>&#8221;, GHC will in addition normalise
the type by expanding out type synonyms and evaluating type-function
applications, and display the normalised result.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:list">
<code class="descname">:list ⟨identifier⟩</code><a class="headerlink" href="#ghci-cmd-:list" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists the source code around the definition of ⟨identifier⟩ or the
current breakpoint if not given. This requires that the identifier
be defined in an interpreted module. If your output device supports
it, then GHCi will highlight the active subexpression in bold.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:list [⟨module⟩]">
<code class="descname">:list [⟨module⟩] ⟨line⟩</code><a class="headerlink" href="#ghci-cmd-:list [⟨module⟩]" title="Permalink to this definition">¶</a></dt>
<dd><p>Lists the source code around the given line number of ⟨module⟩. This
requires that the module be interpreted. If your output device
supports it, then GHCi will highlight the active subexpression in
bold.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:load">
<code class="descname">:load[!] [*]⟨module⟩</code><a class="headerlink" href="#ghci-cmd-:load" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursively loads the specified ⟨module⟩s, and all the modules they
depend on. Here, each ⟨module⟩ must be a module name or filename,
but may not be the name of a module in a package.</p>
<p>All previously loaded modules, except package modules, are
forgotten. The new set of modules is known as the target set. Note
that <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> can be used without any arguments to unload all the
currently loaded modules and bindings.</p>
<p>Normally pre-compiled code for a module will be loaded if available,
or otherwise the module will be compiled to byte-code. Using the
<code class="docutils literal"><span class="pre">*</span></code> prefix forces a module to be loaded as byte-code.</p>
<p>Adding the optional &#8220;<code class="docutils literal"><span class="pre">!</span></code>&#8221; turns type errors into warnings while
loading. This allows to use the portions of the module that are
correct, even if there are type errors in some definitions.
Effectively, the &#8220;-fdefer-type-errors&#8221; flag is set before loading
and unset after loading if the flag has not already been set before.
See <a class="reference internal" href="glasgow_exts.html#defer-type-errors"><span>Deferring type errors to runtime</span></a> for further motivation and details.</p>
<p>After a <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> command, the current context is set to:</p>
<ul class="simple">
<li>⟨module⟩, if it was loaded successfully, or</li>
<li>the most recently successfully loaded module, if any other
modules were loaded as a result of the current <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a>, or</li>
<li><code class="docutils literal"><span class="pre">Prelude</span></code> otherwise.</li>
</ul>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:loc-at">
<code class="descname">:loc-at ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code><a class="headerlink" href="#ghci-cmd-:loc-at" title="Permalink to this definition">¶</a></dt>
<dd><p>Tries to find the definition site of the name at the given
source-code span, e.g.:</p>
<div class="highlight-none"><div class="highlight"><pre>X&gt; :loc-at X.hs 6 14 6 16 mu
X.hs:(8,7)-(8,9)
</pre></div>
</div>
<p>This command is useful when integrating GHCi with text editors and
IDEs for providing a goto-definition facility.</p>
<p>The <code class="docutils literal"><span class="pre">:loc-at</span></code> command requires <a class="reference internal" href="#ghci-cmd-:set +c"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+c</span></code></a> to be set.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:main">
<code class="descname">:main ⟨arg1⟩ ... ⟨argn⟩</code><a class="headerlink" href="#ghci-cmd-:main" title="Permalink to this definition">¶</a></dt>
<dd><p>When a program is compiled and executed, it can use the <code class="docutils literal"><span class="pre">getArgs</span></code>
function to access the command-line arguments. However, we cannot
simply pass the arguments to the <code class="docutils literal"><span class="pre">main</span></code> function while we are
testing in ghci, as the <code class="docutils literal"><span class="pre">main</span></code> function doesn&#8217;t take its arguments
directly.</p>
<p>Instead, we can use the <a class="reference internal" href="#ghci-cmd-:main"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:main</span></code></a> command. This runs whatever
<code class="docutils literal"><span class="pre">main</span></code> is in scope, with any arguments being treated the same as
command-line arguments, e.g.:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; main = System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :main foo bar
[&quot;foo&quot;,&quot;bar&quot;]
</pre></div>
</div>
<p>We can also quote arguments which contains characters like spaces,
and they are treated like Haskell strings, or we can just use
Haskell list syntax:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :main foo &quot;bar baz&quot;
[&quot;foo&quot;,&quot;bar baz&quot;]
Prelude&gt; :main [&quot;foo&quot;, &quot;bar baz&quot;]
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
<p>Finally, other functions can be called, either with the <code class="docutils literal"><span class="pre">-main-is</span></code>
flag or the <a class="reference internal" href="#ghci-cmd-:run"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:run</span></code></a> command:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; foo = putStrLn &quot;foo&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; bar = putStrLn &quot;bar&quot; &gt;&gt; System.Environment.getArgs &gt;&gt;= print
Prelude&gt; :set -main-is foo
Prelude&gt; :main foo &quot;bar baz&quot;
foo
[&quot;foo&quot;,&quot;bar baz&quot;]
Prelude&gt; :run bar [&quot;foo&quot;, &quot;bar baz&quot;]
bar
[&quot;foo&quot;,&quot;bar baz&quot;]
</pre></div>
</div>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:module">
<code class="descname">:module +|- [*]⟨mod1⟩ ...</code><a class="headerlink" href="#ghci-cmd-:module" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-import">
<code class="descname">import ⟨mod⟩</code><a class="headerlink" href="#ghci-cmd-import" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets or modifies the current context for statements typed at the
prompt. The form <code class="docutils literal"><span class="pre">import</span> <span class="pre">mod</span></code> is equivalent to <code class="docutils literal"><span class="pre">:module</span> <span class="pre">+mod</span></code>.
See <a class="reference internal" href="#ghci-scope"><span>プロンプトのスコープにあるもの</span></a> for more details.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:print">
<code class="descname">:print ⟨names⟩</code><a class="headerlink" href="#ghci-cmd-:print" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a value without forcing its evaluation. <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> may be
used on values whose types are unknown or partially known, which
might be the case for local variables with polymorphic types at a
breakpoint. While inspecting the runtime value, <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> attempts
to reconstruct the type of the value, and will elaborate the type in
GHCi&#8217;s environment if possible. If any unevaluated components
(thunks) are encountered, then <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> binds a fresh variable
with a name beginning with <code class="docutils literal"><span class="pre">_t</span></code> to each thunk. See
<a class="reference internal" href="#breakpoints"><span>ブレイクポイントと変数内容の表示</span></a> for more information. See also the <a class="reference internal" href="#ghci-cmd-:sprint"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:sprint</span></code></a>
command, which works like <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a> but does not bind new
variables.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:quit">
<code class="descname">:quit</code><a class="headerlink" href="#ghci-cmd-:quit" title="Permalink to this definition">¶</a></dt>
<dd><p>Quits GHCi. You can also quit by typing <code class="kbd docutils literal"><span class="pre">Control-D</span></code> at the prompt.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:reload">
<code class="descname">:reload[!]</code><a class="headerlink" href="#ghci-cmd-:reload" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to reload the current target set (see <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a>) if any of
the modules in the set, or any dependent module, has changed. Note
that this may entail loading new modules, or dropping modules which
are no longer indirectly required by the target.</p>
<p>Adding the optional &#8220;<code class="docutils literal"><span class="pre">!</span></code>&#8221; turns type errors into warnings while
loading. This allows to use the portions of the module that are
correct, even if there are type errors in some definitions.
Effectively, the &#8220;-fdefer-type-errors&#8221; flag is set before loading
and unset after loading if the flag has not already been set before.
See <a class="reference internal" href="glasgow_exts.html#defer-type-errors"><span>Deferring type errors to runtime</span></a> for further motivation and details.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:run">
<code class="descname">:run</code><a class="headerlink" href="#ghci-cmd-:run" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#ghci-cmd-:main"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:main</span></code></a>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:script">
<code class="descname">:script [⟨n⟩] ⟨filename⟩</code><a class="headerlink" href="#ghci-cmd-:script" title="Permalink to this definition">¶</a></dt>
<dd><p>Executes the lines of a file as a series of GHCi commands. This
command is compatible with multiline statements as set by
<a class="reference internal" href="#ghci-cmd-:set +m"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+m</span></code></a></p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set">
<code class="descname">:set [⟨option⟩ ...]</code><a class="headerlink" href="#ghci-cmd-:set" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets various options. See <a class="reference internal" href="#ghci-set"><span>The :set and :seti commands</span></a> for a list of available
options and <a class="reference internal" href="flags.html#interactive-mode-options"><span>Interactive-mode options</span></a> for a list of
GHCi-specific flags. The <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> command by itself shows which
options are currently set. It also lists the current dynamic flag
settings, with GHCi-specific flags listed separately.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set args">
<code class="descname">:set args ⟨arg⟩</code><a class="headerlink" href="#ghci-cmd-:set args" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-22">Sets the list of arguments which are returned when the program calls
<code class="docutils literal"><span class="pre">System.getArgs</span></code>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set editor">
<code class="descname">:set editor ⟨cmd⟩</code><a class="headerlink" href="#ghci-cmd-:set editor" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the command used by <a class="reference internal" href="#ghci-cmd-:edit"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:edit</span></code></a> to ⟨cmd⟩.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set prog">
<code class="descname">:set prog ⟨prog⟩</code><a class="headerlink" href="#ghci-cmd-:set prog" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-23">Sets the string to be returned when the program calls
<code class="docutils literal"><span class="pre">System.getProgName</span></code>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set prompt">
<code class="descname">:set prompt ⟨prompt⟩</code><a class="headerlink" href="#ghci-cmd-:set prompt" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-24">Sets the string to be used as the prompt in GHCi. Inside ⟨prompt⟩,
the sequence <code class="docutils literal"><span class="pre">%s</span></code> is replaced by the names of the modules
currently in scope, <code class="docutils literal"><span class="pre">%l</span></code> is replaced by the line number (as
referenced in compiler messages) of the current prompt, and <code class="docutils literal"><span class="pre">%%</span></code>
is replaced by <code class="docutils literal"><span class="pre">%</span></code>. If ⟨prompt⟩ starts with <code class="docutils literal"><span class="pre">&quot;</span></code> then it is parsed as
a Haskell String; otherwise it is treated as a literal string.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set prompt2">
<code class="descname">:set prompt2 ⟨prompt⟩</code><a class="headerlink" href="#ghci-cmd-:set prompt2" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the string to be used as the continuation prompt (used when
using the <code class="xref std std-ghci-cmd docutils literal"><span class="pre">:{</span></code> command) in GHCi.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set stop">
<code class="descname">:set stop ⟨num⟩ ⟨cmd⟩</code><a class="headerlink" href="#ghci-cmd-:set stop" title="Permalink to this definition">¶</a></dt>
<dd><p>Set a command to be executed when a breakpoint is hit, or a new item
in the history is selected. The most common use of <a class="reference internal" href="#ghci-cmd-:set stop"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">stop</span></code></a> is
to display the source code at the current location, e.g.
<code class="docutils literal"><span class="pre">:set</span> <span class="pre">stop</span> <span class="pre">:list</span></code>.</p>
<p>If a number is given before the command, then the commands are run
when the specified breakpoint (only) is hit. This can be quite
useful: for example, <code class="docutils literal"><span class="pre">:set</span> <span class="pre">stop</span> <span class="pre">1</span> <span class="pre">:continue</span></code> effectively disables
breakpoint 1, by running <a class="reference internal" href="#ghci-cmd-:continue"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:continue</span></code></a> whenever it is hit (although
GHCi will still emit a message to say the breakpoint was hit). What&#8217;s more,
with cunning use of <a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> and <a class="reference internal" href="#ghci-cmd-:cmd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cmd</span></code></a> you can use
<a class="reference internal" href="#ghci-cmd-:set stop"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">stop</span></code></a> to implement conditional breakpoints:</p>
<div class="highlight-none"><div class="highlight"><pre>*Main&gt; :def cond \expr -&gt; return (&quot;:cmd if (&quot; ++ expr ++ &quot;) then return \&quot;\&quot; else return \&quot;:continue\&quot;&quot;)
*Main&gt; :set stop 0 :cond (x &lt; 3)
</pre></div>
</div>
<p>Ignoring breakpoints for a specified number of iterations is also
possible using similar techniques.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:seti">
<code class="descname">:seti [⟨option⟩ ...]</code><a class="headerlink" href="#ghci-cmd-:seti" title="Permalink to this definition">¶</a></dt>
<dd><p>Like <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a>, but options set with <a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> affect only
expressions and commands typed at the prompt, and not modules loaded
with <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> (in contrast, options set with <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> apply
everywhere). See <a class="reference internal" href="#ghci-interactive-options"><span>Setting options for interactive evaluation only</span></a>.</p>
<p>Without any arguments, displays the current set of options that are
applied to expressions and commands typed at the prompt.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show bindings">
<code class="descname">:show bindings</code><a class="headerlink" href="#ghci-cmd-:show bindings" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the bindings made at the prompt and their types.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show breaks">
<code class="descname">:show breaks</code><a class="headerlink" href="#ghci-cmd-:show breaks" title="Permalink to this definition">¶</a></dt>
<dd><p>List the active breakpoints.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show context">
<code class="descname">:show context</code><a class="headerlink" href="#ghci-cmd-:show context" title="Permalink to this definition">¶</a></dt>
<dd><p>List the active evaluations that are stopped at breakpoints.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show imports">
<code class="descname">:show imports</code><a class="headerlink" href="#ghci-cmd-:show imports" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the imports that are currently in force, as created by
<code class="docutils literal"><span class="pre">import</span></code> and <a class="reference internal" href="#ghci-cmd-:module"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:module</span></code></a> commands.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show modules">
<code class="descname">:show modules</code><a class="headerlink" href="#ghci-cmd-:show modules" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the list of modules currently loaded.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show packages">
<code class="descname">:show packages</code><a class="headerlink" href="#ghci-cmd-:show packages" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the currently active package flags, as well as the list of
packages currently loaded.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show paths">
<code class="descname">:show paths</code><a class="headerlink" href="#ghci-cmd-:show paths" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the current working directory (as set via <a class="reference internal" href="#ghci-cmd-:cd"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:cd</span></code></a> command), as
well as the list of directories searched for source files (as set by the
<code class="docutils literal"><span class="pre">-i</span></code> option).</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show language">
<code class="descname">:show language</code><a class="headerlink" href="#ghci-cmd-:show language" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the currently active language flags for source files.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:showi language">
<code class="descname">:showi language</code><a class="headerlink" href="#ghci-cmd-:showi language" title="Permalink to this definition">¶</a></dt>
<dd><p>Show the currently active language flags for expressions typed at
the prompt (see also <a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a>).</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:show">
<code class="descname">:show [args|prog|prompt|editor|stop]</code><a class="headerlink" href="#ghci-cmd-:show" title="Permalink to this definition">¶</a></dt>
<dd><p>Displays the specified setting (see <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a>).</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:sprint">
<code class="descname">:sprint ⟨expr⟩</code><a class="headerlink" href="#ghci-cmd-:sprint" title="Permalink to this definition">¶</a></dt>
<dd><p>Prints a value without forcing its evaluation. <a class="reference internal" href="#ghci-cmd-:sprint"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:sprint</span></code></a> is
similar to <a class="reference internal" href="#ghci-cmd-:print"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:print</span></code></a>, with the difference that unevaluated subterms
are not bound to new variables, they are simply denoted by <code class="docutils literal"><span class="pre">_</span></code>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:step">
<code class="descname">:step [⟨expr⟩]</code><a class="headerlink" href="#ghci-cmd-:step" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable all breakpoints and begin evaluating an expression in
single-stepping mode. In this mode evaluation will be stopped after
every reduction, allowing local variables to be inspected. If ⟨expr⟩
is not given, evaluation will resume at the last breakpoint. See
<a class="reference internal" href="#single-stepping"><span>ステップ実行</span></a>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:steplocal">
<code class="descname">:steplocal</code><a class="headerlink" href="#ghci-cmd-:steplocal" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable only breakpoints in the current top-level binding and resume
evaluation at the last breakpoint.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:stepmodule">
<code class="descname">:stepmodule</code><a class="headerlink" href="#ghci-cmd-:stepmodule" title="Permalink to this definition">¶</a></dt>
<dd><p>Enable only breakpoints in the current module and resume evaluation
at the last breakpoint.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:trace">
<code class="descname">:trace ⟨expr⟩</code><a class="headerlink" href="#ghci-cmd-:trace" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluates the given expression (or from the last breakpoint if no
expression is given), and additionally logs the evaluation steps for
later inspection using <a class="reference internal" href="#ghci-cmd-:history"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:history</span></code></a>. See <a class="reference internal" href="#tracing"><span>Tracing and history</span></a>.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:type">
<code class="descname">:type ⟨expression⟩</code><a class="headerlink" href="#ghci-cmd-:type" title="Permalink to this definition">¶</a></dt>
<dd><p>Infers and prints the type of ⟨expression⟩, including explicit
forall quantifiers for polymorphic types. The monomorphism
restriction is <em>not</em> applied to the expression during type
inference.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:type-at">
<code class="descname">:type-at ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code><a class="headerlink" href="#ghci-cmd-:type-at" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports the inferred type at the given span/position in the module, e.g.:</p>
<div class="highlight-none"><div class="highlight"><pre>*X&gt; :type-at X.hs 6 6 6 7 f
Int -&gt; Int
</pre></div>
</div>
<p>This command is useful when integrating GHCi with text editors and
IDEs for providing a show-type-under-point facility.</p>
<p>The last string parameter is useful for when the span is out of
date, i.e. the file changed and the code has moved. In which case
<a class="reference internal" href="#ghci-cmd-:type-at"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type-at</span></code></a> falls back to a general <a class="reference internal" href="#ghci-cmd-:type"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type</span></code></a> like lookup.</p>
<p>The <a class="reference internal" href="#ghci-cmd-:type-at"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type-at</span></code></a> command requires <a class="reference internal" href="#ghci-cmd-:set +c"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+c</span></code></a> to be set.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:undef">
<code class="descname">:undef ⟨name⟩</code><a class="headerlink" href="#ghci-cmd-:undef" title="Permalink to this definition">¶</a></dt>
<dd><p>Undefines the user-defined command ⟨name⟩ (see <a class="reference internal" href="#ghci-cmd-:def"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:def</span></code></a> above).</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:unset">
<code class="descname">:unset ⟨option⟩</code><a class="headerlink" href="#ghci-cmd-:unset" title="Permalink to this definition">¶</a></dt>
<dd><p>Unsets certain options. See <a class="reference internal" href="#ghci-set"><span>The :set and :seti commands</span></a> for a list of available
options.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:uses">
<code class="descname">:uses ⟨module⟩ ⟨line⟩ ⟨col⟩ ⟨end-line⟩ ⟨end-col⟩ [⟨name⟩]</code><a class="headerlink" href="#ghci-cmd-:uses" title="Permalink to this definition">¶</a></dt>
<dd><p>Reports all module-local uses of the thing at the given position
in the module, e.g.:</p>
<div class="highlight-none"><div class="highlight"><pre>:uses GhciFind.hs 53 66 53 70 name
GhciFind.hs:(46,25)-(46,29)
GhciFind.hs:(47,37)-(47,41)
GhciFind.hs:(53,66)-(53,70)
GhciFind.hs:(57,62)-(57,66)
</pre></div>
</div>
<p>This command is useful for highlighting and navigating all uses of
an identifier in editors and IDEs.</p>
<p>The <a class="reference internal" href="#ghci-cmd-:uses"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:uses</span></code></a> command requires <a class="reference internal" href="#ghci-cmd-:set +c"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span> <span class="pre">+c</span></code></a> to be set.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:! ⟨command⟩">
<code class="descname">:! ⟨command⟩</code><a class="headerlink" href="#ghci-cmd-:! ⟨command⟩" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-25">Executes the shell command ⟨command⟩.</p>
</dd></dl>

</div>
<div class="section" id="the-set-and-seti-commands">
<span id="ghci-set"></span><h2>5.8. The <code class="docutils literal"><span class="pre">:set</span></code> and <code class="docutils literal"><span class="pre">:seti</span></code> commands<a class="headerlink" href="#the-set-and-seti-commands" title="Permalink to this headline">¶</a></h2>
<p id="index-26">The <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> command sets two types of options: GHCi options, which
begin with &#8220;<code class="docutils literal"><span class="pre">+</span></code>&#8221;, and &#8220;command-line&#8221; options, which begin with &#8220;<code class="docutils literal"><span class="pre">-</span></code>&#8221;.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">At the moment, the <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> command doesn&#8217;t support any kind of
quoting in its arguments: quotes will not be removed and cannot be used
to group words together. For example, <code class="docutils literal"><span class="pre">:set</span> <span class="pre">-DFOO='BAR</span> <span class="pre">BAZ'</span></code> will not
do what you expect.</p>
</div>
<div class="section" id="ghci-options">
<h3>5.8.1. GHCi options<a class="headerlink" href="#ghci-options" title="Permalink to this headline">¶</a></h3>
<p id="index-27">GHCi options may be set using <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> and unset using <a class="reference internal" href="#ghci-cmd-:unset"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:unset</span></code></a>.</p>
<p>The available GHCi options are:</p>
<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +c">
<code class="descname">:set +c</code><a class="headerlink" href="#ghci-cmd-:set +c" title="Permalink to this definition">¶</a></dt>
<dd><p>Collect type and location information after loading modules.
The commands <a class="reference internal" href="#ghci-cmd-:all-types"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:all-types</span></code></a>, <a class="reference internal" href="#ghci-cmd-:loc-at"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:loc-at</span></code></a>,
<a class="reference internal" href="#ghci-cmd-:type-at"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:type-at</span></code></a>, and <a class="reference internal" href="#ghci-cmd-:uses"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:uses</span></code></a> require <code class="docutils literal"><span class="pre">+c</span></code> to be active.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +m">
<code class="descname">:set +m</code><a class="headerlink" href="#ghci-cmd-:set +m" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-28">Enable parsing of multiline commands. A multiline command is
prompted for when the current input line contains open layout
contexts (see <a class="reference internal" href="#ghci-multiline"><span>複数行入力</span></a>).</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +r">
<code class="descname">:set +r</code><a class="headerlink" href="#ghci-cmd-:set +r" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-29">Normally, any evaluation of top-level expressions (otherwise known
as CAFs or Constant Applicative Forms) in loaded modules is retained
between evaluations. Turning on <code class="docutils literal"><span class="pre">+r</span></code> causes all evaluation of
top-level expressions to be discarded after each evaluation (they
are still retained <em>during</em> a single evaluation).</p>
<p>This option may help if the evaluated top-level expressions are
consuming large amounts of space, or if you need repeatable
performance measurements.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +s">
<code class="descname">:set +s</code><a class="headerlink" href="#ghci-cmd-:set +s" title="Permalink to this definition">¶</a></dt>
<dd><p>Display some stats after evaluating each expression, including the
elapsed time and number of bytes allocated. NOTE: the allocation
figure is only accurate to the size of the storage manager&#8217;s
allocation area, because it is calculated at every GC. Hence, you
might see values of zero if no GC has occurred.</p>
</dd></dl>

<dl class="ghci-cmd">
<dt id="ghci-cmd-:set +t">
<code class="descname">:set +t</code><a class="headerlink" href="#ghci-cmd-:set +t" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-30">Display the type of each variable bound after a statement is entered
at the prompt. If the statement is a single expression, then the
only variable binding will be for the variable <code class="docutils literal"><span class="pre">it</span></code>.</p>
</dd></dl>

</div>
<div class="section" id="setting-ghc-command-line-options-in-ghci">
<span id="ghci-cmd-line-options"></span><h3>5.8.2. Setting GHC command-line options in GHCi<a class="headerlink" href="#setting-ghc-command-line-options-in-ghci" title="Permalink to this headline">¶</a></h3>
<p>Normal GHC command-line options may also be set using <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a>. For
example, to turn on <a class="reference internal" href="using-warnings.html#ghc-flag--Wmissing-signatures"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-Wmissing-signatures</span></code></a>, you would say:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :set -Wmissing-signatures
</pre></div>
</div>
<p>Any GHC command-line option that is designated as dynamic (see the table
in <a class="reference internal" href="flags.html#flag-reference"><span>Flag reference</span></a>), may be set using <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a>. To unset an
option, you can set the reverse option:</p>
<div class="highlight-none" id="index-31"><div class="highlight"><pre>Prelude&gt; :set -Wno-incomplete-patterns -XNoMultiParamTypeClasses
</pre></div>
</div>
<p><a class="reference internal" href="flags.html#flag-reference"><span>Flag reference</span></a> lists the reverse for each option where
applicable.</p>
<p>Certain static options (<a class="reference internal" href="phases.html#ghc-flag--package"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-package</span></code></a>, <a class="reference internal" href="phases.html#ghc-flag--I"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-I</span></code></a>, <a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a>,
and <a class="reference internal" href="phases.html#ghc-flag--l"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-l</span></code></a> in particular) will also work, but some may not take effect
until the next reload.</p>
</div>
<div class="section" id="setting-options-for-interactive-evaluation-only">
<span id="ghci-interactive-options"></span><span id="index-32"></span><h3>5.8.3. Setting options for interactive evaluation only<a class="headerlink" href="#setting-options-for-interactive-evaluation-only" title="Permalink to this headline">¶</a></h3>
<p>GHCi actually maintains <em>two</em> sets of options:</p>
<ul class="simple">
<li>The <em>loading options</em> apply when loading modules</li>
<li>The <em>interactive options</em> apply when evaluating expressions and
commands typed at the GHCi prompt.</li>
</ul>
<p>The <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> command modifies both, but there is also a
<a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> command (for &#8220;set interactive&#8221;) that affects only the
interactive options set.</p>
<p>It is often useful to change the interactive options, without having
that option apply to loaded modules too. For example</p>
<div class="highlight-none"><div class="highlight"><pre>:seti -XMonoLocalBinds
</pre></div>
</div>
<p>It would be undesirable if <a class="reference internal" href="glasgow_exts.html#ghc-flag--XMonoLocalBinds"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-XMonoLocalBinds</span></code></a> were to apply to loaded
modules too: that might cause a compilation error, but more commonly it
will cause extra recompilation, because GHC will think that it needs to
recompile the module because the flags have changed.</p>
<p>If you are setting language options in your <code class="docutils literal"><span class="pre">.ghci</span></code> file, it is good
practice to use <a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> rather than <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a>, unless you
really do want them to apply to all modules you load in GHCi.</p>
<p>The two sets of options can be inspected using the <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> and
<a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> commands respectively, with no arguments. For example, in a
clean GHCi session we might see something like this:</p>
<div class="highlight-none"><div class="highlight"><pre>Prelude&gt; :seti
base language is: Haskell2010
with the following modifiers:
  -XNoMonomorphismRestriction
  -XNoDatatypeContexts
  -XNondecreasingIndentation
  -XExtendedDefaultRules
GHCi-specific dynamic flag settings:
other dynamic, non-language, flag settings:
  -fimplicit-import-qualified
warning settings:
</pre></div>
</div>
<p>The two sets of options are initialised as follows. First, both sets of
options are initialised as described in <a class="reference internal" href="#ghci-dot-files"><span>The .ghci and .haskeline files</span></a>. Then the
interactive options are modified as follows:</p>
<ul class="simple">
<li>The option <code class="docutils literal"><span class="pre">-XExtendedDefaultRules</span></code> is enabled, in order to apply
special defaulting rules to expressions typed at the prompt (see
<a class="reference internal" href="#extended-default-rules"><span>GHCi でのデフォルト型設定</span></a>).</li>
<li>The Monomorphism Restriction is disabled (see <a class="reference internal" href="glasgow_exts.html#monomorphism"><span>Switching off the dreaded Monomorphism Restriction</span></a>).</li>
</ul>
</div>
</div>
<div class="section" id="the-ghci-and-haskeline-files">
<span id="ghci-dot-files"></span><h2>5.9. The <code class="docutils literal"><span class="pre">.ghci</span></code> and <code class="docutils literal"><span class="pre">.haskeline</span></code> files<a class="headerlink" href="#the-ghci-and-haskeline-files" title="Permalink to this headline">¶</a></h2>
<div class="section" id="the-ghci-files">
<span id="dot-ghci-files"></span><h3>5.9.1. The <code class="docutils literal"><span class="pre">.ghci</span></code> files<a class="headerlink" href="#the-ghci-files" title="Permalink to this headline">¶</a></h3>
<p id="index-33">When it starts, unless the <a class="reference internal" href="#ghc-flag--ignore-dot-ghci"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ignore-dot-ghci</span></code></a> flag is given, GHCi
reads and executes commands from the following files, in this order, if
they exist:</p>
<ol class="arabic simple">
<li><code class="file docutils literal"><span class="pre">./.ghci</span></code></li>
<li><code class="file docutils literal"><em><span class="pre">appdata</span></em><span class="pre">/ghc/ghci.conf</span></code>, where ⟨appdata⟩ depends on your system,
but is usually something like
<code class="file docutils literal"><span class="pre">C:/Documents</span> <span class="pre">and</span> <span class="pre">Settings/user/Application</span> <span class="pre">Data</span></code></li>
<li>On Unix: <code class="file docutils literal"><span class="pre">$HOME/.ghc/ghci.conf</span></code></li>
<li><code class="file docutils literal"><span class="pre">$HOME/.ghci</span></code></li>
</ol>
<p>The <code class="file docutils literal"><span class="pre">ghci.conf</span></code> file is most useful for turning on favourite options
(e.g. <code class="docutils literal"><span class="pre">:set</span> <span class="pre">+s</span></code>), and defining useful macros.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">When setting language options in this file it is usually desirable to use
<a class="reference internal" href="#ghci-cmd-:seti"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:seti</span></code></a> rather than <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> (see <a class="reference internal" href="#ghci-interactive-options"><span>Setting options for interactive evaluation only</span></a>).</p>
</div>
<p>Placing a <code class="file docutils literal"><span class="pre">.ghci</span></code> file in a directory with a Haskell project is a
useful way to set certain project-wide options so you don&#8217;t have to type
them every time you start GHCi: eg. if your project uses multi-parameter
type classes, scoped type variables, and CPP, and has source files in
three subdirectories A, B and C, you might put the following lines in
<code class="file docutils literal"><span class="pre">.ghci</span></code>:</p>
<div class="highlight-none"><div class="highlight"><pre>:set -XMultiParamTypeClasses -XScopedTypeVariables -cpp
:set -iA:B:C
</pre></div>
</div>
<p>(Note that strictly speaking the <a class="reference internal" href="separate_compilation.html#ghc-flag--i"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-i</span></code></a> flag is a static one, but in
fact it works to set it using <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> like this. The changes won&#8217;t take
effect until the next <a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a>, though.)</p>
<p>Once you have a library of GHCi macros, you may want to source them from
separate files, or you may want to source your <code class="docutils literal"><span class="pre">.ghci</span></code> file into your
running GHCi session while debugging it</p>
<div class="highlight-none"><div class="highlight"><pre>:def source readFile
</pre></div>
</div>
<p>With this macro defined in your <code class="docutils literal"><span class="pre">.ghci</span></code> file, you can use
<code class="docutils literal"><span class="pre">:source</span> <span class="pre">file</span></code> to read GHCi commands from <code class="docutils literal"><span class="pre">file</span></code>. You can find (and
contribute!-) other suggestions for <code class="docutils literal"><span class="pre">.ghci</span></code> files on this Haskell wiki
page: <a class="reference external" href="http://haskell.org/haskellwiki/GHC/GHCi">GHC/GHCi</a></p>
<p>Additionally, any files specified with <a class="reference internal" href="#ghc-flag--ghci-script"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-ghci-script</span></code></a> flags will be
read after the standard files, allowing the use of custom .ghci files.</p>
<p>Two command-line options control whether the startup files files are
read:</p>
<dl class="ghc-flag">
<dt id="ghc-flag--ignore-dot-ghci">
<code class="descname">-ignore-dot-ghci</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--ignore-dot-ghci" title="Permalink to this definition">¶</a></dt>
<dd><p>Don&#8217;t read either <code class="file docutils literal"><span class="pre">./.ghci</span></code> or the other startup files when
starting up.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ghci-script">
<code class="descname">-ghci-script</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--ghci-script" title="Permalink to this definition">¶</a></dt>
<dd><p>Read a specific file after the usual startup files. Maybe be
specified repeatedly for multiple inputs.</p>
</dd></dl>

<p>When defining GHCi macros, there is some important behavior you should
be aware of when names may conflict with built-in commands, especially
regarding tab completion.</p>
<p>For example, consider if you had a macro named <code class="docutils literal"><span class="pre">:time</span></code> and in the
shell, typed <code class="docutils literal"><span class="pre">:t</span> <span class="pre">3</span></code> — what should happen? The current algorithm we use
for completing commands is:</p>
<ol class="arabic simple">
<li>First, look up an exact match on the name from the defined macros.</li>
<li>Look for the exact match on the name in the built-in command list.</li>
<li>Do a prefix lookup on the list of built-in commands - if a built-in
command matches, but a macro is defined with the same name as the
built-in defined, pick the macro.</li>
<li>Do a prefix lookup on the list of built-in commands.</li>
<li>Do a prefix lookup on the list of defined macros.</li>
</ol>
<p>Here are some examples:</p>
<ol class="arabic">
<li><p class="first">You have a macro <code class="docutils literal"><span class="pre">:time</span></code> and enter <code class="docutils literal"><span class="pre">:t</span> <span class="pre">3</span></code></p>
<p>You get <code class="docutils literal"><span class="pre">:type</span> <span class="pre">3</span></code></p>
</li>
<li><p class="first">You have a macro <code class="docutils literal"><span class="pre">:type</span></code> and enter <code class="docutils literal"><span class="pre">:t</span> <span class="pre">3</span></code></p>
<p>You get <code class="docutils literal"><span class="pre">:type</span> <span class="pre">3</span></code> with your defined macro, not the builtin.</p>
</li>
<li><p class="first">You have a macro <code class="docutils literal"><span class="pre">:time</span></code> and a macro <code class="docutils literal"><span class="pre">:type</span></code>, and enter <code class="docutils literal"><span class="pre">:t</span> <span class="pre">3</span></code></p>
<p>You get <code class="docutils literal"><span class="pre">:type</span> <span class="pre">3</span></code> with your defined macro.</p>
</li>
</ol>
</div>
<div class="section" id="the-haskeline-file">
<span id="dot-haskeline-file"></span><h3>5.9.2. The <code class="docutils literal"><span class="pre">.haskeline</span></code> file<a class="headerlink" href="#the-haskeline-file" title="Permalink to this headline">¶</a></h3>
<p id="index-34">GHCi uses <a class="reference external" href="https://hackage.haskell.org/package/haskeline">Haskeline</a> under
the hood. You can configure it to, among other
things, prune duplicates from GHCi history. See:
<a class="reference external" href="http://trac.haskell.org/haskeline/wiki/UserPrefs">Haskeline user preferences</a>.</p>
</div>
</div>
<div class="section" id="compiling-to-object-code-inside-ghci">
<span id="ghci-obj"></span><h2>5.10. Compiling to object code inside GHCi<a class="headerlink" href="#compiling-to-object-code-inside-ghci" title="Permalink to this headline">¶</a></h2>
<p>By default, GHCi compiles Haskell source code into byte-code that is
interpreted by the runtime system. GHCi can also compile Haskell code to
object code: to turn on this feature, use the <a class="reference internal" href="phases.html#ghc-flag--fobject-code"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fobject-code</span></code></a> flag
either on the command line or with <a class="reference internal" href="#ghci-cmd-:set"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:set</span></code></a> (the option <a class="reference internal" href="phases.html#ghc-flag--fbyte-code"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fbyte-code</span></code></a>
restores byte-code compilation again). Compiling to object code takes
longer, but typically the code will execute 10-20 times faster than
byte-code.</p>
<p>Compiling to object code inside GHCi is particularly useful if you are
developing a compiled application, because the <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> command
typically runs much faster than restarting GHC with <a class="reference internal" href="using.html#ghc-flag---make"><code class="xref std std-ghc-flag docutils literal"><span class="pre">--make</span></code></a> from the
command-line, because all the interface files are already cached in
memory.</p>
<p>There are disadvantages to compiling to object-code: you can&#8217;t set
breakpoints in object-code modules, for example. Only the exports of an
object-code module will be visible in GHCi, rather than all top-level
bindings as in interpreted modules.</p>
</div>
<div class="section" id="running-the-interpreter-in-a-separate-process">
<span id="external-interpreter"></span><h2>5.11. Running the interpreter in a separate process<a class="headerlink" href="#running-the-interpreter-in-a-separate-process" title="Permalink to this headline">¶</a></h2>
<p>Normally GHCi runs the interpreted code in the same process as GHC
itself, on top of the same RTS and sharing the same heap.  However, if
the flag <a class="reference internal" href="#ghc-flag--fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fexternal-interpreter</span></code></a> is given, then GHC will spawn a
separate process for running interpreted code, and communicate with it
using messages over a pipe.</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fexternal-interpreter">
<code class="descname">-fexternal-interpreter</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fexternal-interpreter" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Since:</th><td class="field-body">8.0.1</td>
</tr>
</tbody>
</table>
<p>Run interpreted code (for GHCi, Template Haskell, Quasi-quoting,
or Annotations) in a separate process.  The interpreter will run
in profiling mode if <a class="reference internal" href="profiling.html#ghc-flag--prof"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-prof</span></code></a> is in effect, and in
dynamically-linked mode if <a class="reference internal" href="phases.html#ghc-flag--dynamic"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-dynamic</span></code></a> is in effect.</p>
<p>There are a couple of caveats that will hopefully be removed in
the future: this option is currently not implemented on Windows
(it is a no-op), and the external interpreter does not support the
GHCi debugger, so breakpoints and single-stepping don&#8217;t work with
<a class="reference internal" href="#ghc-flag--fexternal-interpreter"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fexternal-interpreter</span></code></a>.</p>
<p>See also the <a class="reference internal" href="phases.html#ghc-flag--pgmi"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-pgmi</span></code></a> (<a class="reference internal" href="phases.html#replacing-phases"><span>Replacing the program for one or more phases</span></a>) and <a class="reference internal" href="phases.html#ghc-flag--opti"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-opti</span></code></a>
(<a class="reference internal" href="phases.html#forcing-options-through"><span>Forcing options to a particular phase</span></a>) flags.</p>
</dd></dl>

<p>Why might we want to do this?  The main reason is that the RTS running
the interpreted code can be a different flavour (profiling or
dynamically-linked) from GHC itself.  So for example:</p>
<ul class="simple">
<li>We can use the profiler to collect stack traces when using GHCi (see
<a class="reference internal" href="#ghci-stack-traces"><span>GHCiのスタックトレース</span></a>).</li>
<li>When compiling Template Haskell code with <a class="reference internal" href="profiling.html#ghc-flag--prof"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-prof</span></code></a> we don&#8217;t need to
compile the modules without <a class="reference internal" href="profiling.html#ghc-flag--prof"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-prof</span></code></a> first (see <a class="reference internal" href="glasgow_exts.html#th-profiling"><span>Using Template Haskell with Profiling</span></a>)
because we can run the profiled object code in the interpreter.</li>
</ul>
<p>This feature is experimental in GHC 8.0.x, but it may become the
default in future releases.</p>
</div>
<div class="section" id="faq-and-things-to-watch-out-for">
<span id="ghci-faq"></span><h2>5.12. FAQ and Things To Watch Out For<a class="headerlink" href="#faq-and-things-to-watch-out-for" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt>The interpreter can&#8217;t load modules with foreign export declarations!</dt>
<dd>Unfortunately not. We haven&#8217;t implemented it yet. Please compile any
offending modules by hand before loading them into GHCi.</dd>
</dl>
<p><a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> doesn&#8217;t work with GHCi!</p>
<blockquote>
<div><p id="index-35">For technical reasons, the bytecode compiler doesn&#8217;t interact well
with one of the optimisation passes, so we have disabled
optimisation when using the interpreter. This isn&#8217;t a great loss:
you&#8217;ll get a much bigger win by compiling the bits of your code that
need to go fast, rather than interpreting them with optimisation
turned on.</p>
</div></blockquote>
<dl class="docutils">
<dt>Unboxed tuples don&#8217;t work with GHCi</dt>
<dd>That&#8217;s right. You can always compile a module that uses unboxed
tuples and load it into GHCi, however. (Incidentally the previous
point, namely that <a class="reference internal" href="using-optimisation.html#ghc-flag--O"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-O</span></code></a> is incompatible with GHCi, is because the
bytecode compiler can&#8217;t deal with unboxed tuples).</dd>
<dt>Concurrent threads don&#8217;t carry on running when GHCi is waiting for input.</dt>
<dd>This should work, as long as your GHCi was built with the
<a class="reference internal" href="phases.html#ghc-flag--threaded"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-threaded</span></code></a> switch, which is the default. Consult whoever supplied
your GHCi installation.</dd>
<dt>After using <code class="docutils literal"><span class="pre">getContents</span></code>, I can&#8217;t use <code class="docutils literal"><span class="pre">stdin</span></code>, until I do <code class="docutils literal"><span class="pre">:load</span></code> or <code class="docutils literal"><span class="pre">:reload</span></code></dt>
<dd><p class="first">This is the defined behaviour of <code class="docutils literal"><span class="pre">getContents</span></code>: it puts the stdin
Handle in a state known as semi-closed, wherein any further I/O
operations on it are forbidden. Because I/O state is retained
between computations, the semi-closed state persists until the next
<a class="reference internal" href="#ghci-cmd-:load"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:load</span></code></a> or <a class="reference internal" href="#ghci-cmd-:reload"><code class="xref std std-ghci-cmd docutils literal"><span class="pre">:reload</span></code></a> command.</p>
<p class="last">You can make <code class="docutils literal"><span class="pre">stdin</span></code> reset itself after every evaluation by giving
GHCi the command <code class="docutils literal"><span class="pre">:set</span> <span class="pre">+r</span></code>. This works because <code class="docutils literal"><span class="pre">stdin</span></code> is just a
top-level expression that can be reverted to its unevaluated state
in the same way as any other top-level expression (CAF).</p>
</dd>
<dt>I can&#8217;t use <code class="kbd docutils literal"><span class="pre">Control-C</span></code> to interrupt computations in GHCi on Windows.</dt>
<dd>See <a class="reference internal" href="win32-dlls.html#ghci-windows"><span>Running GHCi on Windows</span></a>.</dd>
<dt>The default buffering mode is different in GHCi to GHC.</dt>
<dd><p class="first">In GHC, the stdout handle is line-buffered by default. However, in
GHCi we turn off the buffering on stdout, because this is normally
what you want in an interpreter: output appears as it is generated.</p>
<p>If you want line-buffered behaviour, as in GHC, you can start your
program thus:</p>
<div class="last highlight-haskell"><div class="highlight"><pre><span class="nf">main</span> <span class="ow">=</span> <span class="kr">do</span> <span class="p">{</span> <span class="n">hSetBuffering</span> <span class="n">stdout</span> <span class="kt">LineBuffering</span><span class="p">;</span> <span class="o">...</span> <span class="p">}</span>
</pre></div>
</div>
</dd>
</dl>
<table class="docutils footnote" frame="void" id="id31" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id23">[5]</a></td><td>Note that packages only contain compiled code, so debugging a package
requires finding its source and loading that directly.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id32" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id25">[6]</a></td><td>We originally provided bindings for all variables in scope, rather
than just the free variables of the expression, but found that this
affected performance considerably, hence the current restriction to
just the free variables.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="runghc.html" title="6. Using runghc"
             >next</a> |</li>
        <li class="right" >
          <a href="8.0.2-notes.html" title="4. バージョン 8.0.2 のリリースノート"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.0.2 Users Guide</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, GHC Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>