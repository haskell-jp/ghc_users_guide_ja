
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.3. 最適化 (コードの改善) &mdash; Glasgow Haskell Compiler &lt;release&gt; Users Guide</title>
    
    <link rel="stylesheet" href="_static/ghc-theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '8.0.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Glasgow Haskell Compiler &lt;release&gt; Users Guide" href="index.html" />
    <link rel="up" title="7. GHCを使う" href="usage.html" />
    <link rel="next" title="7.4. Using Concurrent Haskell" href="using-concurrent.html" />
    <link rel="prev" title="7.2. 警告と整合性検査" href="using-warnings.html" /> 
  </head>
  <body role="document">
<div class="logo">
    <h1><a href="index.html">Glasgow Haskell Compiler Users Guide</a></h1>
</div>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="using-concurrent.html" title="7.4. Using Concurrent Haskell"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="using-warnings.html" title="7.2. 警告と整合性検査"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.0.2 Users Guide</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="usage.html" accesskey="U">7. GHCを使う</a> &raquo;</li> 
      </ul>
    </div>

      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.3. 最適化 (コードの改善)</a><ul>
<li><a class="reference internal" href="#o">7.3.1. <code class="docutils literal"><span class="pre">-O*</span></code>: 便利な最適化フラグの「詰め合わせ」</a></li>
<li><a class="reference internal" href="#f">7.3.2. <code class="docutils literal"><span class="pre">-f*</span></code>: プラットフォーム非依存のフラグ</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="using-warnings.html"
                        title="previous chapter">7.2. 警告と整合性検査</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="using-concurrent.html"
                        title="next chapter">7.4. Using Concurrent Haskell</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/using-optimisation.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="options-optimise">
<span id="id1"></span><h1>7.3. 最適化 (コードの改善)<a class="headerlink" href="#options-optimise" title="Permalink to this headline">¶</a></h1>
<p id="index-0"><code class="docutils literal"><span class="pre">-O*</span></code> オプションば便利な最適化フラグの「詰め合わせ」を指定するのに使います．
<em>個別の</em> 最適化を有効/無効にするには，後述する <code class="docutils literal"><span class="pre">-f*</span></code> オプションを使います．
<em>マシン固有</em> の最適化を有効/無効にするには <code class="docutils literal"><span class="pre">-m*</span></code> オプションを使います．</p>
<p>こうしたオプションのほとんどは，オプションをオン/オフする論理値になっています(オフにする場合は <code class="docutils literal"><span class="pre">no-</span></code> が前置されます)．
<code class="docutils literal"><span class="pre">-fspecialise</span></code> は特定化を有効にし，<code class="docutils literal"><span class="pre">-fno-specialise</span></code> は無効にします．
同じオプションに関して複数のフラグが1つのコマンドラインにあらわれたときは左から右への順で評価されますので，
<code class="docutils literal"><span class="pre">-fno-specialise</span> <span class="pre">-fspecialise</span></code> という指定では，特定化は有効になります．</p>
<p><code class="docutils literal"><span class="pre">-O*</span></code> という型のフラグは大まかにいって <code class="docutils literal"><span class="pre">-f*</span></code> という型のフラグの組み合わせを指定しているものになっているということに注意をしてください．
したがって <code class="docutils literal"><span class="pre">-O*</span></code> フラグと <code class="docutils literal"><span class="pre">-f*</span></code> フラグの効果はコマンドライン中にあらわれる順番に依存します．</p>
<p><code class="docutils literal"><span class="pre">-fno-specialise</span> <span class="pre">-O1</span></code> を例にとってみましょう．
コマンドラインに <code class="docutils literal"><span class="pre">-fno-specialise</span></code> があっても，特定化(specialisation)は有効になります．
これは <code class="docutils literal"><span class="pre">-O1</span></code> が <code class="docutils literal"><span class="pre">-fspecialise</span></code> を有効にするので，先に指定したフラグを上書きしてしまいます．
これとは対照的に <code class="docutils literal"><span class="pre">-O1</span> <span class="pre">-fno-specialise</span></code> のようにすると予想どおり特定化は発動しません．</p>
<div class="section" id="o">
<span id="optimise-pkgs"></span><h2>7.3.1. <code class="docutils literal"><span class="pre">-O*</span></code>: 便利な最適化フラグの「詰め合わせ」<a class="headerlink" href="#o" title="Permalink to this headline">¶</a></h2>
<p>GHCが生成するコードの質に影響を与えるオプションは <em>大量に</em> あります．
ほとんどの人にとっては，最適化の目標は「素早くコンパイルする」とか「電光石火のごとく走るプログラムコードを生成する」など一般的なものです．
したがって，以下にしめすような最適化の「詰め合わせ」を指定(あるいは指定しない)する選択をするだけで十分です．</p>
<p>最適化のレベルを高くすると，モジュールを跨ぐ最適化が増えます．
これは，ソースコードを変更したときにどの程度の再コンパイルする必要があるかに大きく影響します．
これは開発中は最適化をしないようにすることの理由の1つです．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--O*">
<code class="descname">-O*</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--O*" title="Permalink to this definition">¶</a></dt>
<dd><p>このフラグの意味は「速くコンパイルしてね，生成したコードのインスタンスについてはうるさいことは言わないから」です．
たとえば <code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-c</span> <span class="pre">Foo.hs</span></code> のようにします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--O0">
<code class="descname">-O0</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--O0" title="Permalink to this definition">¶</a></dt>
<dd><p>「すべての最適化を無効にする」という意味です． <code class="docutils literal"><span class="pre">-O``オプションを全く指定しないのと同じ状態にするということです．</span>
<span class="pre">わざわざ</span> <span class="pre">``-O0</span></code> を指定するのは <code class="docutils literal"><span class="pre">make</span></code> が既に <code class="docutils literal"><span class="pre">-O</span></code> オプションを指定してしまっているときに便利です．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--O">
<code class="descname">-O</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--O" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--O1">
<code class="descname">-O1</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--O1" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-1">「高品質のコードをそれほど時間をかけないで生成する」という意味です．
<code class="docutils literal"><span class="pre">ghc</span> <span class="pre">-c</span> <span class="pre">-O</span> <span class="pre">Main.lhs</span></code> のように使います．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--O2">
<code class="descname">-O2</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--O2" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-2">「危険のない最適化をすべて適用する．コンパイルにかなりの時間を書けてもよい」という意味です．</p>
<p>ここで回避しようとしている「危険な」最適化とは，運が悪ければ，実行時における時間・空間性能を <em>悪化させる</em> 可能性があるということです．
通常これらの最適化は個別に指定します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--Odph">
<code class="descname">-Odph</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--Odph" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-3">すべての <code class="docutils literal"><span class="pre">-O2</span></code> の最適化を有効にした上で <code class="docutils literal"><span class="pre">-fmax-simplifier-iterations=20</span></code> と <code class="docutils literal"><span class="pre">-fsimplifier-phases=3</span></code> を設定します．
<a class="reference internal" href="parallel.html#dph"><span>Data Parallel Haskell (DPH)</span></a> を使うときように設計されました．</p>
</dd></dl>

<p>日常の作業で <code class="docutils literal"><span class="pre">-O*</span></code> フラグを使うことはありません．
それなりの速度が必要なときには <code class="docutils literal"><span class="pre">-O</span></code> を使います．
たとえば，何かを計測したいときなどです．
ちょっと休憩したいときには <code class="docutils literal"><span class="pre">-O2</span></code> を使い(たっぷりのコーヒーブレイクに行き)ます．</p>
<p><code class="docutils literal"><span class="pre">-O</span></code> (など)の「実際の意味」を知りたければ <a class="reference internal" href="using.html#ghc-flag--v"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-v</span></code></a> を付ければいいでしょう．
びっくりして，後ずさりすることになるでしょうね．</p>
</div>
<div class="section" id="f">
<span id="options-f"></span><h2>7.3.2. <code class="docutils literal"><span class="pre">-f*</span></code>: プラットフォーム非依存のフラグ<a class="headerlink" href="#f" title="Permalink to this headline">¶</a></h2>
<p id="index-4">これらのフラグは個々の最適化を有効/無効にするのに使います．
<code class="docutils literal"><span class="pre">-O</span></code> を使えば，「デフォルトで有効」となっているフラグをすべて有効にできます．
したがって，明示的に指定する必要はないはずです．
<code class="docutils literal"><span class="pre">-fwombat</span></code> というフラグの否定は <code class="docutils literal"><span class="pre">-fno-wombat</span></code> です．概略の一覧表は <a class="reference internal" href="flags.html#options-f-compact"><span>Individual optimisations</span></a> を参照してください．</p>
<dl class="ghc-flag">
<dt id="ghc-flag--fcase-merge">
<code class="descname">-fcase-merge</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fcase-merge" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>直接入れ子になった case 式の検査対象が同じ変数である場合，1つにまとめます．
たとえば，</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Red</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="kr">_</span>   <span class="ow">-&gt;</span> <span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
            <span class="kt">Blue</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
            <span class="kt">Green</span> <span class="ow">-&gt;</span> <span class="n">e3</span>
</pre></div>
</div>
<p>は以下のよう変換する．</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">case</span> <span class="n">x</span> <span class="kr">of</span>
   <span class="kt">Red</span> <span class="ow">-&gt;</span> <span class="n">e1</span>
   <span class="kt">Blue</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
   <span class="kt">Green</span> <span class="ow">-&gt;</span> <span class="n">e2</span>
</pre></div>
</div>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcall-arity">
<code class="descname">-fcall-arity</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fcall-arity" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>コール・アリティ解析を有効にします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcmm-elim-common-blocks">
<code class="descname">-fcmm-elim-common-blocks</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fcmm-elim-common-blocks" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>コード生成器における共通ブロック除去を有効にします．
この最適化の目的は，同一の Cmm ブロックを探し，それを除去します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcmm-sink">
<code class="descname">-fcmm-sink</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fcmm-sink" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>コード生成器におけるシンキング(コード位置を後ろにずらすこと)のパスを有効にします．
この最適化の目的は Cmm の同一のブロックを探すことです．
その重複を除去すれば変数束縛を使う場所に近づけられます．
このパスではリテラルやレジスタなどの単純な式を埋め込みます．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcpr-off">
<code class="descname">-fcpr-off</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fcpr-off" title="Permalink to this definition">¶</a></dt>
<dd><p>デマンド解析器における CPR 解析を無効にする．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcse">
<code class="descname">-fcse</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fcse" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>共通部分式除去の最適化を有効にします．
共通式としてまとめたくないような <code class="docutils literal"><span class="pre">unsafePerformIO</span></code> 式を使っている場合にはこれを無効にするのが便利です．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdicts-cheap">
<code class="descname">-fdicts-cheap</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fdicts-cheap" title="Permalink to this definition">¶</a></dt>
<dd><p>かなり実験的なフラグで，辞書を値にもつような式のコストを最適化器が安く見積るようにします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdicts-strict">
<code class="descname">-fdicts-strict</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fdicts-strict" title="Permalink to this definition">¶</a></dt>
<dd><p>辞書を正格にします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdmd-tx-dict-sel">
<code class="descname">-fdmd-tx-dict-sel</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fdmd-tx-dict-sel" title="Permalink to this definition">¶</a></dt>
<dd><p><em>オプション ``-O0`` ， ``-O`` ， ``-O2`` のもとではデフォルトで有効</em></p>
<p>辞書選択子ように特別な要求変換子を使います．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdo-eta-reduction">
<code class="descname">-fdo-eta-reduction</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fdo-eta-reduction" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>λ抽象式をη簡約することで，複数のλ抽象式をまとめて除去できるなら，そうします．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fdo-lambda-eta-expansion">
<code class="descname">-fdo-lambda-eta-expansion</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fdo-lambda-eta-expansion" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">有効</td>
</tr>
</tbody>
</table>
<p>アリティを増やすために let 束縛をη展開します．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--feager-blackholing">
<code class="descname">-feager-blackholing</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--feager-blackholing" title="Permalink to this definition">¶</a></dt>
<dd><p>通常 GHC はスレッドを切り替える場合にのみサンクをブラックホール化します．
このフラグは，サンクに入ってすぐにこれを行うようにします．
以下を参照してください． <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/parallel/">Haskell on a shared-memory
multiprocessor</a>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fexcess-precision">
<code class="descname">-fexcess-precision</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fexcess-precision" title="Permalink to this definition">¶</a></dt>
<dd><p>このオプションを指定すると，中間の浮動小数点数が最終的な型よりも <em>大きな</em> 精度/範囲をもつことを許すことになります．
このことは一般的には良いことです．
しかし <code class="docutils literal"><span class="pre">Float</span></code>/<code class="docutils literal"><span class="pre">Double</span></code> 値がその精度/範囲に正確におさまっていることに依存するプログラムが存在することもあり，
そのようなプログラムにはこのオプションを指定してコンパイルしてはいけません．</p>
<p>32-bit x86 のネイティブコード生成器は excess-precision モードしかサポートしておらず <code class="docutils literal"><span class="pre">-fexcess-precision</span></code> も
<code class="docutils literal"><span class="pre">-fno-excess-precision</span></code> も効果を持ちません．これは既知のバグです． <a class="reference internal" href="bugs.html#bugs-ghc"><span>Bugs in GHC</span></a> を参照してください．</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fexpose-all-unfoldings">
<code class="descname">-fexpose-all-unfoldings</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fexpose-all-unfoldings" title="Permalink to this definition">¶</a></dt>
<dd><p>An experimental flag to expose all unfoldings, even for very large
or recursive functions. This allows for all functions to be inlined
while usually GHC would avoid inlining larger functions.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ffloat-in">
<code class="descname">-ffloat-in</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--ffloat-in" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Float let-bindings inwards, nearer their binding
site. See <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs
(ICFP&#8216;96)</a>.</p>
<p>This optimisation moves let bindings closer to their use site. The
benefit here is that this may avoid unnecessary allocation if the
branch the let is now on is never executed. It also enables other
optimisation passes to work more effectively as they have more
information locally.</p>
<p>This optimisation isn&#8217;t always beneficial though (so GHC applies
some heuristics to decide when to apply it). The details get
complicated but a simple example is that it is often beneficial to
move let bindings outwards so that multiple let bindings can be
grouped into a larger single let binding, effectively batching their
allocation and helping the garbage collector and allocator.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ffull-laziness">
<code class="descname">-ffull-laziness</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--ffull-laziness" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Run the full laziness optimisation (also known as
let-floating), which floats let-bindings outside enclosing lambdas,
in the hope they will be thereby be computed less often. See
<a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/float.ps.gz">Let-floating: moving bindings to give faster programs
(ICFP&#8216;96)</a>.
Full laziness increases sharing, which can lead to increased memory
residency.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">GHC doesn&#8217;t implement complete full-laziness. When
optimisation in on, and <code class="docutils literal"><span class="pre">-fno-full-laziness</span></code> is not given, some
transformations that increase sharing are performed, such as
extracting repeated computations from a loop. These are the same
transformations that a fully lazy implementation would do, the
difference is that GHC doesn&#8217;t consistently apply full-laziness, so
don&#8217;t rely on it.</p>
</div>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--ffun-to-thunk">
<code class="descname">-ffun-to-thunk</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--ffun-to-thunk" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Worker-wrapper removes unused arguments, but usually we do not
remove them all, lest it turn a function closure into a thunk,
thereby perhaps creating a space leak and/or disrupting inlining.
This flag allows worker/wrapper to remove <em>all</em> value lambdas.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fignore-asserts">
<code class="descname">-fignore-asserts</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fignore-asserts" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Causes GHC to ignore uses of the function <code class="docutils literal"><span class="pre">Exception.assert</span></code> in source
code (in other words, rewriting <code class="docutils literal"><span class="pre">Exception.assert</span> <span class="pre">p</span> <span class="pre">e</span></code> to <code class="docutils literal"><span class="pre">e</span></code> (see
<a class="reference internal" href="glasgow_exts.html#assertions"><span>Assertions</span></a>).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fignore-interface-pragmas">
<code class="descname">-fignore-interface-pragmas</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fignore-interface-pragmas" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells GHC to ignore all inessential information when reading
interface files. That is, even if <code class="file docutils literal"><span class="pre">M.hi</span></code> contains unfolding or
strictness information for a function, GHC will ignore that
information.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--flate-dmd-anal">
<code class="descname">-flate-dmd-anal</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--flate-dmd-anal" title="Permalink to this definition">¶</a></dt>
<dd><p>Run demand analysis again, at the end of the simplification
pipeline. We found some opportunities for discovering strictness
that were not visible earlier; and optimisations like
<a class="reference internal" href="#ghc-flag--fspec-constr"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fspec-constr</span></code></a> can create functions with unused arguments which
are eliminated by late demand analysis. Improvements are modest, but
so is the cost. See notes on the <a class="reference external" href="http://ghc.haskell.org/trac/ghc/wiki/LateDmd">Trac wiki page</a>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fliberate-case">
<code class="descname">-fliberate-case</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fliberate-case" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Off by default, but enabled by -O2.</em> Turn on the liberate-case
transformation. This unrolls recursive function once in its own RHS,
to avoid repeated case analysis of free variables. It&#8217;s a bit like
the call-pattern specialiser (<a class="reference internal" href="#ghc-flag--fspec-constr"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fspec-constr</span></code></a>) but for free
variables rather than arguments.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fliberate-case-threshold">
<code class="descname">-fliberate-case-threshold</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fliberate-case-threshold" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">2000</td>
</tr>
</tbody>
</table>
<p>Set the size threshold for the liberate-case transformation.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--floopification">
<code class="descname">-floopification</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--floopification" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>When this optimisation is enabled the code generator will turn all
self-recursive saturated tail calls into local jumps rather than
function calls.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-inline-alloc-size">
<code class="descname">-fmax-inline-alloc-size</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-inline-alloc-size" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">128</td>
</tr>
</tbody>
</table>
<p>Set the maximum size of inline array allocations to n bytes.
GHC will allocate non-pinned arrays of statically known size in the current
nursery block if they&#8217;re no bigger than n bytes, ignoring GC overheap. This
value should be quite a bit smaller than the block size (typically: 4096).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-inline-memcpy-insn">
<code class="descname">-fmax-inline-memcpy-insn</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-inline-memcpy-insn" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">32</td>
</tr>
</tbody>
</table>
<p>Inline <code class="docutils literal"><span class="pre">memcpy</span></code> calls if they would generate no more than ⟨n⟩ pseudo-instructions.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-inline-memset-insns">
<code class="descname">-fmax-inline-memset-insns</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-inline-memset-insns" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">32</td>
</tr>
</tbody>
</table>
<p>Inline <code class="docutils literal"><span class="pre">memset</span></code> calls if they would generate no more than n pseudo
instructions.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-relevant-binds">
<code class="descname">-fmax-relevant-binds</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-relevant-binds" title="Permalink to this definition">¶</a></dt>
<dt id="ghc-flag--fno-max-relevant-bindings">
<code class="descname">-fno-max-relevant-bindings</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fno-max-relevant-bindings" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">6</td>
</tr>
</tbody>
</table>
<p>The type checker sometimes displays a fragment of the type
environment in error messages, but only up to some maximum number,
set by this flag. Turning it off with
<code class="docutils literal"><span class="pre">-fno-max-relevant-bindings</span></code> gives an unlimited number.
Syntactically top-level bindings are also usually excluded (since
they may be numerous), but <code class="docutils literal"><span class="pre">-fno-max-relevant-bindings</span></code> includes
them too.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-simplifier-iterations">
<code class="descname">-fmax-simplifier-iterations</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-simplifier-iterations" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">4</td>
</tr>
</tbody>
</table>
<p>Sets the maximal number of iterations for the simplifier.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fmax-worker-args">
<code class="descname">-fmax-worker-args</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fmax-worker-args" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">10</td>
</tr>
</tbody>
</table>
<p>If a worker has that many arguments, none will be unpacked anymore.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fno-opt-coercion">
<code class="descname">-fno-opt-coercion</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fno-opt-coercion" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn off the coercion optimiser.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fno-pre-inlining">
<code class="descname">-fno-pre-inlining</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fno-pre-inlining" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn off pre-inlining.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fno-state-hack">
<code class="descname">-fno-state-hack</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fno-state-hack" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn off the &#8220;state hack&#8221; whereby any lambda with a <code class="docutils literal"><span class="pre">State#</span></code> token
as argument is considered to be single-entry, hence it is considered
okay to inline things inside it. This can improve performance of IO
and ST monad code, but it runs the risk of reducing sharing.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fomit-interface-pragmas">
<code class="descname">-fomit-interface-pragmas</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fomit-interface-pragmas" title="Permalink to this definition">¶</a></dt>
<dd><p>Tells GHC to omit all inessential information from the interface
file generated for the module being compiled (say M). This means
that a module importing M will see only the <em>types</em> of the functions
that M exports, but not their unfoldings, strictness info, etc.
Hence, for example, no function exported by M will be inlined into
an importing module. The benefit is that modules that import M will
need to be recompiled less often (only when M&#8217;s exports change their
type, not when they change their implementation).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fomit-yields">
<code class="descname">-fomit-yields</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fomit-yields" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Tells GHC to omit heap checks when no allocation is
being performed. While this improves binary sizes by about 5%, it
also means that threads run in tight non-allocating loops will not
get preempted in a timely fashion. If it is important to always be
able to interrupt such threads, you should turn this optimization
off. Consider also recompiling all libraries with this optimization
turned off, if you need to guarantee interruptibility.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fpedantic-bottoms">
<code class="descname">-fpedantic-bottoms</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fpedantic-bottoms" title="Permalink to this definition">¶</a></dt>
<dd><p>Make GHC be more precise about its treatment of bottom (but see also
<a class="reference internal" href="#ghc-flag--fno-state-hack"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fno-state-hack</span></code></a>). In particular, stop GHC eta-expanding through
a case expression, which is good for performance, but bad if you are
using <code class="docutils literal"><span class="pre">seq</span></code> on partial applications.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fregs-graph">
<code class="descname">-fregs-graph</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fregs-graph" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Off by default due to a performance regression bug. Only applies in
combination with the native code generator.</em> Use the graph colouring
register allocator for register allocation in the native code
generator. By default, GHC uses a simpler, faster linear register
allocator. The downside being that the linear register allocator
usually generates worse code.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fregs-iterative">
<code class="descname">-fregs-iterative</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fregs-iterative" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Off by default, only applies in combination with the native code
generator.</em> Use the iterative coalescing graph colouring register
allocator for register allocation in the native code generator. This
is the same register allocator as the <code class="docutils literal"><span class="pre">-fregs-graph</span></code> one but also
enables iterative coalescing during register allocation.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fsimplifier-phases">
<code class="descname">-fsimplifier-phases</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fsimplifier-phases" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">2</td>
</tr>
</tbody>
</table>
<p>Set the number of phases for the simplifier. Ignored with <code class="docutils literal"><span class="pre">-O0</span></code>.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fsimpl-tick-factor">
<code class="descname">-fsimpl-tick-factor</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fsimpl-tick-factor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">100</td>
</tr>
</tbody>
</table>
<p>GHC&#8217;s optimiser can diverge if you write rewrite rules
(<a class="reference internal" href="glasgow_exts.html#rewrite-rules"><span>Rewrite rules</span></a>) that don&#8217;t terminate, or (less satisfactorily)
if you code up recursion through data types (<a class="reference internal" href="bugs.html#bugs-ghc"><span>Bugs in GHC</span></a>). To
avoid making the compiler fall into an infinite loop, the optimiser
carries a &#8220;tick count&#8221; and stops inlining and applying rewrite rules
when this count is exceeded. The limit is set as a multiple of the
program size, so bigger programs get more ticks. The
<code class="docutils literal"><span class="pre">-fsimpl-tick-factor</span></code> flag lets you change the multiplier. The
default is 100; numbers larger than 100 give more ticks, and numbers
smaller than 100 give fewer.</p>
<p>If the tick-count expires, GHC summarises what simplifier steps it
has done; you can use <code class="docutils literal"><span class="pre">-fddump-simpl-stats</span></code> to generate a much
more detailed list. Usually that identifies the loop quite
accurately, because some numbers are very large.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr">
<code class="descname">-fspec-constr</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fspec-constr" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Off by default, but enabled by -O2.</em> Turn on call-pattern
specialisation; see <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/spec-constr/index.htm">Call-pattern specialisation for Haskell
programs</a>.</p>
<p>This optimisation specializes recursive functions according to their
argument &#8220;shapes&#8221;. This is best explained by example so consider:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">last</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">last</span> <span class="kt">[]</span> <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;last&quot;</span>
<span class="nf">last</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="kt">[]</span><span class="p">)</span> <span class="ow">=</span> <span class="n">x</span>
<span class="nf">last</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last</span> <span class="n">xs</span>
</pre></div>
</div>
<p>In this code, once we pass the initial check for an empty list we
know that in the recursive case this pattern match is redundant. As
such <code class="docutils literal"><span class="pre">-fspec-constr</span></code> will transform the above code to:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="nf">last</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">last</span> <span class="kt">[]</span>       <span class="ow">=</span> <span class="ne">error</span> <span class="s">&quot;last&quot;</span>
<span class="nf">last</span> <span class="p">(</span><span class="n">x</span> <span class="kt">:</span> <span class="n">xs</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last&#39;</span> <span class="n">x</span> <span class="n">xs</span>
    <span class="kr">where</span>
      <span class="n">last&#39;</span> <span class="n">x</span> <span class="kt">[]</span>       <span class="ow">=</span> <span class="n">x</span>
      <span class="n">last&#39;</span> <span class="n">x</span> <span class="p">(</span><span class="n">y</span> <span class="kt">:</span> <span class="n">ys</span><span class="p">)</span> <span class="ow">=</span> <span class="n">last&#39;</span> <span class="n">y</span> <span class="n">ys</span>
</pre></div>
</div>
<p>As well avoid unnecessary pattern matching it also helps avoid
unnecessary allocation. This applies when a argument is strict in
the recursive call to itself but not on the initial entry. As strict
recursive branch of the function is created similar to the above
example.</p>
<p>It is also possible for library writers to instruct GHC to perform
call-pattern specialisation extremely aggressively. This is
necessary for some highly optimized libraries, where we may want to
specialize regardless of the number of specialisations, or the size
of the code. As an example, consider a simplified use-case from the
<code class="docutils literal"><span class="pre">vector</span></code> library:</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">import</span> <span class="nn">GHC.Types</span> <span class="p">(</span><span class="kt">SPEC</span><span class="p">(</span><span class="o">..</span><span class="p">))</span>

<span class="nf">foldl</span> <span class="ow">::</span> <span class="p">(</span><span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span><span class="p">)</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Stream</span> <span class="n">b</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="cm">{-# INLINE foldl #-}</span>
<span class="nf">foldl</span> <span class="n">f</span> <span class="n">z</span> <span class="p">(</span><span class="kt">Stream</span> <span class="n">step</span> <span class="n">s</span> <span class="kr">_</span><span class="p">)</span> <span class="ow">=</span> <span class="n">foldl_loop</span> <span class="kt">SPEC</span> <span class="n">z</span> <span class="n">s</span>
  <span class="kr">where</span>
    <span class="n">foldl_loop</span> <span class="o">!</span><span class="n">sPEC</span> <span class="n">z</span> <span class="n">s</span> <span class="ow">=</span> <span class="kr">case</span> <span class="n">step</span> <span class="n">s</span> <span class="kr">of</span>
                            <span class="kt">Yield</span> <span class="n">x</span> <span class="n">s&#39;</span> <span class="ow">-&gt;</span> <span class="n">foldl_loop</span> <span class="n">sPEC</span> <span class="p">(</span><span class="n">f</span> <span class="n">z</span> <span class="n">x</span><span class="p">)</span> <span class="n">s&#39;</span>
                            <span class="kt">Skip</span>       <span class="ow">-&gt;</span> <span class="n">foldl_loop</span> <span class="n">sPEC</span> <span class="n">z</span> <span class="n">s&#39;</span>
                            <span class="kt">Done</span>       <span class="ow">-&gt;</span> <span class="n">z</span>
</pre></div>
</div>
<p>Here, after GHC inlines the body of <code class="docutils literal"><span class="pre">foldl</span></code> to a call site, it
will perform call-pattern specialisation very aggressively on
<code class="docutils literal"><span class="pre">foldl_loop</span></code> due to the use of <code class="docutils literal"><span class="pre">SPEC</span></code> in the argument of the
loop body. <code class="docutils literal"><span class="pre">SPEC</span></code> from <code class="docutils literal"><span class="pre">GHC.Types</span></code> is specifically recognised by
the compiler.</p>
<p>(NB: it is extremely important you use <code class="docutils literal"><span class="pre">seq</span></code> or a bang pattern on
the <code class="docutils literal"><span class="pre">SPEC</span></code> argument!)</p>
<p>In particular, after inlining this will expose <code class="docutils literal"><span class="pre">f</span></code> to the loop
body directly, allowing heavy specialisation over the recursive
cases.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr-count">
<code class="descname">-fspec-constr-count</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fspec-constr-count" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">3</td>
</tr>
</tbody>
</table>
<p>Set the maximum number of specialisations that will be created for
any one function by the SpecConstr transformation.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspec-constr-threshold">
<code class="descname">-fspec-constr-threshold</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fspec-constr-threshold" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">2000</td>
</tr>
</tbody>
</table>
<p>Set the size threshold for the SpecConstr transformation.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fspecialise">
<code class="descname">-fspecialise</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fspecialise" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Specialise each type-class-overloaded function
defined in this module for the types at which it is called in this
module. If <a class="reference internal" href="#ghc-flag--fcross-module-specialise"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-fcross-module-specialise</span></code></a> is set imported functions
that have an INLINABLE pragma (<a class="reference internal" href="glasgow_exts.html#inlinable-pragma"><span>INLINABLE pragma</span></a>) will be
specialised as well.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fcross-module-specialise">
<code class="descname">-fcross-module-specialise</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fcross-module-specialise" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Specialise <code class="docutils literal"><span class="pre">INLINABLE</span></code> (<a class="reference internal" href="glasgow_exts.html#inlinable-pragma"><span>INLINABLE pragma</span></a>)
type-class-overloaded functions imported from other modules for the types at
which they are called in this module. Note that specialisation must be
enabled (by <code class="docutils literal"><span class="pre">-fspecialise</span></code>) for this to have any effect.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstatic-argument-transformation">
<code class="descname">-fstatic-argument-transformation</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fstatic-argument-transformation" title="Permalink to this definition">¶</a></dt>
<dd><p>Turn on the static argument transformation, which turns a recursive
function into a non-recursive one with a local recursive loop. See
Chapter 7 of <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/santos-thesis.ps.gz">Andre Santos&#8217;s PhD
thesis</a></p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstrictness">
<code class="descname">-fstrictness</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fstrictness" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p>Switch on the strictness analyser. There is a very
old paper about GHC&#8217;s strictness analyser, <a class="reference external" href="http://research.microsoft.com/en-us/um/people/simonpj/papers/simple-strictnes-analyser.ps.gz">Measuring the
effectiveness of a simple strictness
analyser</a>,
but the current one is quite a bit different.</p>
<p>The strictness analyser figures out when arguments and variables in
a function can be treated &#8216;strictly&#8217; (that is they are always
evaluated in the function at some point). This allow GHC to apply
certain optimisations such as unboxing that otherwise don&#8217;t apply as
they change the semantics of the program when applied to lazy
arguments.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fstrictness-before">
<code class="descname">-fstrictness-before</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--fstrictness-before" title="Permalink to this definition">¶</a></dt>
<dd><p>Run an additional strictness analysis before simplifier phase ⟨n⟩.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funbox-small-strict-fields">
<code class="descname">-funbox-small-strict-fields</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--funbox-small-strict-fields" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p id="index-5">This option causes all constructor fields which
are marked strict (i.e. “!”) and which representation is smaller or
equal to the size of a pointer to be unpacked, if possible. It is
equivalent to adding an <code class="docutils literal"><span class="pre">UNPACK</span></code> pragma (see <a class="reference internal" href="glasgow_exts.html#unpack-pragma"><span>UNPACK pragma</span></a>)
to every strict constructor field that fulfils the size restriction.</p>
<p>For example, the constructor fields in the following data types</p>
<div class="highlight-haskell"><div class="highlight"><pre><span class="kr">data</span> <span class="kt">A</span> <span class="ow">=</span> <span class="kt">A</span> <span class="o">!</span><span class="kt">Int</span>
<span class="kr">data</span> <span class="kt">B</span> <span class="ow">=</span> <span class="kt">B</span> <span class="o">!</span><span class="kt">A</span>
<span class="kr">newtype</span> <span class="kt">C</span> <span class="ow">=</span> <span class="kt">C</span> <span class="kt">B</span>
<span class="kr">data</span> <span class="kt">D</span> <span class="ow">=</span> <span class="kt">D</span> <span class="o">!</span><span class="kt">C</span>
</pre></div>
</div>
<p>would all be represented by a single <code class="docutils literal"><span class="pre">Int#</span></code> (see
<a class="reference internal" href="glasgow_exts.html#primitives"><span>Unboxed types and primitive operations</span></a>) value with <code class="docutils literal"><span class="pre">-funbox-small-strict-fields</span></code>
enabled.</p>
<p>This option is less of a sledgehammer than
<code class="docutils literal"><span class="pre">-funbox-strict-fields</span></code>: it should rarely make things worse. If
you use <code class="docutils literal"><span class="pre">-funbox-small-strict-fields</span></code> to turn on unboxing by
default you can disable it for certain constructor fields using the
<code class="docutils literal"><span class="pre">NOUNPACK</span></code> pragma (see <a class="reference internal" href="glasgow_exts.html#nounpack-pragma"><span>NOUNPACK pragma</span></a>).</p>
<p>Note that for consistency <code class="docutils literal"><span class="pre">Double</span></code>, <code class="docutils literal"><span class="pre">Word64</span></code>, and <code class="docutils literal"><span class="pre">Int64</span></code>
constructor fields are unpacked on 32-bit platforms, even though
they are technically larger than a pointer on those platforms.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funbox-strict-fields">
<code class="descname">-funbox-strict-fields</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--funbox-strict-fields" title="Permalink to this definition">¶</a></dt>
<dd><p id="index-6">This option causes all constructor fields which are marked strict
(i.e. <code class="docutils literal"><span class="pre">!</span></code>) to be unpacked if possible. It is equivalent to adding an
<code class="docutils literal"><span class="pre">UNPACK</span></code> pragma to every strict constructor field (see
<a class="reference internal" href="glasgow_exts.html#unpack-pragma"><span>UNPACK pragma</span></a>).</p>
<p>This option is a bit of a sledgehammer: it might sometimes make
things worse. Selectively unboxing fields by using <code class="docutils literal"><span class="pre">UNPACK</span></code>
pragmas might be better. An alternative is to use
<code class="docutils literal"><span class="pre">-funbox-strict-fields</span></code> to turn on unboxing by default but disable
it for certain constructor fields using the <code class="docutils literal"><span class="pre">NOUNPACK</span></code> pragma (see
<a class="reference internal" href="glasgow_exts.html#nounpack-pragma"><span>NOUNPACK pragma</span></a>).</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-creation-threshold">
<code class="descname">-funfolding-creation-threshold</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-creation-threshold" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">750</td>
</tr>
</tbody>
</table>
<p id="index-7">Governs the maximum size that GHC will allow a
function unfolding to be. (An unfolding has a “size” that reflects
the cost in terms of “code bloat” of expanding (aka inlining) that
unfolding at a call site. A bigger function would be assigned a
bigger cost.)</p>
<p>Consequences:</p>
<ol class="loweralpha simple">
<li>nothing larger than this will be inlined (unless it has an <code class="docutils literal"><span class="pre">INLINE</span></code> pragma)</li>
<li>nothing larger than this will be spewed into an interface file.</li>
</ol>
<p>Increasing this figure is more likely to result in longer compile
times than faster code. The <a class="reference internal" href="#ghc-flag--funfolding-use-threshold"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-funfolding-use-threshold</span></code></a> is more
useful.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-dict-discount">
<code class="descname">-funfolding-dict-discount</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-dict-discount" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">30</td>
</tr>
</tbody>
</table>
<p id="index-8">How eager should the compiler be to inline dictionaries?</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-fun-discount">
<code class="descname">-funfolding-fun-discount</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-fun-discount" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">60</td>
</tr>
</tbody>
</table>
<p id="index-9">How eager should the compiler be to inline functions?</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-keeness-factor">
<code class="descname">-funfolding-keeness-factor</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-keeness-factor" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">1.5</td>
</tr>
</tbody>
</table>
<p id="index-10">How eager should the compiler be to inline functions?</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--funfolding-use-threshold">
<code class="descname">-funfolding-use-threshold</code><code class="descclassname">=⟨n⟩</code><a class="headerlink" href="#ghc-flag--funfolding-use-threshold" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">60</td>
</tr>
</tbody>
</table>
<p id="index-11">This is the magic cut-off figure for unfolding (aka
inlining): below this size, a function definition will be unfolded
at the call-site, any bigger and it won&#8217;t. The size computed for a
function depends on two things: the actual size of the expression
minus any discounts that apply depending on the context into which
the expression is to be inlined.</p>
<p>The difference between this and <a class="reference internal" href="#ghc-flag--funfolding-creation-threshold"><code class="xref std std-ghc-flag docutils literal"><span class="pre">-funfolding-creation-threshold</span></code></a>
is that this one determines if a function definition will be inlined
<em>at a call site</em>. The other option determines if a function
definition will be kept around at all for potential inlining.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fvectorisation-avoidance">
<code class="descname">-fvectorisation-avoidance</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fvectorisation-avoidance" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">on</td>
</tr>
</tbody>
</table>
<p id="index-12">Part of <a class="reference internal" href="parallel.html#dph"><span>Data Parallel Haskell (DPH)</span></a>.</p>
<p>Enable the <em>vectorisation</em> avoidance optimisation.
This optimisation only works when used in combination with the
<code class="docutils literal"><span class="pre">-fvectorise</span></code> transformation.</p>
<p>While vectorisation of code using DPH is often a big win, it can
also produce worse results for some kinds of code. This optimisation
modifies the vectorisation transformation to try to determine if a
function would be better of unvectorised and if so, do just that.</p>
</dd></dl>

<dl class="ghc-flag">
<dt id="ghc-flag--fvectorise">
<code class="descname">-fvectorise</code><code class="descclassname"> </code><a class="headerlink" href="#ghc-flag--fvectorise" title="Permalink to this definition">¶</a></dt>
<dd><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Default:</th><td class="field-body">off</td>
</tr>
</tbody>
</table>
<p>Part of <a class="reference internal" href="parallel.html#dph"><span>Data Parallel Haskell (DPH)</span></a>.</p>
<p>Enable the <em>vectorisation</em> optimisation
transformation. This optimisation transforms the nested data
parallelism code of programs using DPH into flat data parallelism.
Flat data parallel programs should have better load balancing,
enable SIMD parallelism and friendlier cache behaviour.</p>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="using-concurrent.html" title="7.4. Using Concurrent Haskell"
             >next</a> |</li>
        <li class="right" >
          <a href="using-warnings.html" title="7.2. 警告と整合性検査"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">GHC 8.0.2 Users Guide</a> &raquo;</li>
          <li class="nav-item nav-item-1"><a href="usage.html" >7. GHCを使う</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &copy; Copyright 2015, GHC Team.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.3.6.
    </div>
  </body>
</html>